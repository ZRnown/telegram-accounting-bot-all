./middleware.ts
./app/security/page.tsx
./app/cookie-helper/page.tsx
./app/admin/audit-logs/page.tsx
./app/admin/custom-commands/page.tsx
./app/admin/layout.tsx
./app/dashboard/page.tsx
./app/layout.tsx
./app/api/bots/introspect/route.ts
./app/api/bots/route.ts
./app/api/bots/[id]/features/route.ts
./app/api/bots/[id]/groups/[groupId]/route.ts
./app/api/bots/[id]/groups/route.ts
./app/api/bots/[id]/welcome-message/route.ts
./app/api/bots/[id]/route.ts
./app/api/bots/[id]/commands/route.ts
./app/api/bots/[id]/broadcast/route.ts
./app/api/audit-logs/route.ts
./app/api/_auth.ts
./app/api/auth/logout/route.ts
./app/api/auth/logout-all/route.ts
./app/api/auth/me/route.ts
./app/api/auth/change-password/route.ts
./app/api/auth/login/route.ts
./app/api/uploads/route.ts
./app/api/transactions/route.ts
./app/api/global-config/commands/route.ts
./app/api/bills/route.ts
./app/api/bills/[id]/route.ts
./app/api/custom-commands/image/route.ts
./app/api/custom-commands/route.ts
./app/api/telegram/get-user/route.ts
./app/api/chats/manual-add/route.ts
./app/api/chats/route.ts
./app/api/chats/[id]/settings/route.ts
./app/api/chats/[id]/operators/route.ts
./app/api/chats/[id]/group/route.ts
./app/api/chats/[id]/features/route.ts
./app/api/chats/[id]/route.ts
./app/api/chats/[id]/eligible-bots/route.ts
./app/api/whitelisted-users/route.ts
./app/api/stats/today/route.ts
./app/api/stats/current-date/route.ts
./app/api/stats/30d/route.ts
./app/api/stats/weekly/route.ts
./app/chats/[id]/page.tsx
./app/chats/page.tsx
./app/page.tsx
./app/weekly/page.tsx
./app/summary/page.tsx
./test-safew.js
./safew-config.js
./middleware-proxy.ts
./next-env.d.ts
./components/theme-provider.tsx
./components/ui/aspect-ratio.tsx
./components/ui/alert-dialog.tsx
./components/ui/use-mobile.tsx
./components/ui/pagination.tsx
./components/ui/tabs.tsx
./components/ui/button-group.tsx
./components/ui/card.tsx
./components/ui/slider.tsx
./components/ui/input-group.tsx
./components/ui/popover.tsx
./components/ui/progress.tsx
./components/ui/toaster.tsx
./components/ui/input-otp.tsx
./components/ui/chart.tsx
./components/ui/hover-card.tsx
./components/ui/sheet.tsx
./components/ui/field.tsx
./components/ui/scroll-area.tsx
./components/ui/resizable.tsx
./components/ui/label.tsx
./components/ui/sonner.tsx
./components/ui/navigation-menu.tsx
./components/ui/accordion.tsx
./components/ui/drawer.tsx
./components/ui/empty.tsx
./components/ui/tooltip.tsx
./components/ui/alert.tsx
./components/ui/use-toast.ts
./components/ui/switch.tsx
./components/ui/calendar.tsx
./components/ui/breadcrumb.tsx
./components/ui/radio-group.tsx
./components/ui/command.tsx
./components/ui/item.tsx
./components/ui/toggle-group.tsx
./components/ui/avatar.tsx
./components/ui/menubar.tsx
./components/ui/kbd.tsx
./components/ui/dialog.tsx
./components/ui/badge.tsx
./components/ui/sidebar.tsx
./components/ui/table.tsx
./components/ui/separator.tsx
./components/ui/button.tsx
./components/ui/toggle.tsx
./components/ui/toast.tsx
./components/ui/checkbox.tsx
./components/ui/spinner.tsx
./components/ui/collapsible.tsx
./components/ui/dropdown-menu.tsx
./components/ui/select.tsx
./components/ui/textarea.tsx
./components/ui/input.tsx
./components/ui/skeleton.tsx
./components/ui/context-menu.tsx
./components/ui/form.tsx
./components/ui/carousel.tsx
./components/error-boundary.tsx
./components/statistics-cards.tsx
./components/category-stats.tsx
./components/transaction-tables.tsx
./components/login-form.tsx
./components/dashboard-header.tsx
./hooks/use-mobile.ts
./hooks/use-toast.ts
./lib/okx-api.js
./lib/export-excel.js
./lib/db.js
./lib/utils.js
./bot/constants.js
./bot/database.js
./bot/logger.js
./bot/formatting.js
./bot/bot-identity.js
./bot/core-middleware.js
./bot/index.js
./bot/commands-registry.js
./bot/state.js
./bot/middleware.js
./bot/manager.js
./bot/helpers.js
./bot/lru-cache.js
./bot/utils.js
./bot/handlers/extended.js
./bot/handlers/modes.js
./bot/handlers/core.js
./bot/handlers/bill.js
./bot/handlers/okx.js
./bot/handlers/message-handler.js
./bot/handlers/index.js
./bot/handlers/custom.js
./bot/handlers/accounting.js
./bot/handlers/member-handler.js
./bot/handlers/admin.js
./bot/handlers/custom-command-handler.js
./bot/handlers/settings.js
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// ğŸ”¥ æœ¬åœ°å¼€å‘ç¯å¢ƒä¸­é—´ä»¶ï¼ˆç®€åŒ–ç‰ˆï¼‰
// ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ middleware-proxy.ts

export function middleware(request: NextRequest) {
  // æœ¬åœ°å¼€å‘ç¯å¢ƒè·³è¿‡å¤æ‚çš„å®‰å…¨æ£€æŸ¥
  // åªä¿ç•™åŸºæœ¬çš„è·¯å¾„éªŒè¯

  const { pathname } = request.nextUrl

  // ğŸ”¥ é˜²æ­¢è·¯å¾„éå†æ”»å‡»ï¼ˆåŸºæœ¬æ£€æŸ¥ï¼‰
  if (pathname.includes('..') || pathname.includes('\\')) {
    return new NextResponse('Forbidden', { status: 403 })
  }

  // æœ¬åœ°å¼€å‘ç¯å¢ƒå…è®¸æ‰€æœ‰è¯·æ±‚é€šè¿‡
  return NextResponse.next()
}

// ğŸ”¥ é…ç½®ä¸­é—´ä»¶åŒ¹é…çš„è·¯å¾„ï¼ˆæœ¬åœ°å¼€å‘ï¼‰
export const config = {
  matcher: [
    /*
     * æœ¬åœ°å¼€å‘ç¯å¢ƒï¼šåªå¯¹APIè·¯å¾„è¿›è¡ŒåŸºæœ¬æ£€æŸ¥
     */
    '/api/:path*',
  ],
}
"use client"

import { useEffect, useState } from "react"
import { useRouter } from "next/navigation"

export default function SecurityPage() {
  const router = useRouter()
  const [mounted, setMounted] = useState(false)
  const [username, setUsername] = useState("")
  const [oldPassword, setOldPassword] = useState("")
  const [newPassword, setNewPassword] = useState("")
  const [confirm, setConfirm] = useState("")
  const [error, setError] = useState("")
  const [ok, setOk] = useState("")
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    setMounted(true)
    const token = localStorage.getItem("auth_token")
    if (!token) {
      router.push("/")
      return
    }
    const u = localStorage.getItem("auth_user") || "admin"
    setUsername(u)
  }, [router])

  if (!mounted) return null

  return (
    <div className="min-h-screen bg-slate-50">
      <div className="container mx-auto px-4 py-6 max-w-xl">
        <div className="bg-white border rounded-lg p-6">
          <div className="text-lg font-semibold mb-4">å®‰å…¨è®¾ç½®</div>
          <div className="space-y-3">
            <div>
              <label className="block text-sm text-slate-600 mb-1">ç”¨æˆ·å</label>
              <input
                className="w-full border rounded px-3 py-2 text-sm"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                placeholder="è¯·è¾“å…¥ç”¨æˆ·å"
              />
            </div>
            <div>
              <label className="block text-sm text-slate-600 mb-1">åŸå¯†ç </label>
              <input
                type="password"
                className="w-full border rounded px-3 py-2 text-sm"
                value={oldPassword}
                onChange={(e) => setOldPassword(e.target.value)}
                placeholder="è¯·è¾“å…¥åŸå¯†ç "
              />
            </div>
            <div>
              <label className="block text-sm text-slate-600 mb-1">æ–°å¯†ç </label>
              <input
                type="password"
                className="w-full border rounded px-3 py-2 text-sm"
                value={newPassword}
                onChange={(e) => setNewPassword(e.target.value)}
                placeholder="è¯·è¾“å…¥æ–°å¯†ç ï¼ˆè‡³å°‘6ä½ï¼‰"
              />
            </div>
            <div>
              <label className="block text-sm text-slate-600 mb-1">ç¡®è®¤æ–°å¯†ç </label>
              <input
                type="password"
                className="w-full border rounded px-3 py-2 text-sm"
                value={confirm}
                onChange={(e) => setConfirm(e.target.value)}
                placeholder="è¯·å†æ¬¡è¾“å…¥æ–°å¯†ç "
              />
            </div>
            {error && <div className="text-sm text-red-600">{error}</div>}
            {ok && <div className="text-sm text-green-600">{ok}</div>}
            <div className="flex items-center gap-3">
              <button
                className="px-3 py-2 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
                disabled={loading}
                onClick={async () => {
                  setError("")
                  setOk("")
                  if (!username.trim()) { setError("ç”¨æˆ·åä¸èƒ½ä¸ºç©º"); return }
                  if (!oldPassword || !newPassword) { setError("è¯·å¡«å†™å®Œæ•´"); return }
                  if (newPassword !== confirm) { setError("ä¸¤æ¬¡è¾“å…¥çš„æ–°å¯†ç ä¸ä¸€è‡´"); return }
                  setLoading(true)
                  try {
                    const res = await fetch('/api/auth/change-password', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ username, oldPassword, newPassword })
                    })
                    if (res.status === 204) {
                      setOk("ä¿®æ”¹æˆåŠŸï¼Œè¯·ä½¿ç”¨æ–°å¯†ç é‡æ–°ç™»å½•")
                      // é€€å‡ºé‡æ–°ç™»å½•
                      localStorage.removeItem('auth_token')
                      localStorage.setItem('auth_user', username)
                      setTimeout(() => router.push('/'), 1200)
                    } else {
                      const text = await res.text().catch(() => '')
                      setError(text || 'ä¿®æ”¹å¤±è´¥')
                    }
                  } catch {
                    setError('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•')
                  } finally {
                    setLoading(false)
                  }
                }}
              >{loading ? 'æäº¤ä¸­...' : 'ä¿å­˜ä¿®æ”¹'}</button>
              <button
                className="px-3 py-2 text-sm border rounded-md hover:bg-slate-50"
                onClick={() => router.push('/dashboard')}
              >è¿”å›</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
"use client"

import { useState } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Alert, AlertDescription } from "@/components/ui/alert"

export default function CookieHelperPage() {
  const [cookieString, setCookieString] = useState("")
  const [parsedCookies, setParsedCookies] = useState<Record<string, string>>({})
  const [error, setError] = useState("")

  const parseCookies = () => {
    try {
      setError("")
      if (!cookieString.trim()) {
        setError("è¯·è¾“å…¥ Cookie å­—ç¬¦ä¸²")
        return
      }

      const cookies: Record<string, string> = {}
      const parts = cookieString.split(";")
      
      for (const part of parts) {
        const [key, value] = part.trim().split("=").map(s => s.trim())
        if (key && value) {
          cookies[key] = value
        }
      }

      setParsedCookies(cookies)
    } catch (e: any) {
      setError(`è§£æå¤±è´¥: ${e.message}`)
    }
  }

  const checkRequiredCookies = () => {
    const required = ["stel_ssid", "stel_dt", "stel_ton_token"]
    const missing = required.filter(key => !parsedCookies[key])
    return missing
  }

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text)
    alert("å·²å¤åˆ¶åˆ°å‰ªè´´æ¿")
  }

  const missingCookies = checkRequiredCookies()

  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <Card>
        <CardHeader>
          <CardTitle>Telegram Fragment API Cookie åŠ©æ‰‹</CardTitle>
          <CardDescription>
            å¸®åŠ©æ‚¨æŸ¥çœ‹å’Œè®¾ç½® Telegram Fragment API æ‰€éœ€çš„ Cookie
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <Alert>
            <AlertDescription>
              <strong>å¦‚ä½•è·å– Cookieï¼š</strong>
              <ol className="list-decimal list-inside mt-2 space-y-1">
                <li>æ‰“å¼€æµè§ˆå™¨ï¼Œè®¿é—® <code className="bg-slate-100 px-1 rounded">https://web.telegram.org</code></li>
                <li>ç™»å½•æ‚¨çš„ Telegram è´¦å·</li>
                <li>æ‰“å¼€å¼€å‘è€…å·¥å…·ï¼ˆF12 æˆ–å³é”® â†’ æ£€æŸ¥ï¼‰</li>
                <li>åœ¨ Console ä¸­æ‰§è¡Œï¼š<code className="bg-slate-100 px-1 rounded">document.cookie</code></li>
                <li>å¤åˆ¶è¾“å‡ºçš„ Cookie å­—ç¬¦ä¸²å¹¶ç²˜è´´åˆ°ä¸‹æ–¹</li>
              </ol>
            </AlertDescription>
          </Alert>

          <div className="space-y-2">
            <Label htmlFor="cookie-input">Cookie å­—ç¬¦ä¸²</Label>
            <textarea
              id="cookie-input"
              className="w-full min-h-[120px] p-3 border rounded-md font-mono text-sm"
              placeholder="ç²˜è´´å®Œæ•´çš„ Cookie å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ï¼šstel_ssid=xxx; stel_dt=xxx; stel_ton_token=xxx; ..."
              value={cookieString}
              onChange={(e) => setCookieString(e.target.value)}
            />
            <Button onClick={parseCookies}>è§£æ Cookie</Button>
          </div>

          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {Object.keys(parsedCookies).length > 0 && (
            <div className="space-y-4">
              <div>
                <h3 className="font-semibold mb-2">è§£æç»“æœï¼š</h3>
                {missingCookies.length > 0 && (
                  <Alert variant="destructive" className="mb-4">
                    <AlertDescription>
                      <strong>ç¼ºå°‘å¿…éœ€çš„ Cookieï¼š</strong> {missingCookies.join(", ")}
                    </AlertDescription>
                  </Alert>
                )}
                {missingCookies.length === 0 && (
                  <Alert className="mb-4 bg-green-50 border-green-200">
                    <AlertDescription className="text-green-800">
                      âœ… æ‰€æœ‰å¿…éœ€çš„ Cookie éƒ½å·²æ‰¾åˆ°
                    </AlertDescription>
                  </Alert>
                )}
              </div>

              <div className="space-y-2">
                <h4 className="font-medium">å¿…éœ€çš„ Cookieï¼š</h4>
                {["stel_ssid", "stel_dt", "stel_ton_token"].map((key) => {
                  const value = parsedCookies[key]
                  const exists = !!value
                  return (
                    <div key={key} className="p-3 border rounded-md">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <span className="font-mono text-sm font-semibold">{key}</span>
                          {exists ? (
                            <span className="text-xs text-green-600">âœ“ å·²æ‰¾åˆ°</span>
                          ) : (
                            <span className="text-xs text-red-600">âœ— ç¼ºå¤±</span>
                          )}
                        </div>
                        {exists && (
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => copyToClipboard(value)}
                          >
                            å¤åˆ¶
                          </Button>
                        )}
                      </div>
                      {exists && (
                        <div className="mt-2">
                          <code className="text-xs bg-slate-100 p-2 rounded block break-all">
                            {value.length > 100 ? `${value.substring(0, 100)}... (${value.length} å­—ç¬¦)` : value}
                          </code>
                        </div>
                      )}
                    </div>
                  )
                })}
              </div>

              <div className="space-y-2">
                <h4 className="font-medium">å…¶ä»– Cookieï¼š</h4>
                <div className="max-h-60 overflow-y-auto space-y-1">
                  {Object.entries(parsedCookies)
                    .filter(([key]) => !["stel_ssid", "stel_dt", "stel_ton_token"].includes(key))
                    .map(([key, value]) => (
                      <div key={key} className="p-2 border rounded text-sm">
                        <span className="font-mono font-semibold">{key}:</span>{" "}
                        <span className="text-slate-600">
                          {value.length > 50 ? `${value.substring(0, 50)}...` : value}
                        </span>
                      </div>
                    ))}
                </div>
              </div>

              <div className="space-y-2">
                <h4 className="font-medium">ç¯å¢ƒå˜é‡è®¾ç½®ï¼š</h4>
                <Alert>
                  <AlertDescription>
                    <p className="mb-2">å°†ä»¥ä¸‹å†…å®¹æ·»åŠ åˆ°æ‚¨çš„ <code className="bg-slate-100 px-1 rounded">.env</code> æ–‡ä»¶ä¸­ï¼š</p>
                    <div className="bg-slate-900 text-green-400 p-4 rounded font-mono text-sm space-y-1">
                      <div>
                        FRAGMENT_COOKIE={cookieString}
                      </div>
                      {parsedCookies.stel_ton_token && (
                        <div>
                          FRAGMENT_HASH={parsedCookies.stel_ton_token.substring(0, 16)}
                        </div>
                      )}
                    </div>
                    <Button
                      className="mt-2"
                      onClick={() => {
                        let envContent = `FRAGMENT_COOKIE=${cookieString}\n`
                        if (parsedCookies.stel_ton_token) {
                          envContent += `FRAGMENT_HASH=${parsedCookies.stel_ton_token.substring(0, 16)}\n`
                        }
                        copyToClipboard(envContent)
                      }}
                    >
                      å¤åˆ¶ç¯å¢ƒå˜é‡é…ç½®
                    </Button>
                  </AlertDescription>
                </Alert>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  )
}

"use client"

import { useEffect, useMemo, useState } from 'react'

type Item = { id: string; username?: string; action?: string; target?: string; ip?: string; createdAt?: string }

type Query = { page: number; size: number; username: string; ip: string; action: string; from: string; to: string }

export default function AuditLogsPage() {
  const [q, setQ] = useState<Query>({ page: 1, size: 20, username: '', ip: '', action: '', from: '', to: '' })
  const [loading, setLoading] = useState(false)
  const [items, setItems] = useState<Item[]>([])
  const [total, setTotal] = useState(0)
  const [error, setError] = useState<string | null>(null)

  const params = useMemo(() => {
    const sp = new URLSearchParams()
    sp.set('page', String(q.page))
    sp.set('size', String(q.size))
    if (q.username.trim()) sp.set('username', q.username.trim())
    if (q.ip.trim()) sp.set('ip', q.ip.trim())
    if (q.action.trim()) sp.set('action', q.action.trim())
    if (q.from) sp.set('from', q.from)
    if (q.to) sp.set('to', q.to)
    return sp.toString()
  }, [q])

  const fetchData = async () => {
    setLoading(true)
    setError(null)
    try {
      const res = await fetch(`/api/audit-logs?${params}`, { cache: 'no-store' })
      const data = await res.json().catch(() => ({}))
      if (!res.ok) throw new Error(data?.error || 'åŠ è½½å¤±è´¥')
      setItems(Array.isArray(data.items) ? data.items : [])
      setTotal(Number(data.total || 0))
    } catch (e: any) {
      setError(e?.message || 'åŠ è½½å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => { fetchData() }, [params])

  const totalPages = Math.max(1, Math.ceil(total / q.size))

  return (
    <div className="p-4 max-w-6xl mx-auto">
      <div className="flex items-center gap-2 mb-4">
        <h1 className="text-xl font-semibold">å®¡è®¡æ—¥å¿—</h1>
        <div className="flex-1" />
        <button className="px-3 py-1 border rounded" onClick={fetchData} disabled={loading}>{loading ? 'åˆ·æ–°ä¸­...' : 'åˆ·æ–°'}</button>
      </div>

      <div className="border rounded p-3 mb-4 grid gap-3 md:grid-cols-2 lg:grid-cols-3">
        <div>
          <div className="text-sm text-slate-600 mb-1">ç”¨æˆ·å</div>
          <input className="w-full border rounded px-3 py-2" value={q.username} onChange={e => setQ(s => ({ ...s, username: e.target.value, page: 1 }))} placeholder="admin" />
        </div>
        <div>
          <div className="text-sm text-slate-600 mb-1">IP</div>
          <input className="w-full border rounded px-3 py-2" value={q.ip} onChange={e => setQ(s => ({ ...s, ip: e.target.value, page: 1 }))} placeholder="127.0.0.1" />
        </div>
        <div>
          <div className="text-sm text-slate-600 mb-1">æ“ä½œ(Action)</div>
          <input className="w-full border rounded px-3 py-2" value={q.action} onChange={e => setQ(s => ({ ...s, action: e.target.value, page: 1 }))} placeholder="login_success" />
        </div>
        <div>
          <div className="text-sm text-slate-600 mb-1">èµ·å§‹æ—¶é—´(ISO)</div>
          <input className="w-full border rounded px-3 py-2" value={q.from} onChange={e => setQ(s => ({ ...s, from: e.target.value, page: 1 }))} placeholder="2025-01-01T00:00:00Z" />
        </div>
        <div>
          <div className="text-sm text-slate-600 mb-1">ç»“æŸæ—¶é—´(ISO)</div>
          <input className="w-full border rounded px-3 py-2" value={q.to} onChange={e => setQ(s => ({ ...s, to: e.target.value, page: 1 }))} placeholder="2025-01-31T23:59:59Z" />
        </div>
        <div className="flex items-end">
          <button className="px-3 py-2 border rounded w-full" onClick={() => setQ(s => ({ ...s, page: 1 }))}>åº”ç”¨ç­›é€‰</button>
        </div>
      </div>

      {error && <div className="text-red-600 mb-2">{error}</div>}

      <div className="overflow-x-auto border rounded">
        <table className="w-full text-sm">
          <thead className="bg-slate-50 text-slate-600">
            <tr>
              <th className="text-left px-3 py-2 border-b">æ—¶é—´</th>
              <th className="text-left px-3 py-2 border-b">ç”¨æˆ·å</th>
              <th className="text-left px-3 py-2 border-b">åŠ¨ä½œ</th>
              <th className="text-left px-3 py-2 border-b">ç›®æ ‡</th>
              <th className="text-left px-3 py-2 border-b">IP</th>
            </tr>
          </thead>
          <tbody>
            {items.length === 0 && (
              <tr><td colSpan={5} className="px-3 py-4 text-center text-slate-400">æš‚æ— æ•°æ®</td></tr>
            )}
            {items.map((it) => (
              <tr key={it.id} className="hover:bg-slate-50">
                <td className="px-3 py-2 border-b">{it.createdAt ? new Date(it.createdAt).toLocaleString() : ''}</td>
                <td className="px-3 py-2 border-b">{it.username || ''}</td>
                <td className="px-3 py-2 border-b">{it.action || ''}</td>
                <td className="px-3 py-2 border-b break-all">{it.target || ''}</td>
                <td className="px-3 py-2 border-b">{it.ip || ''}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <div className="flex items-center justify-between mt-3">
        <div className="text-sm text-slate-600">å…± {total} æ¡ï¼Œ{q.size} æ¡/é¡µ</div>
        <div className="flex items-center gap-2">
          <button className="px-3 py-1 border rounded disabled:opacity-50" onClick={() => setQ(s => ({ ...s, page: Math.max(1, s.page - 1) }))} disabled={q.page <= 1}>ä¸Šä¸€é¡µ</button>
          <div className="text-sm">{q.page} / {totalPages}</div>
          <button className="px-3 py-1 border rounded disabled:opacity-50" onClick={() => setQ(s => ({ ...s, page: Math.min(totalPages, s.page + 1) }))} disabled={q.page >= totalPages}>ä¸‹ä¸€é¡µ</button>
          <select className="px-2 py-1 border rounded" value={q.size} onChange={e => setQ(s => ({ ...s, size: Number(e.target.value), page: 1 }))}>
            {[10,20,50,100].map(n => <option key={n} value={n}>{n}/é¡µ</option>)}
          </select>
        </div>
      </div>
    </div>
  )
}
"use client"

import React, { useEffect, useMemo, useRef, useState } from 'react'
import { useSearchParams, useRouter } from 'next/navigation'
import { toast } from '@/hooks/use-toast'

type Item = {
  name: string
  text?: string
  imageUrl?: string
  updatedAt?: string
  updatedBy?: string
}

export default function CustomCommandsPage() {
  const searchParams = useSearchParams()
  const router = useRouter()
  const botId = useMemo(() => (searchParams?.get('botId') || '').trim(), [searchParams])
  const [mounted, setMounted] = useState(false)
  const [isAdmin, setIsAdmin] = useState(false)

  const [loading, setLoading] = useState(false)
  const [items, setItems] = useState<Item[]>([])
  const [error, setError] = useState<string | null>(null)

  // form state
  const [formName, setFormName] = useState('')
  const [formText, setFormText] = useState('')
  const [saving, setSaving] = useState(false)
  const [formImageUrl, setFormImageUrl] = useState('')

  // modal state for add/edit
  const [modalOpen, setModalOpen] = useState(false)
  const [modalMode, setModalMode] = useState<'create' | 'edit'>('create')
  const [modalName, setModalName] = useState('')
  const [modalText, setModalText] = useState('')
  const [modalImageUrl, setModalImageUrl] = useState('')
  const [modalSaving, setModalSaving] = useState(false)
  const fileInputRef = useRef<HTMLInputElement | null>(null)
  const [confirmDeleteName, setConfirmDeleteName] = useState<string | null>(null)

  const refresh = async () => {
    if (!botId) return
    setLoading(true)
    setError(null)
    try {
      const res = await fetch(`/api/custom-commands?botId=${encodeURIComponent(botId)}`)
      const data = await res.json()
      if (!res.ok) throw new Error(data?.error || 'åŠ è½½å¤±è´¥')
      setItems(Array.isArray(data.items) ? data.items : [])
    } catch (e: any) {
      setError(e?.message || 'åŠ è½½å¤±è´¥')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    setMounted(true)
    ;(async () => {
      try {
        const res = await fetch('/api/auth/me', { cache: 'no-store' })
        if (res.ok) {
          setIsAdmin(true)
        } else {
          setIsAdmin(false)
          router.push('/')
        }
      } catch {
        setIsAdmin(false)
        router.push('/')
      }
    })()
  }, [router])

  const copy = async (text: string) => {
    try {
      await navigator.clipboard.writeText(text)
      toast({ title: 'å·²å¤åˆ¶', description: text })
    } catch (e: any) {
      toast({ title: 'å¤åˆ¶å¤±è´¥', description: e?.message || '' , variant: 'destructive'})
    }
  }

  useEffect(() => {
    refresh()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [botId])

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!botId) { toast({ title: 'é”™è¯¯', description: 'ç¼ºå°‘ botId', variant: 'destructive' }); return }
    const name = formName.trim()
    if (!name) { toast({ title: 'æç¤º', description: 'è¯·è¾“å…¥æŒ‡ä»¤åç§°' }); return }
    try {
      setSaving(true)
      const res = await fetch('/api/custom-commands', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ botId, name, text: formText || '' })
      })
      const data = await res.json().catch(() => ({}))
      if (!res.ok) throw new Error(data?.error || 'ä¿å­˜å¤±è´¥')
      // if image url provided, then set image
      const img = (formImageUrl || '').trim()
      if (img.length > 0) {
        const ires = await fetch('/api/custom-commands/image', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ botId, name, imageUrl: img })
        })
        const idata = await ires.json().catch(() => ({}))
        if (!ires.ok) throw new Error(idata?.error || 'è®¾ç½®å›¾ç‰‡å¤±è´¥')
      }
      setFormName('')
      setFormText('')
      setFormImageUrl('')
      await refresh()
      toast({ title: 'æˆåŠŸ', description: 'å·²ä¿å­˜è‡ªå®šä¹‰æŒ‡ä»¤' })
    } catch (e: any) {
      toast({ title: 'é”™è¯¯', description: e?.message || 'ä¿å­˜å¤±è´¥', variant: 'destructive' })
    } finally {
      setSaving(false)
    }
  }

  const openCreateModal = () => {
    setModalMode('create')
    setModalName('')
    setModalText('')
    setModalImageUrl('')
    setModalOpen(true)
  }

  const openEditModal = (it: Item) => {
    setModalMode('edit')
    setModalName(it.name)
    setModalText(it.text || '')
    setModalImageUrl(it.imageUrl || '')
    setModalOpen(true)
  }

  const submitModal = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!botId) { toast({ title: 'é”™è¯¯', description: 'ç¼ºå°‘ botId', variant: 'destructive' }); return }
    const name = (modalName || '').trim()
    if (!name) { toast({ title: 'æç¤º', description: 'è¯·è¾“å…¥æŒ‡ä»¤åç§°' }); return }
    try {
      setModalSaving(true)
      // å…ˆæäº¤æ–‡æœ¬
      const res = await fetch('/api/custom-commands', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ botId, name, text: modalText || '' })
      })
      const data = await res.json().catch(() => ({}))
      if (!res.ok) throw new Error(data?.error || 'ä¿å­˜å¤±è´¥')
      // å†è®¾ç½®å›¾ç‰‡ï¼ˆå¯é€‰ï¼Œå¯æ¸…ç©ºï¼‰
      const image = (modalImageUrl || '').trim()
      if (image.length > 0 || modalMode === 'edit') {
        const ires = await fetch('/api/custom-commands/image', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ botId, name, imageUrl: image })
        })
        const idata = await ires.json().catch(() => ({}))
        if (!ires.ok) throw new Error(idata?.error || 'è®¾ç½®å›¾ç‰‡å¤±è´¥')
      }
      setModalOpen(false)
      await refresh()
      toast({ title: 'æˆåŠŸ', description: 'å·²ä¿å­˜è‡ªå®šä¹‰æŒ‡ä»¤' })
    } catch (e: any) {
      toast({ title: 'é”™è¯¯', description: e?.message || 'ä¿å­˜å¤±è´¥', variant: 'destructive' })
    } finally {
      setModalSaving(false)
    }
  }

  const setImage = (it: Item) => {
    // å¤ç”¨ç¼–è¾‘å¼¹çª—
    openEditModal(it)
  }

  const remove = async (name: string) => {
    if (!botId) { toast({ title: 'é”™è¯¯', description: 'ç¼ºå°‘ botId', variant: 'destructive' }); return }
    try {
      const res = await fetch('/api/custom-commands', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ botId, name })
      })
      const data = await res.json().catch(() => ({}))
      if (!res.ok) throw new Error(data?.error || 'åˆ é™¤å¤±è´¥')
      await refresh()
      toast({ title: 'æˆåŠŸ', description: 'å·²åˆ é™¤' })
    } catch (e: any) {
      toast({ title: 'é”™è¯¯', description: e?.message || 'åˆ é™¤å¤±è´¥', variant: 'destructive' })
    }
  }

  return (
    <div className="p-4 max-w-4xl mx-auto">
      <div className="flex items-center gap-2 mb-4">
        <button className="px-3 py-1 border rounded" onClick={() => router.back()}>è¿”å›</button>
        <h1 className="text-xl font-semibold">è‡ªå®šä¹‰æŒ‡ä»¤ç®¡ç†</h1>
        <div className="flex-1" />
        <button className="px-3 py-1 border rounded bg-black text-white" onClick={openCreateModal}>æ–°å¢æŒ‡ä»¤</button>
      </div>

      {/* éšè— botId å±•ç¤ºï¼Œä»…ä¿ç•™å†…éƒ¨ä½¿ç”¨ */}

      <form onSubmit={onSubmit} className="border rounded p-4 mb-6">
        <h2 className="font-medium mb-3">æ–°å¢ / ç¼–è¾‘æ–‡æœ¬å†…å®¹</h2>
        <div className="grid gap-3">
          <div>
            <label className="block text-sm text-gray-600 mb-1">æŒ‡ä»¤åç§°</label>
            <input className="w-full px-3 py-2 border rounded" placeholder="ä¾‹å¦‚ï¼šå°ååœ°å€" value={formName} onChange={e => setFormName(e.target.value)} />
          </div>
          <div>
            <label className="block text-sm text-gray-600 mb-1">æ–‡æœ¬å†…å®¹</label>
            <textarea className="w-full px-3 py-2 border rounded min-h-[100px]" placeholder="è¿™é‡Œæ˜¯å†…å®¹" value={formText} onChange={e => setFormText(e.target.value)} />
          </div>
          <div>
            <label className="block text-sm text-gray-600 mb-1">å›¾ç‰‡ URLï¼ˆå¯é€‰ï¼‰</label>
            <div className="flex gap-2 items-center">
              <input className="w-full px-3 py-2 border rounded" placeholder="https://.../image.png" value={formImageUrl} onChange={e => setFormImageUrl(e.target.value)} />
              <button type="button" className="px-3 py-2 rounded border" onClick={() => fileInputRef.current?.click()}>ä¸Šä¼ å›¾ç‰‡</button>
              <input ref={fileInputRef} className="hidden" type="file" accept="image/*" onChange={async (e) => {
                const f = e.target.files?.[0]
                if (!f) return
                try {
                  const fd = new FormData()
                  fd.append('file', f)
                  const r = await fetch('/api/uploads', { method: 'POST', body: fd })
                  const j = await r.json().catch(() => ({}))
                  if (!r.ok) throw new Error(j?.error || 'ä¸Šä¼ å¤±è´¥')
                  setFormImageUrl(j.url || '')
                  toast({ title: 'ä¸Šä¼ æˆåŠŸ', description: 'å›¾ç‰‡å·²ä¸Šä¼ ' })
                } catch (err: any) {
                  toast({ title: 'é”™è¯¯', description: err?.message || 'ä¸Šä¼ å¤±è´¥', variant: 'destructive' })
                } finally {
                  if (fileInputRef.current) fileInputRef.current.value = ''
                }
              }} />
            </div>
          </div>
          <div className="flex gap-2">
            <button type="submit" className="px-4 py-2 rounded bg-black text-white disabled:opacity-50" disabled={saving}>{saving ? 'ä¿å­˜ä¸­...' : 'ä¿å­˜'}</button>
            <button type="button" className="px-3 py-2 rounded border" onClick={() => { setFormName(''); setFormText('') }}>é‡ç½®</button>
          </div>
        </div>
      </form>

      <div className="flex items-center justify-between mb-2">
        <h2 className="font-medium">æŒ‡ä»¤åˆ—è¡¨</h2>
        <button className="px-3 py-1 border rounded" onClick={refresh} disabled={loading}>{loading ? 'åˆ·æ–°ä¸­...' : 'åˆ·æ–°'}</button>
      </div>
      {error && <div className="text-red-600 mb-2">{error}</div>}

      <div className="border rounded divide-y">
        {items.length === 0 && (
          <div className="p-4 text-gray-500">æš‚æ— æ•°æ®</div>
        )}
        {items.map((it) => (
          <div key={it.name} className="p-4 grid gap-2">
            <div className="flex items-center justify-between">
              <div className="font-medium">{it.name}</div>
              <div className="text-xs text-gray-500">{it.updatedAt ? new Date(it.updatedAt).toLocaleString() : ''}</div>
            </div>
            {it.text && (
              <div className="whitespace-pre-wrap text-sm bg-gray-50 p-2 rounded border">{it.text}</div>
            )}
            {it.imageUrl && (
              <div className="flex items-center gap-3">
                <img src={it.imageUrl} alt={it.name} className="w-24 h-24 object-cover rounded border" />
                <a className="text-blue-600 underline break-all" href={it.imageUrl} target="_blank" rel="noreferrer">{it.imageUrl}</a>
              </div>
            )}
            <div className="flex gap-2 mt-2">
              <button className="px-3 py-1 border rounded" onClick={() => openEditModal(it)}>ç¼–è¾‘</button>
              <button className="px-3 py-1 border rounded" onClick={() => setImage(it)}>è®¾ç½®å›¾ç‰‡</button>
              <button className="px-3 py-1 border rounded text-red-600" onClick={() => remove(it.name)}>åˆ é™¤</button>
            </div>
          </div>
        ))}
      </div>

      {/* åˆ é™¤å¿«é€Ÿå¤åˆ¶åŒºåŸŸï¼Œä¿æŒé¡µé¢ç®€æ´ */}

      {/* Modal for create/edit */}
      {modalOpen && (
        <div className="fixed inset-0 z-50 flex items-center justify-center">
          <div className="absolute inset-0 bg-black/40" onClick={() => !modalSaving && setModalOpen(false)} />
          <div className="relative bg-white rounded-lg shadow-lg w-full max-w-lg p-5">
            <div className="text-lg font-medium mb-3">{modalMode === 'create' ? 'æ–°å¢æŒ‡ä»¤' : 'ç¼–è¾‘æŒ‡ä»¤'}</div>
            <form onSubmit={submitModal} className="grid gap-3">
              <div>
                <label className="block text-sm text-gray-600 mb-1">æŒ‡ä»¤åç§°</label>
                <input className="w-full px-3 py-2 border rounded disabled:opacity-60" placeholder="ä¾‹å¦‚ï¼šå°ååœ°å€" value={modalName} onChange={e => setModalName(e.target.value)} disabled={modalMode === 'edit'} />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">æ–‡æœ¬å†…å®¹</label>
                <textarea className="w-full px-3 py-2 border rounded min-h-[100px]" placeholder="è¿™é‡Œæ˜¯å†…å®¹" value={modalText} onChange={e => setModalText(e.target.value)} />
              </div>
              <div>
                <label className="block text-sm text-gray-600 mb-1">å›¾ç‰‡ URLï¼ˆå¯é€‰ï¼Œç•™ç©ºè¡¨ç¤ºä¸è®¾ç½®/æ¸…é™¤ï¼‰</label>
                <div className="flex gap-2 items-center">
                  <input className="w-full px-3 py-2 border rounded" placeholder="https://.../image.png" value={modalImageUrl} onChange={e => setModalImageUrl(e.target.value)} />
                  <button type="button" className="px-3 py-2 rounded border" onClick={() => (document.getElementById('modal-file') as HTMLInputElement)?.click()}>ä¸Šä¼ å›¾ç‰‡</button>
                  <input id="modal-file" className="hidden" type="file" accept="image/*" onChange={async (e) => {
                    const f = (e.target as HTMLInputElement).files?.[0]
                    if (!f) return
                    try {
                      const fd = new FormData()
                      fd.append('file', f)
                      const r = await fetch('/api/uploads', { method: 'POST', body: fd })
                      const j = await r.json().catch(() => ({}))
                      if (!r.ok) throw new Error(j?.error || 'ä¸Šä¼ å¤±è´¥')
                      setModalImageUrl(j.url || '')
                      toast({ title: 'ä¸Šä¼ æˆåŠŸ', description: 'å›¾ç‰‡å·²ä¸Šä¼ ' })
                    } catch (err: any) {
                      toast({ title: 'é”™è¯¯', description: err?.message || 'ä¸Šä¼ å¤±è´¥', variant: 'destructive' })
                    } finally {
                      ;(document.getElementById('modal-file') as HTMLInputElement).value = ''
                    }
                  }} />
                </div>
              </div>
              <div className="flex items-center gap-2 mt-1">
                <button type="button" className="px-3 py-2 rounded border" onClick={() => !modalSaving && setModalOpen(false)} disabled={modalSaving}>å–æ¶ˆ</button>
                <button type="submit" className="px-4 py-2 rounded bg-black text-white disabled:opacity-50" disabled={modalSaving}>{modalSaving ? 'ä¿å­˜ä¸­...' : 'ä¿å­˜'}</button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}
import { cookies } from 'next/headers'
import { redirect } from 'next/navigation'
import { verifySession } from '@/app/api/_auth'

export default async function AdminLayout({ children }: { children: React.ReactNode }) {
  const cookieStore = await cookies()
  const sess = cookieStore.get('adm_sess')?.value || null
  const s = verifySession(sess)
  if (!s?.u) {
    redirect('/')
  }
  return (
    <div>
      {children}
    </div>
  )
}
"use client"

import { Fragment, Suspense, useEffect, useState, useMemo, useCallback } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import { useToast } from "@/hooks/use-toast"
import { DashboardHeader } from "@/components/dashboard-header"
import { StatisticsCards } from "@/components/statistics-cards"
import { TransactionTables } from "@/components/transaction-tables"
import { CategoryStats } from "@/components/category-stats"
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"

function DashboardPageInner() {
  const { toast } = useToast()
  const router = useRouter()
  const searchParams = useSearchParams()
  const [mounted, setMounted] = useState(false)
  const [currentDate, setCurrentDate] = useState(new Date())
  const [dateInitialized, setDateInitialized] = useState(false)
  const chatId = (searchParams?.get("chatId") || "").trim()
  const [billData, setBillData] = useState<{ billStartTime?: string; billEndTime?: string } | null>(null) // ğŸ”¥ ç´¯è®¡æ¨¡å¼è´¦å•æ—¶é—´æ•°æ®
  const [chatTitle, setChatTitle] = useState<string>("")
  const [groupsCount, setGroupsCount] = useState<number | null>(null)
  const [groups, setGroups] = useState<Array<{ id: string; title: string | null; status?: string; allowed?: boolean; createdAt: string; botId?: string | null; invitedBy?: string | null; invitedByUsername?: string | null; groupId?: string | null; group?: { id: string; name: string } | null; bot?: { name: string } }>>([])
  const [inviterFilter, setInviterFilter] = useState<string>('å…¨éƒ¨') // ğŸ”¥ æ–°å¢ï¼šé‚€è¯·äººç­›é€‰
  const [drafts, setDrafts] = useState<Record<string, { status: "PENDING" | "APPROVED" | "BLOCKED"; botId?: string | null; allowed: boolean }>>({})
  const [bots, setBots] = useState<Array<{ id: string; name: string; enabled?: boolean; realName?: string | null }>>([])
  const [saving, setSaving] = useState<Record<string, boolean>>({})
  const [isAdmin, setIsAdmin] = useState<boolean>(false)
  const [expandedRows, setExpandedRows] = useState<Record<string, boolean>>({})
  const [featureCache, setFeatureCache] = useState<Record<string, { items: Array<{ feature: string; enabled: boolean }>; loading?: boolean }>>({})
  const [featureSaving, setFeatureSaving] = useState<Record<string, boolean>>({})
  // ğŸ”¥ å¿«æ·è®¾ç½®ç¼“å­˜ï¼ˆåœ°å€éªŒè¯ã€åˆ é™¤è´¦å•ç¡®è®¤ã€è®¡ç®—å™¨ï¼‰
  const [quickSettingsCache, setQuickSettingsCache] = useState<Record<string, { addressVerificationEnabled: boolean; deleteBillConfirm: boolean; calculatorEnabled: boolean; showAuthPrompt: boolean; loading?: boolean }>>({})
  const [quickSettingsSaving, setQuickSettingsSaving] = useState<Record<string, boolean>>({})
  const [showCreateBot, setShowCreateBot] = useState<boolean>(false)
  const [createForm, setCreateForm] = useState<{ token: string; enabled: boolean }>({ token: "", enabled: true })
  const [broadcastDrafts, setBroadcastDrafts] = useState<Record<string, {
    open: boolean
    message: string
    sending?: boolean
    selectedChatIds?: string[] // ğŸ”¥ æ–°å¢ï¼šé€‰ä¸­çš„ç¾¤ç»„ID
    selectedGroupIds?: string[] // ğŸ”¥ æ–°å¢ï¼šé€‰ä¸­çš„åˆ†ç»„ID
    showSelector?: boolean // ğŸ”¥ æ–°å¢ï¼šæ˜¯å¦æ˜¾ç¤ºé€‰æ‹©å™¨
    creating?: boolean // ğŸ”¥ æ–°å¢ï¼šåˆ›å»ºçŠ¶æ€
    pending?: boolean // ğŸ”¥ æ–°å¢ï¼šå¾…å¤„ç†çŠ¶æ€
  }>>({})
  // ğŸ”¥ æ–°å¢ï¼šåˆ†ç»„ç®¡ç†çŠ¶æ€
  const [chatGroups, setChatGroups] = useState<Record<string, Array<{ id: string; name: string; description: string | null; chatCount: number }>>>({})
  const [groupDialogs, setGroupDialogs] = useState<Record<string, {
    open: boolean
    editing?: { id: string; name: string; description: string | null }
    creating?: boolean
    pending?: boolean
    selectedGroupId?: string
  }>>({})

  // æ¬¢è¿æŒ‡ä»¤è®¾ç½®å¯¹è¯æ¡†
  const [welcomeDialog, setWelcomeDialog] = useState<{
    open: boolean
    botId?: string
    loading?: boolean
    saving?: boolean
    message?: string
  }>({ open: false })
  const [groupForm, setGroupForm] = useState<{ name: string; description: string }>({ name: '', description: '' })
  const [groupSaving, setGroupSaving] = useState<Record<string, boolean>>({})
  const [manualAdd, setManualAdd] = useState<{ open: boolean; chatId: string; botId: string; saving?: boolean; error?: string }>({ open: false, chatId: '', botId: '' })
  const [batchSaving, setBatchSaving] = useState(false)
  const [selectedGroups, setSelectedGroups] = useState<Set<string>>(new Set()) // ğŸ”¥ æ‰¹é‡é€‰ä¸­çŠ¶æ€
  
  // ğŸ”¥ ç¡®è®¤å¯¹è¯æ¡†çŠ¶æ€
  const [confirmDialog, setConfirmDialog] = useState<{
    open: boolean
    title: string
    description: string
    onConfirm: () => void
  }>({
    open: false,
    title: '',
    description: '',
    onConfirm: () => {}
  })
  
  // ç™½åå•ç”¨æˆ·ç®¡ç†çŠ¶æ€
  const [whitelistedUsers, setWhitelistedUsers] = useState<Array<{ id: string; userId: string; username: string | null; note: string | null; createdAt: string }>>([])
  const [whitelistLoading, setWhitelistLoading] = useState(false)
  const [whitelistForm, setWhitelistForm] = useState({ userId: '', note: '' })
  const [whitelistSaving, setWhitelistSaving] = useState(false)
  
  // ğŸ”¥ é‚€è¯·è®°å½•åŠŸèƒ½å·²åˆ é™¤

  const FEATURE_NAME_MAP: Record<string, string> = {
    accounting_basic: 'åŸºç¡€è®°è´¦',
  }

  useEffect(() => {
    setMounted(true)
    // Require auth only for admin homepage (no chatId)
    ;(async () => {
      try {
        const res = await fetch('/api/auth/me', { cache: 'no-store' })
        if (res.ok) {
          setIsAdmin(true)
          if (!chatId) {
            loadWhitelistedUsers()
          }
        } else {
          setIsAdmin(false)
          if (!chatId) router.push('/')
        }
      } catch {
        setIsAdmin(false)
        if (!chatId) router.push('/')
      }
    })()
  }, [router, chatId])

  // ğŸ”¥ åˆå§‹åŒ–æ—¶æ ¹æ®æ—¥åˆ‡æ—¶é—´è·å–å½“å‰åº”è¯¥æŸ¥çœ‹çš„æ—¥æœŸ
  useEffect(() => {
    if (!chatId || dateInitialized) return
    
    const fetchCurrentDate = async () => {
      try {
        const params = new URLSearchParams()
        params.set('chatId', chatId)
        const res = await fetch(`/api/stats/current-date?${params.toString()}`)
        if (res.ok) {
          const data = await res.json()
          if (data.date) {
            // è§£ææ—¥æœŸå­—ç¬¦ä¸² YYYY-MM-DD
            const [year, month, day] = data.date.split('-').map(Number)
            const targetDate = new Date(year, month - 1, day)
            setCurrentDate(targetDate)
            setDateInitialized(true)
          }
        }
      } catch (e) {
        console.error('è·å–å½“å‰æ—¥æœŸå¤±è´¥', e)
        // å¤±è´¥æ—¶æ ‡è®°ä¸ºå·²åˆå§‹åŒ–ï¼Œä½¿ç”¨é»˜è®¤çš„å½“å‰æ—¥æœŸ
        setDateInitialized(true)
      }
    }
    
    fetchCurrentDate()
  }, [chatId, dateInitialized])
  
  // åŠ è½½ç™½åå•ç”¨æˆ·
  const loadWhitelistedUsers = async () => {
    setWhitelistLoading(true)
    try {
      const res = await fetch('/api/whitelisted-users')
      if (res.ok) {
        const json = await res.json()
        setWhitelistedUsers(Array.isArray(json.items) ? json.items : [])
      }
    } catch (e) {
      console.error('åŠ è½½ç™½åå•å¤±è´¥', e)
    } finally {
      setWhitelistLoading(false)
    }
  }
  
  // ç§»é™¤è‡ªåŠ¨å¡«å……åŠŸèƒ½ï¼ˆç”¨æˆ·åå°†åœ¨æ·»åŠ åè‡ªåŠ¨æ˜¾ç¤ºåœ¨è¡¨æ ¼ä¸­ï¼‰
  
  // æ·»åŠ ç™½åå•ç”¨æˆ·
  const addWhitelistedUser = async () => {
    if (!whitelistForm.userId.trim()) {
      toast({ title: 'æç¤º', description: 'è¯·è¾“å…¥ç”¨æˆ·ID', variant: 'destructive' })
      return
    }
    setWhitelistSaving(true)
    try {
      const res = await fetch('/api/whitelisted-users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(whitelistForm)
      })
      if (res.ok) {
        await loadWhitelistedUsers()
        setWhitelistForm({ userId: '', note: '' })
        toast({ title: 'æˆåŠŸ', description: 'æ·»åŠ æˆåŠŸï¼ç”¨æˆ·åå·²è‡ªåŠ¨è·å–å¹¶æ˜¾ç¤ºåœ¨è¡¨æ ¼ä¸­ã€‚' })
      } else {
        const json = await res.json()
        toast({ title: 'é”™è¯¯', description: json.error || 'æ·»åŠ å¤±è´¥', variant: 'destructive' })
      }
    } catch (e) {
      toast({ title: 'é”™è¯¯', description: 'æ·»åŠ å¤±è´¥', variant: 'destructive' })
    } finally {
      setWhitelistSaving(false)
    }
  }
  
  // ğŸ”¥ æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†çš„è¾…åŠ©å‡½æ•°
  const showConfirm = (title: string, description: string, onConfirm: () => void) => {
    setConfirmDialog({
      open: true,
      title,
      description,
      onConfirm
    })
  }
  
  // åˆ é™¤ç™½åå•ç”¨æˆ·
  const removeWhitelistedUser = async (userId: string) => {
    showConfirm(
      'åˆ é™¤ç™½åå•ç”¨æˆ·',
      'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç™½åå•ç”¨æˆ·å—ï¼Ÿ',
      async () => {
    try {
      const res = await fetch('/api/whitelisted-users', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId })
      })
        if (res.ok) {
          await loadWhitelistedUsers()
          toast({ title: 'æˆåŠŸ', description: 'åˆ é™¤æˆåŠŸ' })
        } else {
          toast({ title: 'é”™è¯¯', description: 'åˆ é™¤å¤±è´¥', variant: 'destructive' })
        }
      } catch (e) {
        toast({ title: 'é”™è¯¯', description: 'åˆ é™¤å¤±è´¥', variant: 'destructive' })
      }
    })
  }
  
  // ğŸ”¥ é‚€è¯·è®°å½•åŠŸèƒ½å·²åˆ é™¤

  // ä»…å±•ç¤º"å·²åœ¨è¯¥ç¾¤å†…çš„æœºå™¨äºº"
  const [eligibleBots, setEligibleBots] = useState<Record<string, Array<{ id: string; name: string }>>>({})
  useEffect(() => {
    // å½“ groups åˆ—è¡¨å˜åŒ–æ—¶ï¼Œå¹¶è¡ŒåŠ è½½æ‰€æœ‰ç¾¤ç»„çš„å¯ç»‘å®šæœºå™¨äººï¼ˆå·²åŠ å…¥è¯¥ç¾¤ï¼‰
    (async () => {
      if (!Array.isArray(groups) || groups.length === 0) return
      
      // è¿‡æ»¤å‡ºå°šæœªåŠ è½½çš„ç¾¤ç»„
      const groupsToLoad = groups.filter(g => !eligibleBots[g.id])
      if (groupsToLoad.length === 0) return
      
      // å¹¶è¡ŒåŠ è½½æ‰€æœ‰ç¾¤ç»„çš„ eligibleBotsï¼Œå¤§å¹…æå‡æ€§èƒ½
      const results = await Promise.allSettled(
        groupsToLoad.map(async (g) => {
          const cid = g.id
          try {
            const res = await fetch(`/api/chats/${encodeURIComponent(cid)}/eligible-bots`)
            if (!res.ok) return { cid, items: [] }
            const json = await res.json().catch(() => ({}))
            const items = Array.isArray(json?.items) ? json.items : []
            return { cid, items }
          } catch (e) {
            console.error(`[eligible-bots] chat=${cid}`, e)
            return { cid, items: [] }
          }
        })
      )
      
      // ä¸€æ¬¡æ€§æ›´æ–°æ‰€æœ‰ç»“æœï¼Œé¿å…å¤šæ¬¡æ¸²æŸ“
      const newEligibleBots: Record<string, Array<{ id: string; name: string }>> = {}
      results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value) {
          newEligibleBots[result.value.cid] = result.value.items
        }
      })
      
      if (Object.keys(newEligibleBots).length > 0) {
        setEligibleBots((m) => ({ ...m, ...newEligibleBots }))
      }
    })()
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [JSON.stringify(groups)])

  // æœ¬åœ°ç¼“å­˜æœºåˆ¶ - ç¼“å­˜ç¾¤ç»„å’Œæœºå™¨äººæ•°æ®5åˆ†é’Ÿ
  const CACHE_KEY_BOTS = 'dashboard_cache_bots'
  const CACHE_KEY_GROUPS = 'dashboard_cache_groups'
  const CACHE_TTL = 5 * 60 * 1000 // 5åˆ†é’Ÿ
  const CACHE_MANUAL_ADDED = 'dashboard_manual_added_chats'

  const getCachedData = (key: string) => {
    if (typeof window === 'undefined') return null
    try {
      const cached = localStorage.getItem(key)
      if (!cached) return null
      const { data, timestamp } = JSON.parse(cached)
      if (Date.now() - timestamp > CACHE_TTL) {
        localStorage.removeItem(key)
        return null
      }
      return data
    } catch {
      return null
    }
  }

  const setCachedData = (key: string, data: any) => {
    if (typeof window === 'undefined') return
    try {
      localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }))
    } catch {}
  }

  // è¯»å–æœ¬åœ°è®°å½•çš„â€œæ‰‹åŠ¨æ·»åŠ â€çš„ç¾¤ç»„
  const getManualAddedSet = (): Set<string> => {
    if (typeof window === 'undefined') return new Set<string>()
    try {
      const raw = localStorage.getItem(CACHE_MANUAL_ADDED)
      if (!raw) return new Set<string>()
      const arr = JSON.parse(raw)
      if (Array.isArray(arr)) return new Set(arr as string[])
      return new Set<string>()
    } catch {
      return new Set<string>()
    }
  }

  const addManualAdded = (chatId: string) => {
    if (typeof window === 'undefined') return
    try {
      const set = getManualAddedSet()
      set.add(chatId)
      localStorage.setItem(CACHE_MANUAL_ADDED, JSON.stringify(Array.from(set)))
    } catch {}
  }

  // load chat title if chatId present; otherwise load bots and group list for empty state
  useEffect(() => {
    if (!mounted) return
    const load = async () => {
      try {
        if (chatId) {
          const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/settings`)
          if (res.ok) {
            const json = await res.json()
            setChatTitle(json?.chat?.title || "")
          }
        } else {
          // å°è¯•ä»ç¼“å­˜åŠ è½½
          const cachedBots = getCachedData(CACHE_KEY_BOTS)
          const cachedGroups = getCachedData(CACHE_KEY_GROUPS)

          if (cachedBots && cachedGroups) {
            // ä½¿ç”¨ç¼“å­˜æ•°æ®
            setBots(cachedBots)
            setGroups(cachedGroups)
            setGroupsCount(cachedGroups.length)
            const d: Record<string, { status: "PENDING" | "APPROVED" | "BLOCKED"; botId?: string | null; allowed: boolean }> = {}
            for (const it of cachedGroups) {
              const status = (it.status as any) || (it.allowed ? 'APPROVED' : 'PENDING')
              const allowed = status === 'APPROVED'
              d[it.id] = { status, botId: it.botId ?? null, allowed }
            }
            setDrafts(d)
            // åå°å¼‚æ­¥åˆ·æ–°ç¼“å­˜
            setTimeout(() => {
              Promise.all([fetch('/api/bots'), fetch('/api/chats')]).then(async ([botsRes, chatsRes]) => {
                if (botsRes.ok && chatsRes.ok) {
                  const botsData = await botsRes.json()
                  const chatsData = await chatsRes.json()
                  const botsItems = Array.isArray(botsData?.items) ? botsData.items : []
                  const chatsItems = (Array.isArray(chatsData?.items) ? chatsData.items : []).filter((it: any) => String(it.id || '').startsWith('-'))
                  const newBots = botsItems.map((b: any) => ({ id: b.id, name: b.name, enabled: !!b.enabled, realName: b.realName || null }))
                  // ğŸ”¥ ç«‹å³æ›´æ–°çŠ¶æ€å¹¶å†™å…¥ç¼“å­˜ï¼Œé¿å…åˆ·æ–°åçœ‹ä¸åˆ°æ–°åˆ›å»ºçš„æœºå™¨äºº/ç¾¤ç»„
                  setBots(newBots)
                  setGroups(chatsItems)
                  setGroupsCount(chatsItems.length)
                  setCachedData(CACHE_KEY_BOTS, newBots)
                  setCachedData(CACHE_KEY_GROUPS, chatsItems)
                  // åŒæ­¥ drafts
                  const d: Record<string, { status: "PENDING" | "APPROVED" | "BLOCKED"; botId?: string | null; allowed: boolean }> = {}
                  for (const it of chatsItems) {
                    const status = (it.status as any) || (it.allowed ? 'APPROVED' : 'PENDING')
                    const allowed = status === 'APPROVED'
                    d[it.id] = { status, botId: it.botId ?? null, allowed }
                  }
                  setDrafts(d)
                }
              }).catch(() => {})
            }, 100)
          } else {
            // ğŸ”¥ å¹¶è¡ŒåŠ è½½æœºå™¨äººå’Œç¾¤ç»„ï¼Œæå‡åŠ è½½é€Ÿåº¦
            const [botsRes, chatsRes] = await Promise.all([
              fetch('/api/bots'),
              fetch('/api/chats')
            ])
            
            if (botsRes.ok) {
              const data = await botsRes.json()
              const items = Array.isArray(data?.items) ? data.items : []
              const botsData = items.map((b: any) => ({ id: b.id, name: b.name, enabled: !!b.enabled, realName: b.realName || null }))
              setBots(botsData)
              setCachedData(CACHE_KEY_BOTS, botsData)
            }
            
            if (chatsRes.ok) {
              const json = await chatsRes.json()
              const items = (Array.isArray(json?.items) ? json.items : []).filter((it: any) => String(it.id || '').startsWith('-'))
              setGroups(items)
              setGroupsCount(items.length)
              setCachedData(CACHE_KEY_GROUPS, items)
              const d: Record<string, { status: "PENDING" | "APPROVED" | "BLOCKED"; botId?: string | null; allowed: boolean }> = {}
              for (const it of items) {
                const status = (it.status as any) || (it.allowed ? 'APPROVED' : 'PENDING')
                const allowed = status === 'APPROVED'
                d[it.id] = { status, botId: it.botId ?? null, allowed }
              }
              setDrafts(d)
            }
          }
        }
      } catch {}
    }
    load()
    
    // ğŸ”¥ åŠ è½½åˆ†ç»„æ•°æ®
    const loadGroups = async () => {
      for (const bot of bots) {
        try {
          const res = await fetch(`/api/bots/${encodeURIComponent(bot.id)}/groups`)
          if (res.ok) {
            const data = await res.json()
            setChatGroups((prev) => ({ ...prev, [bot.id]: data }))
          }
        } catch {}
      }
    }
    if (bots.length > 0) {
      loadGroups()
    }

    // ğŸ”¥ è‡ªåŠ¨åˆ·æ–°ç¾¤ç»„åˆ—è¡¨ï¼ˆæ¯30ç§’è½®è¯¢ä¸€æ¬¡ï¼Œæå‡æ›´æ–°é€Ÿåº¦ï¼‰
    if (!chatId) {
      const interval = setInterval(() => {
        Promise.all([fetch('/api/bots'), fetch('/api/chats')]).then(async ([botsRes, chatsRes]) => {
          if (botsRes.ok && chatsRes.ok) {
            const botsData = await botsRes.json()
            const chatsData = await chatsRes.json()
            const botsItems = Array.isArray(botsData?.items) ? botsData.items : []
            const chatsItems = (Array.isArray(chatsData?.items) ? chatsData.items : []).filter((it: any) => String(it.id || '').startsWith('-'))
            const newBots = botsItems.map((b: any) => ({ id: b.id, name: b.name, enabled: !!b.enabled, realName: b.realName || null }))
            setBots(newBots)
            setGroups(chatsItems)
            setGroupsCount(chatsItems.length)
            const d: Record<string, { status: "PENDING" | "APPROVED" | "BLOCKED"; botId?: string | null; allowed: boolean }> = {}
            for (const it of chatsItems) {
              const status = (it.status as any) || (it.allowed ? 'APPROVED' : 'PENDING')
              const allowed = status === 'APPROVED'
              d[it.id] = { status, botId: it.botId ?? null, allowed }
            }
            setDrafts(d)
            setCachedData(CACHE_KEY_BOTS, newBots)
            setCachedData(CACHE_KEY_GROUPS, chatsItems)
            // ğŸ”¥ åŒæ—¶åˆ·æ–°åˆ†ç»„æ•°æ®
            for (const bot of newBots) {
              try {
                const groupsRes = await fetch(`/api/bots/${encodeURIComponent(bot.id)}/groups`)
                if (groupsRes.ok) {
                  const groupsData = await groupsRes.json()
                  setChatGroups((prev) => ({ ...prev, [bot.id]: groupsData }))
                }
              } catch {}
            }
          }
        }).catch(() => {})
      }, 30 * 1000) // ğŸ”¥ æ¯30ç§’åˆ·æ–°ä¸€æ¬¡
      
      return () => clearInterval(interval)
    }
  }, [mounted, chatId])


  // ğŸ”¥ ä½¿ç”¨ useMemo ä¼˜åŒ–è®¡ç®—ï¼ˆå¿…é¡»åœ¨æ‰€æœ‰æ¡ä»¶è¿”å›ä¹‹å‰ï¼‰
  const manualAddedSet = useMemo(() => getManualAddedSet(), [groups])
  const inviterOptions = useMemo(() => {
    return Array.from(new Set(groups.map(g => g.invitedByUsername || (manualAddedSet.has(g.id) ? 'æ‰‹åŠ¨' : '-'))))
      .filter(x => x !== '-')
      .sort()
  }, [groups, manualAddedSet])
  
  const filteredGroups = useMemo(() => {
    return inviterFilter === 'å…¨éƒ¨' 
      ? groups 
      : groups.filter(g => (g.invitedByUsername || '-') === inviterFilter)
  }, [groups, inviterFilter])

  // ğŸ”¥ ä½¿ç”¨ useCallback ä¼˜åŒ–äº‹ä»¶å¤„ç†ï¼ˆå¿…é¡»åœ¨æ‰€æœ‰æ¡ä»¶è¿”å›ä¹‹å‰ï¼‰
  const handlePreviousDay = useCallback(() => {
    setCurrentDate(prev => {
      const newDate = new Date(prev)
      newDate.setDate(newDate.getDate() - 1)
      return newDate
    })
  }, [])

  const handleNextDay = useCallback(() => {
    setCurrentDate(prev => {
      const newDate = new Date(prev)
      newDate.setDate(newDate.getDate() + 1)
      // ğŸ”¥ é™åˆ¶ï¼šä¸èƒ½è¶…è¿‡ä»Šå¤©
      const today = new Date()
      today.setHours(23, 59, 59, 999)
      if (newDate > today) {
        return prev // å¦‚æœè¶…è¿‡ä»Šå¤©ï¼Œä¸æ›´æ–°
      }
      return newDate
    })
  }, [])

  const handleDateChange = useCallback((date: Date) => {
    // ğŸ”¥ é™åˆ¶ï¼šä¸èƒ½é€‰æ‹©æœªæ¥æ—¥æœŸ
    const today = new Date()
    today.setHours(23, 59, 59, 999)
    if (date > today) {
      return // å¦‚æœè¶…è¿‡ä»Šå¤©ï¼Œä¸æ›´æ–°
    }
    setCurrentDate(date)
  }, [])

  const handleViewSummary = useCallback(() => {
    router.push('/summary')
  }, [router])

  const handleLogout = useCallback(async () => {
    try { await fetch('/api/auth/logout', { method: 'POST' }) } catch {}
    router.push('/')
  }, [router])

  // ğŸ”¥ å¤„ç†è´¦å•æ•°æ®å˜åŒ–ï¼ˆä»…ä¿å­˜æ—¶é—´æ•°æ®ï¼‰
  const handleBillDataChange = useCallback((data: any) => {
    // ğŸ”¥ åªä¿å­˜éœ€è¦çš„æ—¶é—´æ•°æ®ï¼Œå‡å°‘å†…å­˜å ç”¨
    setBillData(data?.billStartTime || data?.billEndTime ? {
      billStartTime: data.billStartTime,
      billEndTime: data.billEndTime
    } : null)
  }, [])

  const showCompact = !chatId

  if (!mounted) {
    return null
  }

  return (
    <div className="min-h-screen bg-slate-50">
      <div className="container mx-auto px-4 py-6 max-w-[95%]">
        <DashboardHeader
          currentDate={currentDate}
          onPreviousDay={handlePreviousDay}
          onNextDay={handleNextDay}
          onViewSummary={handleViewSummary}
          onLogout={handleLogout}
          onDateChange={handleDateChange}
          chatId={chatId}
          chatTitle={chatTitle}
          compact={showCompact}
          hideLogout={!!chatId}
          hideGroupButton={!!chatId}
          showBackHome={!!chatId && isAdmin}
          isAdmin={isAdmin}
          billStartTime={billData?.billStartTime}
          billEndTime={billData?.billEndTime}
        />

        {showCompact ? (
          <div className="mt-6 space-y-6">
            {/* ç§»é™¤å…¨å±€JSONé…ç½®ï¼Œæ”¹ä¸ºæŒ‰æœºå™¨äººé…ç½®çš„å¼¹çª—UI */}
            {/* ç™½åå•ç”¨æˆ·ç®¡ç† */}
            <div className="bg-white border rounded-lg p-6">
              <div className="flex items-start justify-between mb-4">
                <div>
                  <div className="text-lg font-semibold text-slate-900">ğŸ” ç™½åå•ç”¨æˆ·ç®¡ç†</div>
                  <div className="text-sm text-slate-600 mt-1">
                    ç™½åå•ä¸­çš„ç”¨æˆ·é‚€è¯·æœºå™¨äººè¿›ç¾¤åï¼Œè¯¥ç¾¤å°†è‡ªåŠ¨è¢«æˆæƒä½¿ç”¨ï¼ˆæ— éœ€æ‰‹åŠ¨æ‰¹å‡†ï¼‰
                  </div>
                </div>
              </div>

              {/* æ·»åŠ ç™½åå•ç”¨æˆ·è¡¨å• */}
              <div className="bg-slate-50 rounded-lg p-4 mb-4">
                <div className="text-sm font-medium text-slate-700 mb-3">æ·»åŠ ç™½åå•ç”¨æˆ·</div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-3">
                  <div>
                    <label className="block text-xs text-slate-600 mb-1">ç”¨æˆ·IDï¼ˆå¿…å¡«ï¼‰*</label>
                    <input
                      type="text"
                      className="w-full border rounded px-3 py-2 text-sm"
                      placeholder="ä¾‹å¦‚ï¼š123456789"
                      value={whitelistForm.userId}
                      onChange={(e) => setWhitelistForm(f => ({ ...f, userId: e.target.value }))}
                    />
                    <p className="text-xs text-slate-500 mt-1">ğŸ’¡ Telegramç”¨æˆ·çš„æ•°å­—IDï¼ˆæ·»åŠ åç”¨æˆ·åä¼šè‡ªåŠ¨æ˜¾ç¤ºåœ¨è¡¨æ ¼ä¸­ï¼‰</p>
                  </div>
                  <div>
                    <label className="block text-xs text-slate-600 mb-1">å¤‡æ³¨ï¼ˆå¯é€‰ï¼‰</label>
                    <input
                      type="text"
                      className="w-full border rounded px-3 py-2 text-sm"
                      placeholder="ä¾‹å¦‚ï¼šå¼ ä¸‰-è¿è¥"
                      value={whitelistForm.note}
                      onChange={(e) => setWhitelistForm(f => ({ ...f, note: e.target.value }))}
                    />
                    <p className="text-xs text-slate-500 mt-1">ğŸ’¡ é¢å¤–è¯´æ˜ä¿¡æ¯</p>
                  </div>
                </div>
                <div className="flex justify-end">
                  <button
                    className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 text-sm"
                    onClick={addWhitelistedUser}
                    disabled={whitelistSaving || !whitelistForm.userId.trim()}
                  >
                    {whitelistSaving ? 'æ·»åŠ ä¸­...' : 'â• æ·»åŠ åˆ°ç™½åå•'}
                  </button>
                </div>
              </div>

              {/* ç™½åå•ç”¨æˆ·åˆ—è¡¨ */}
              <div className="border rounded-lg overflow-hidden">
                <table className="w-full text-sm">
                  <thead className="bg-slate-50 border-b">
                    <tr>
                      <th className="text-left py-3 px-4 text-slate-600 font-medium">ç”¨æˆ·ID</th>
                      <th className="text-left py-3 px-4 text-slate-600 font-medium">ç”¨æˆ·å</th>
                      <th className="text-left py-3 px-4 text-slate-600 font-medium">å¤‡æ³¨</th>
                      <th className="text-left py-3 px-4 text-slate-600 font-medium">æ·»åŠ æ—¶é—´</th>
                      <th className="text-right py-3 px-4 text-slate-600 font-medium">æ“ä½œ</th>
                    </tr>
                  </thead>
                  <tbody>
                    {whitelistLoading ? (
                      <tr>
                        <td colSpan={5} className="text-center py-8 text-slate-500">
                          åŠ è½½ä¸­...
                        </td>
                      </tr>
                    ) : whitelistedUsers.length === 0 ? (
                      <tr>
                        <td colSpan={5} className="text-center py-8 text-slate-500">
                          æš‚æ— ç™½åå•ç”¨æˆ·ï¼Œæ·»åŠ åè¯¥ç”¨æˆ·é‚€è¯·æœºå™¨äººè¿›ç¾¤å°†è‡ªåŠ¨æˆæƒ
                        </td>
                      </tr>
                    ) : (
                      whitelistedUsers.map((user) => (
                        <tr key={user.id} className="border-b hover:bg-slate-50">
                          <td className="py-3 px-4 font-mono text-xs">{user.userId}</td>
                          <td className="py-3 px-4">{user.username || '-'}</td>
                          <td className="py-3 px-4">{user.note || '-'}</td>
                          <td className="py-3 px-4 text-slate-600">
                            {new Date(user.createdAt).toLocaleString('zh-CN')}
                          </td>
                          <td className="py-3 px-4 text-right">
                            <button
                              className="px-3 py-1 text-xs border rounded hover:bg-red-50 hover:border-red-300 hover:text-red-600"
                              onClick={() => removeWhitelistedUser(user.userId)}
                            >
                              åˆ é™¤
                            </button>
                          </td>
                        </tr>
                      ))
                    )}
                  </tbody>
                </table>
              </div>
            </div>

            {/* æœºå™¨äººæ¦‚è§ˆ */}
            <div className="bg-white border rounded-lg p-6">
              <div className="flex items-start justify-between mb-4">
                <div>
                  <div className="text-lg font-semibold text-slate-900">æœºå™¨äººç®¡ç†</div>
                  <div className="text-sm text-slate-600 mt-1">å…¨éƒ¨æœºå™¨äººé›†ä¸­å±•ç¤ºï¼Œå¯åœ¨æ­¤å¯ç”¨/åœç”¨ã€‚</div>
                </div>
                <div className="flex items-center gap-2">
                  <button
                    className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50"
                    onClick={() => setShowCreateBot((v) => !v)}
                  >{showCreateBot ? 'æ”¶èµ·åˆ›å»º' : 'åˆ›å»ºæ–°æœºå™¨äºº'}</button>
                </div>
              </div>

            {manualAdd.open && (
              <div className="fixed inset-0 bg-black/20 flex items-center justify-center z-50">
                <div className="bg-white rounded-lg shadow-lg p-5 w-full max-w-md">
                  <div className="text-lg font-semibold mb-3">æ‰‹åŠ¨æ·»åŠ ç¾¤</div>
                  <div className="space-y-3">
                    <div className="text-sm text-slate-600">è¯·è¾“å…¥ Chat ID ä¸è¦ç»‘å®šçš„æœºå™¨äººã€‚</div>
                    <input
                      className="w-full border rounded px-2 py-1 text-sm"
                      placeholder="Chat IDï¼Œå¦‚ -1001234567890"
                      value={manualAdd.chatId}
                      onChange={(e) => setManualAdd((m) => ({ ...m, chatId: e.target.value }))}
                    />
                    <select
                      className="w-full border rounded px-2 py-1 text-sm"
                      value={manualAdd.botId}
                      onChange={(e) => setManualAdd((m) => ({ ...m, botId: e.target.value }))}
                    >
                      <option value="">é€‰æ‹©æœºå™¨äºº</option>
                      {bots.map((b) => (
                        <option key={b.id} value={b.id}>{b.name}</option>
                      ))}
                    </select>
                    {manualAdd.error && <div className="text-xs text-red-600">{manualAdd.error}</div>}
                  </div>
                  <div className="mt-4 flex justify-end gap-2">
                    <button
                      className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50"
                      onClick={() => setManualAdd({ open: false, chatId: '', botId: '' })}
                    >å–æ¶ˆ</button>
                    <button
                      className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
                      disabled={!manualAdd.chatId.trim() || !manualAdd.botId || manualAdd.saving}
                      onClick={async () => {
                        const chatId = manualAdd.chatId.trim()
                        const botId = manualAdd.botId
                        setManualAdd((m) => ({ ...m, saving: true, error: '' }))
                        try {
                          const res = await fetch('/api/chats/manual-add', {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ chatId, botId })
                          })
                          if (!res.ok) {
                            const msg = await res.text().catch(() => '')
                            throw new Error(msg || 'æ·»åŠ å¤±è´¥')
                          }
                          // è®°å½•ä¸ºæ‰‹åŠ¨æ·»åŠ 
                          addManualAdded(chatId)
                          // é‡æ–°åŠ è½½ç¾¤åˆ—è¡¨
                          const gl = await fetch('/api/chats')
                          if (gl.ok) {
                            const j = await gl.json().catch(() => ({}))
                            const items = Array.isArray(j?.items) ? j.items : []
                            setGroups(items)
                            setGroupsCount(items.length)
                          }
                          setManualAdd({ open: false, chatId: '', botId: '' })
                        } catch (e) {
                          setManualAdd((m) => ({ ...m, saving: false, error: (e as Error).message }))
                        } finally {
                          setManualAdd((m) => ({ ...m, saving: false }))
                        }
                      }}
                    >{manualAdd.saving ? 'æ·»åŠ ä¸­...' : 'ç¡®å®šæ·»åŠ '}</button>
                  </div>
                </div>
              </div>
            )}

              {showCreateBot && (
                <div className="border rounded-md p-4 mb-4 space-y-3">
                  <div className="flex gap-2">
                    <input
                      className="border rounded px-2 py-1 text-sm flex-1"
                      placeholder="æœºå™¨äºº Token"
                      value={createForm.token}
                      onChange={(e) => setCreateForm(f => ({ ...f, token: e.target.value }))}
                    />
                  </div>
                  <div className="text-xs text-slate-500">ç³»ç»Ÿå°†è‡ªåŠ¨è¯†åˆ«Tokenå¹¶åˆ›å»ºæœºå™¨äººï¼Œè‡ªåŠ¨ä½¿ç”¨ @username ä½œä¸ºåç§°ã€‚</div>
                  <label className="inline-flex items-center gap-2 text-sm">
                    <input type="checkbox" checked={createForm.enabled} onChange={(e) => setCreateForm(f => ({ ...f, enabled: e.target.checked }))} />
                    <span>åˆ›å»ºåç«‹å³å¯ç”¨</span>
                  </label>
                  <div>
                    <button
                      className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
                      disabled={!createForm.token.trim()}
                      onClick={async () => {
                        if (!createForm.token.trim()) { toast({ title: 'æç¤º', description: 'è¯·å…ˆå¡«å†™ Token', variant: 'destructive' }); return }
                        
                        // ğŸ”¥ è‡ªåŠ¨è¯†åˆ«å¹¶åˆ›å»ºï¼ˆåˆå¹¶ä¸ºä¸€ä¸ªæ“ä½œï¼‰
                        try {
                          // å…ˆè¯†åˆ«Token
                          const introspectRes = await fetch('/api/bots/introspect', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ token: createForm.token }) 
                          })
                          
                          if (!introspectRes.ok) {
                            const msg = await introspectRes.json().catch(() => ({}))
                            toast({ title: 'é”™è¯¯', description: `è¯†åˆ«å¤±è´¥ï¼š${msg?.error || 'è¯·æ£€æŸ¥ Token'}`, variant: 'destructive' })
                            return
                          }
                          
                          const me = await introspectRes.json()
                          const name = me.username ? `@${me.username}` : (me.first_name || 'æ–°æœºå™¨äºº')
                          
                          // ç›´æ¥åˆ›å»º
                          const payload = { name, token: createForm.token, enabled: createForm.enabled }
                          const createRes = await fetch('/api/bots', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify(payload) 
                          })
                          
                          if (createRes.ok) {
                            try {
                              const botsRes2 = await fetch('/api/bots')
                              if (botsRes2.ok) {
                                const data2 = await botsRes2.json()
                                const items2 = Array.isArray(data2?.items) ? data2.items : []
                                const newBots = items2.map((x: any) => ({ id: x.id, name: x.name, enabled: !!x.enabled, realName: x.realName || null }))
                                setBots(newBots)
                                // ğŸ”¥ åŒæ­¥æ›´æ–°ç¼“å­˜ï¼Œé¿å…åˆ·æ–°åçœ‹ä¸åˆ°æ–°æœºå™¨äºº
                                setCachedData(CACHE_KEY_BOTS, newBots)
                              }
                            } catch {}
                            setCreateForm({ token: '', enabled: true })
                            setShowCreateBot(false)
                            toast({ title: 'æˆåŠŸ', description: `æœºå™¨äºº ${name} åˆ›å»ºæˆåŠŸ` })
                          } else {
                            toast({ title: 'é”™è¯¯', description: 'åˆ›å»ºå¤±è´¥', variant: 'destructive' })
                          }
                        } catch {
                          toast({ title: 'é”™è¯¯', description: 'åˆ›å»ºå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’ŒToken', variant: 'destructive' })
                        }
                      }}
                    >åˆ›å»ºæœºå™¨äºº</button>
                  </div>
                </div>
              )}

              {bots.length === 0 ? (
                <div className="text-sm text-slate-500">æš‚æ— æœºå™¨äººï¼Œè¯·å…ˆåˆ›å»ºã€‚</div>
              ) : (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {bots.map((bot) => (
                    <div key={bot.id} className="border rounded-md p-4 space-y-2">
                      <div className="flex items-center justify-between">
                        <div className="font-medium text-slate-900">{bot.name}</div>
                        <label className="inline-flex items-center gap-2 text-sm">
                          <input
                            type="checkbox"
                            checked={!!bot.enabled}
                            onChange={async (e) => {
                              const enabled = e.target.checked
                              const res = await fetch(`/api/bots/${encodeURIComponent(bot.id)}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ enabled })
                              })
                              if (res.ok) {
                                setBots((prev) => {
                                  const next = prev.map((b) => b.id === bot.id ? { ...b, enabled } : b)
                                  setCachedData(CACHE_KEY_BOTS, next)
                                  return next
                                })
                                toast({ title: 'æˆåŠŸ', description: `æœºå™¨äººå·²${enabled ? 'å¯ç”¨' : 'åœç”¨'}` })
                              } else {
                                toast({ title: 'é”™è¯¯', description: 'æ›´æ–°å¯ç”¨çŠ¶æ€å¤±è´¥', variant: 'destructive' })
                              }
                            }}
                          />
                          <span>{bot.enabled ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨'}</span>
                        </label>
                      </div>
                      {bot.realName && (
                        <div className="text-xs text-slate-500">{bot.realName}</div>
                      )}
                      <div className="flex items-center gap-2">
                        <button
                          className="px-3 py-1.5 text-xs border rounded-md hover:bg-slate-50"
                          onClick={() => {
                            setBroadcastDrafts((prev) => {
                              const current = prev[bot.id] || { open: false, message: '' }
                              return {
                                ...prev,
                                [bot.id]: { ...current, open: !current.open }
                              }
                            })
                          }}
                        >{broadcastDrafts[bot.id]?.open ? 'æ”¶èµ·ç¾¤å‘' : 'ç¾¤å‘é€šçŸ¥'}</button>
                        {isAdmin && (
                          <>
                            <button
                              className="px-3 py-1.5 text-xs border rounded-md hover:bg-slate-50"
                              onClick={() => router.push(`/admin/custom-commands?botId=${encodeURIComponent(bot.id)}`)}
                            >è‡ªå®šä¹‰æŒ‡ä»¤</button>
                          </>
                        )}
                        <button
                          className="px-3 py-1.5 text-xs border rounded-md hover:bg-red-50 text-red-600"
                          onClick={async () => {
                            if (!confirm('ç¡®è®¤åˆ é™¤è¯¥æœºå™¨äººï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤')) return
                            try {
                              const res = await fetch(`/api/bots/${encodeURIComponent(bot.id)}`, { method: 'DELETE' })
                              if (res.status === 204) {
                                setBots((prev) => {
                                  const next = prev.filter((b) => b.id !== bot.id)
                                  setCachedData(CACHE_KEY_BOTS, next)
                                  return next
                                })
                                toast({ title: 'æˆåŠŸ', description: 'æœºå™¨äººåˆ é™¤æˆåŠŸ' })
                              } else {
                                const msg = await res.text().catch(() => '')
                                toast({ title: 'é”™è¯¯', description: `åˆ é™¤å¤±è´¥ï¼š${msg || 'Server error'}`, variant: 'destructive' })
                              }
                            } catch {
                              toast({ title: 'é”™è¯¯', description: 'åˆ é™¤å¤±è´¥ï¼šç½‘ç»œé”™è¯¯', variant: 'destructive' })
                            }
                          }}
                        >åˆ é™¤æœºå™¨äºº</button>
                        <button
                          className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50"
                          onClick={async () => {
                            setWelcomeDialog({ open: true, botId: bot.id, loading: true, message: '' })
                            try {
                              const token = localStorage.getItem('auth_token') || ''
                              const res = await fetch(`/api/bots/${encodeURIComponent(bot.id)}/welcome-message`, {
                                headers: { 'x-auth-token': token }
                              })
                              if (res.ok) {
                                const data = await res.json().catch(() => ({}))
                                setWelcomeDialog(prev => ({ ...prev, loading: false, message: data.message || '' }))
                              } else {
                                setWelcomeDialog(prev => ({ ...prev, loading: false }))
                              }
                            } catch {
                              setWelcomeDialog(prev => ({ ...prev, loading: false }))
                            }
                          }}
                        >æ¬¢è¿æŒ‡ä»¤è®¾ç½®</button>
                      </div>
                      {broadcastDrafts[bot.id]?.open && (
                        <div className="space-y-2 text-sm">
                          <textarea
                            className="w-full border rounded-md px-2 py-1 text-sm min-h-[80px]"
                            placeholder="åœ¨æ­¤è¾“å…¥è¦å‘é€çš„å…¬å‘Š"
                            value={broadcastDrafts[bot.id]?.message || ''}
                            onChange={(e) => {
                              const value = e.target.value
                              setBroadcastDrafts((prev) => ({
                                ...prev,
                                [bot.id]: { ...(prev[bot.id] || { open: true, sending: false }), open: true, message: value },
                              }))
                            }}
                          />
                          {/* ğŸ”¥ æ–°å¢ï¼šé€‰æ‹©å‘é€ç›®æ ‡ */}
                          <div className="space-y-2">
                            <div className="flex items-center gap-2">
                              <button
                                className="px-2 py-1 text-xs border rounded-md hover:bg-slate-50"
                                onClick={() => {
                                  const current = broadcastDrafts[bot.id] || { open: true, message: '', sending: false }
                                  setBroadcastDrafts((prev) => ({
                                    ...prev,
                                    [bot.id]: { ...current, showSelector: !current.showSelector }
                                  }))
                                }}
                              >{broadcastDrafts[bot.id]?.showSelector ? 'æ”¶èµ·é€‰æ‹©' : 'é€‰æ‹©å‘é€ç›®æ ‡'}</button>
                              <button
                                className="px-2 py-1 text-xs border rounded-md hover:bg-slate-50"
                                onClick={() => {
                                  setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true } }))
                                  // åŠ è½½åˆ†ç»„æ•°æ®
                                  fetch(`/api/bots/${encodeURIComponent(bot.id)}/groups`).then(async (res) => {
                                    if (res.ok) {
                                      const data = await res.json()
                                      setChatGroups((prev) => ({ ...prev, [bot.id]: data }))
                                    }
                                  }).catch(() => {})
                                }}
                              >ç®¡ç†åˆ†ç»„</button>
                              <span className="text-xs text-slate-500">
                                {(() => {
                                  const current = broadcastDrafts[bot.id]
                                  if (!current) return 'é»˜è®¤å‘é€åˆ°æ‰€æœ‰ç¾¤ç»„'
                                  if (current.selectedChatIds && current.selectedChatIds.length > 0) {
                                    return `å·²é€‰æ‹© ${current.selectedChatIds.length} ä¸ªç¾¤ç»„`
                                  }
                                  if (current.selectedGroupIds && current.selectedGroupIds.length > 0) {
                                    return `å·²é€‰æ‹© ${current.selectedGroupIds.length} ä¸ªåˆ†ç»„`
                                  }
                                  return 'é»˜è®¤å‘é€åˆ°æ‰€æœ‰ç¾¤ç»„'
                                })()}
                              </span>
                            </div>
                            {broadcastDrafts[bot.id]?.showSelector && (
                              <div className="border rounded-md p-2 space-y-2 max-h-[200px] overflow-y-auto">
                                {/* åˆ†ç»„é€‰æ‹© */}
                                {chatGroups[bot.id] && chatGroups[bot.id].length > 0 && (
                                  <div className="space-y-1">
                                    <div className="text-xs font-medium text-slate-700">æŒ‰åˆ†ç»„å‘é€ï¼š</div>
                                    <div className="space-y-1">
                                      {chatGroups[bot.id].map((group) => {
                                        const isSelected = broadcastDrafts[bot.id]?.selectedGroupIds?.includes(group.id)
                                        return (
                                          <label key={group.id} className="flex items-center gap-2 text-xs">
                                            <input
                                              type="checkbox"
                                              checked={isSelected || false}
                                              onChange={(e) => {
                                                const current = broadcastDrafts[bot.id] || { open: true, message: '', sending: false }
                                                const selectedGroupIds = current.selectedGroupIds || []
                                                const newSelected = e.target.checked
                                                  ? [...selectedGroupIds, group.id]
                                                  : selectedGroupIds.filter((id: string) => id !== group.id)
                                                setBroadcastDrafts((prev) => ({
                                                  ...prev,
                                                  [bot.id]: { ...current, selectedGroupIds: newSelected, selectedChatIds: [] }
                                                }))
                                              }}
                                            />
                                            <span>{group.name} ({group.chatCount} ä¸ªç¾¤ç»„)</span>
                                          </label>
                                        )
                                      })}
                                    </div>
                                  </div>
                                )}
                                {/* ç¾¤ç»„é€‰æ‹© */}
                                <div className="space-y-1">
                                  <div className="text-xs font-medium text-slate-700">æŒ‰ç¾¤ç»„å‘é€ï¼š</div>
                                  <div className="space-y-1 max-h-[100px] overflow-y-auto">
                                    {groups.filter((g: any) => g.botId === bot.id && g.status === 'APPROVED').slice(0, 20).map((group: any) => {
                                      const isSelected = broadcastDrafts[bot.id]?.selectedChatIds?.includes(group.id)
                                      return (
                                        <label key={group.id} className="flex items-center gap-2 text-xs">
                                          <input
                                            type="checkbox"
                                            checked={isSelected || false}
                                            onChange={(e) => {
                                              const current = broadcastDrafts[bot.id] || { open: true, message: '', sending: false }
                                              const selectedChatIds = current.selectedChatIds || []
                                              const newSelected = e.target.checked
                                                ? [...selectedChatIds, group.id]
                                                : selectedChatIds.filter((id: string) => id !== group.id)
                                              setBroadcastDrafts((prev) => ({
                                                ...prev,
                                                [bot.id]: { ...current, selectedChatIds: newSelected, selectedGroupIds: [] }
                                              }))
                                            }}
                                          />
                                          <span className="truncate">{group.title || group.id}</span>
                                        </label>
                                      )
                                    })}
                                    {groups.filter((g: any) => g.botId === bot.id && g.status === 'APPROVED').length > 20 && (
                                      <div className="text-xs text-slate-500">ï¼ˆä»…æ˜¾ç¤ºå‰20ä¸ªï¼Œæ›´å¤šè¯·ä½¿ç”¨åˆ†ç»„ï¼‰</div>
                                    )}
                                  </div>
                                </div>
                                <button
                                  className="px-2 py-1 text-xs border rounded-md hover:bg-slate-50"
                                  onClick={() => {
                                    const current = broadcastDrafts[bot.id] || { open: true, message: '', sending: false }
                                    setBroadcastDrafts((prev) => ({
                                      ...prev,
                                      [bot.id]: { ...current, selectedChatIds: [], selectedGroupIds: [] }
                                    }))
                                  }}
                                >æ¸…é™¤é€‰æ‹©ï¼ˆå‘é€åˆ°æ‰€æœ‰ç¾¤ç»„ï¼‰</button>
                              </div>
                            )}
                          </div>
                          <div className="flex justify-end gap-3">
                            <button
                              className="px-3 py-1.5 text-xs border rounded-md hover:bg-slate-50"
                              onClick={() => setBroadcastDrafts((prev) => ({ ...prev, [bot.id]: { open: false, message: '', sending: false } }))}
                            >å–æ¶ˆ</button>
                            <button
                              className="px-3 py-1.5 text-xs border rounded-md hover:bg-slate-50 disabled:opacity-50"
                              disabled={!broadcastDrafts[bot.id]?.message?.trim() || broadcastDrafts[bot.id]?.sending}
                              onClick={async () => {
                                const current = broadcastDrafts[bot.id]
                                if (!current?.message?.trim()) return
                                setBroadcastDrafts((prev) => ({ ...prev, [bot.id]: { ...current, sending: true } }))
                                try {
                                  const body: any = { message: current.message }
                                  if (current.selectedChatIds && current.selectedChatIds.length > 0) {
                                    body.chatIds = current.selectedChatIds
                                  } else if (current.selectedGroupIds && current.selectedGroupIds.length > 0) {
                                    body.groupIds = current.selectedGroupIds
                                  }
                                  const res = await fetch(`/api/bots/${encodeURIComponent(bot.id)}/broadcast`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(body),
                                  })
                                  if (res.ok) {
                                    const json = await res.json().catch(() => null)
                                    toast({ title: 'æˆåŠŸ', description: `å·²å‘é€ï¼š${json?.sent ?? 0} / ${json?.total ?? 0}` })
                                    setBroadcastDrafts((prev) => ({ ...prev, [bot.id]: { open: false, message: '', sending: false } }))
                                  } else {
                                    const err = await res.json().catch(() => ({}))
                                    toast({ title: 'é”™è¯¯', description: `å‘é€å¤±è´¥ï¼š${err?.error || 'è¯·æ£€æŸ¥ç½‘ç»œ'}`, variant: 'destructive' })
                                    setBroadcastDrafts((prev) => ({ ...prev, [bot.id]: { ...current, sending: false } }))
                                  }
                                } catch (e) {
                                  toast({ title: 'é”™è¯¯', description: 'å‘é€å¤±è´¥ï¼šç½‘ç»œé”™è¯¯', variant: 'destructive' })
                                  setBroadcastDrafts((prev) => ({ ...prev, [bot.id]: { ...current, sending: false } }))
                                }
                              }}
                            >{broadcastDrafts[bot.id]?.sending ? 'å‘é€ä¸­...' : 'å‘é€ç¾¤å‘'}</button>
                          </div>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* âœ… ä¿®æ­£ï¼šåˆ é™¤äº†ä¸­é—´å¯¼è‡´æŠ¥é”™çš„æ®‹ç•™ä»£ç ï¼Œç›´æ¥è¡”æ¥åˆ†ç»„å¯¹è¯æ¡†é€»è¾‘ */}

            {bots.map((bot) => {
              const dlg = groupDialogs[bot.id]
              if (!dlg) return null
              const botGroups = chatGroups[bot.id] || []
              const chatsForBot = groups.filter((g: any) => g.botId === bot.id && g.status === 'APPROVED')
              const selectedGroupId = dlg.selectedGroupId || (botGroups[0]?.id ?? '')
              const creating = dlg.creating || false
              const pending = dlg.pending || {}
              const selectedGroup = botGroups.find((g) => g.id === selectedGroupId)

              return (
                <Dialog key={`group-${bot.id}`} open={!!dlg.open} onOpenChange={(open) => {
                  if (!open) {
                    setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: false } }))
                    setGroupForm({ name: '', description: '' })
                  }
                }}>
                  <DialogContent className="w-[98vw] max-w-none sm:max-w-none max-h-[80vh] overflow-y-auto">
                    <DialogHeader>
                      <DialogTitle>ğŸ“ åˆ†ç»„ç®¡ç† - {bot.name}</DialogTitle>
                      <DialogDescription>é€‰æ‹©åˆ†ç»„ â†’ å‹¾é€‰ç¾¤ç»„ â†’ ä¿å­˜ï¼›å¯æ–°å»º/é‡å‘½å/åˆ é™¤åˆ†ç»„ã€‚</DialogDescription>
                    </DialogHeader>

                    <div className="mt-4 space-y-4">
                      {/* åˆ†ç»„é€‰æ‹©ä¸å¢åˆ æ”¹ */}
                      <div className="border rounded-md p-4 space-y-3">
                        <div className="text-sm font-medium">åˆ†ç»„é€‰æ‹© / åˆ›å»º / é‡å‘½å / åˆ é™¤</div>
                        <div className="flex flex-col gap-3">
                          <div className="flex flex-wrap gap-2 items-center">
                            {botGroups.length === 0 && (
                              <div className="text-xs text-slate-500">æš‚æ— åˆ†ç»„ï¼Œè¯·å…ˆåˆ›å»º</div>
                            )}
                            {botGroups.map((g) => {
                              const active = !creating && g.id === selectedGroupId
                              return (
                                <button
                                  key={g.id}
                                  className={`px-3 py-1 text-xs rounded-md border ${active ? 'bg-blue-50 border-blue-500 text-blue-600' : 'hover:bg-slate-50'}`}
                                  onClick={() => {
                                    setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true, selectedGroupId: g.id, pending: {}, creating: false } }))
                                    setGroupForm({ name: g.name || '', description: '' })
                                  }}
                                >
                                  {g.name}
                                </button>
                              )
                            })}
                            <button
                              className="px-3 py-1 text-xs rounded-md border border-dashed hover:bg-slate-50"
                              onClick={() => {
                                setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true, selectedGroupId: '', pending: {}, creating: true } }))
                                setGroupForm({ name: '', description: '' })
                              }}
                            >
                              åˆ›å»ºåˆ†ç»„
                            </button>
                          </div>

                          <div className="flex items-center gap-2">
                            <input
                              type="text"
                              className="border rounded-md px-2 py-1 text-sm flex-1"
                              placeholder={creating ? 'æ–°åˆ†ç»„åç§°' : 'åˆ†ç»„åç§°'}
                              value={groupForm.name}
                              onChange={(e) => setGroupForm((prev) => ({ ...prev, name: e.target.value }))}
                            />
                            {creating ? (
                              <>
                                <button
                                  className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
                                  disabled={!groupForm.name.trim() || groupSaving[bot.id]}
                                  onClick={async () => {
                                    if (!groupForm.name.trim()) return
                                    setGroupSaving((prev) => ({ ...prev, [bot.id]: true }))
                                    try {
                                      const res = await fetch(`/api/bots/${encodeURIComponent(bot.id)}/groups`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ name: groupForm.name.trim() })
                                      })
                                      if (res.ok) {
                                        const data = await res.json()
                                        setChatGroups((prev) => {
                                          const current = prev[bot.id] || []
                                          return { ...prev, [bot.id]: [...current, data] }
                                        })
                                        setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true, selectedGroupId: data.id, pending: {}, creating: false } }))
                                        setGroupForm({ name: data.name, description: '' })
                                        toast({ title: 'æˆåŠŸ', description: 'åˆ†ç»„å·²åˆ›å»º' })
                                      } else {
                                        const err = await res.json().catch(() => ({}))
                                        toast({ title: 'é”™è¯¯', description: err?.error || 'åˆ›å»ºå¤±è´¥', variant: 'destructive' })
                                      }
                                    } catch {
                                      toast({ title: 'é”™è¯¯', description: 'ç½‘ç»œé”™è¯¯', variant: 'destructive' })
                                    } finally {
                                      setGroupSaving((prev) => ({ ...prev, [bot.id]: false }))
                                    }
                                  }}
                                >åˆ›å»º</button>
                                <button
                                  className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50"
                                  onClick={() => {
                                    const fallbackId = botGroups[0]?.id || ''
                                    setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true, selectedGroupId: fallbackId, pending: {}, creating: false } }))
                                    setGroupForm({ name: fallbackId ? (botGroups.find((g) => g.id === fallbackId)?.name || '') : '', description: '' })
                                  }}
                                >å–æ¶ˆ</button>
                              </>
                            ) : (
                              <>
                                <button
                                  className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
                                  disabled={!groupForm.name.trim() || groupSaving[bot.id] || !selectedGroupId}
                                  onClick={async () => {
                                    if (!groupForm.name.trim() || !selectedGroupId) return
                                    setGroupSaving((prev) => ({ ...prev, [bot.id]: true }))
                                    try {
                                      const url = `/api/bots/${encodeURIComponent(bot.id)}/groups/${encodeURIComponent(selectedGroupId)}`
                                      const res = await fetch(url, {
                                        method: 'PATCH',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ name: groupForm.name.trim() })
                                      })
                                      if (res.ok) {
                                        const data = await res.json()
                                        setChatGroups((prev) => {
                                          const current = prev[bot.id] || []
                                          return { ...prev, [bot.id]: current.map((g) => g.id === selectedGroupId ? data : g) }
                                        })
                                        setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true, selectedGroupId: data.id, pending: {}, creating: false } }))
                                        setGroupForm({ name: data.name, description: '' })
                                        toast({ title: 'æˆåŠŸ', description: 'åˆ†ç»„å·²æ›´æ–°' })
                                      } else {
                                        const err = await res.json().catch(() => ({}))
                                        toast({ title: 'é”™è¯¯', description: err?.error || 'æ›´æ–°å¤±è´¥', variant: 'destructive' })
                                      }
                                    } catch {
                                      toast({ title: 'é”™è¯¯', description: 'ç½‘ç»œé”™è¯¯', variant: 'destructive' })
                                    } finally {
                                      setGroupSaving((prev) => ({ ...prev, [bot.id]: false }))
                                    }
                                  }}
                                >æ›´æ–°</button>
                                <button
                                  className="px-3 py-1.5 text-sm border rounded-md hover:bg-red-50 text-red-600 disabled:opacity-50"
                                  disabled={!selectedGroupId || groupSaving[bot.id]}
                                  onClick={async () => {
                                    if (!selectedGroupId) return
                                    const target = botGroups.find((g) => g.id === selectedGroupId)
                                    if (!confirm(`ç¡®è®¤åˆ é™¤åˆ†ç»„"${target?.name || ''}"ï¼Ÿæ­¤æ“ä½œä¼šå°†åˆ†ç»„ä¸­çš„ç¾¤ç»„ç§»å‡ºåˆ†ç»„ï¼Œä½†ä¸ä¼šåˆ é™¤ç¾¤ç»„ã€‚`)) return
                                    setGroupSaving((prev) => ({ ...prev, [bot.id]: true }))
                                    try {
                                      const res = await fetch(`/api/bots/${encodeURIComponent(bot.id)}/groups/${encodeURIComponent(selectedGroupId)}`, { method: 'DELETE' })
                                      if (res.ok) {
                                        setChatGroups((prev) => {
                                          const current = prev[bot.id] || []
                                          const next = current.filter((g) => g.id !== selectedGroupId)
                                          return { ...prev, [bot.id]: next }
                                        })
                                        setGroups((prev) => prev.map((g: any) => g.botId === bot.id && g.groupId === selectedGroupId ? { ...g, groupId: null } : g))
                                        const rest = botGroups.filter((g) => g.id !== selectedGroupId)
                                        const nextId = rest[0]?.id || ''
                                        setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true, selectedGroupId: nextId, pending: {}, creating: false } }))
                                        setGroupForm({ name: nextId ? (rest.find((g) => g.id === nextId)?.name || '') : '', description: '' })
                                        toast({ title: 'æˆåŠŸ', description: 'åˆ†ç»„å·²åˆ é™¤' })
                                      } else {
                                        const err = await res.json().catch(() => ({}))
                                        toast({ title: 'é”™è¯¯', description: err?.error || 'åˆ é™¤å¤±è´¥', variant: 'destructive' })
                                      }
                                    } catch {
                                      toast({ title: 'é”™è¯¯', description: 'ç½‘ç»œé”™è¯¯', variant: 'destructive' })
                                    } finally {
                                      setGroupSaving((prev) => ({ ...prev, [bot.id]: false }))
                                    }
                                  }}
                                >åˆ é™¤</button>
                              </>
                            )}
                          </div>
                        </div>
                      </div>

                      {/* å‹¾é€‰ç¾¤ç»„åŠ å…¥æ‰€é€‰åˆ†ç»„ */}
                      <div className="border rounded-md p-4 space-y-2">
                        <div className="flex items-center justify-between">
                          <div className="text-sm font-medium">å‹¾é€‰ç¾¤ç»„åŠ å…¥å½“å‰åˆ†ç»„</div>
                          <div className="text-xs text-slate-500">å½“å‰åˆ†ç»„ï¼š{selectedGroup ? selectedGroup.name : 'æœªé€‰æ‹©'}</div>
                        </div>
                        {chatsForBot.length === 0 ? (
                          <div className="text-sm text-slate-500">æš‚æ— ç¾¤ç»„</div>
                        ) : (
                          <div className="space-y-1 max-h-[360px] overflow-y-auto">
                            {chatsForBot.map((chat) => {
                              const initialChecked = chat.groupId === selectedGroupId
                              const hasPending = Object.prototype.hasOwnProperty.call(pending, chat.id)
                              const checked = hasPending ? pending[chat.id] : initialChecked
                              return (
                                <label key={chat.id} className="flex items-center gap-2 text-sm">
                                  <input
                                    type="checkbox"
                                    checked={checked}
                                    onChange={(e) => {
                                      const val = e.target.checked
                                      setGroupDialogs((prev) => {
                                        const cur = prev[bot.id] || { open: true }
                                        const p = cur.pending || {}
                                        return { ...prev, [bot.id]: { ...cur, selectedGroupId, pending: { ...p, [chat.id]: val } } }
                                      })
                                    }}
                                  />
                                  <span className="truncate">{chat.title || chat.id}</span>
                                  {chat.groupId && chat.groupId !== selectedGroupId && (
                                    <span className="text-xs text-slate-500">(å½“å‰åœ¨ {botGroups.find((g) => g.id === chat.groupId)?.name || chat.groupId})</span>
                                  )}
                                </label>
                              )
                            })}
                          </div>
                        )}
                        <div className="flex justify-end gap-2 pt-2">
                          <button
                            className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50"
                            onClick={() => setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true, selectedGroupId, pending: {} } }))}
                          >é‡ç½®é€‰æ‹©</button>
                          <button
                            className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
                            disabled={!selectedGroupId || groupSaving[bot.id]}
                            onClick={async () => {
                              if (!selectedGroupId) return
                              setGroupSaving((prev) => ({ ...prev, [bot.id]: true }))
                              try {
                                const changes: Array<{ chatId: string; groupId: string | null; prevGroupId: string | null }> = []
                                for (const chat of chatsForBot) {
                                  const initialChecked = chat.groupId === selectedGroupId
                                  const hasPending = Object.prototype.hasOwnProperty.call(pending, chat.id)
                                  const desired = hasPending ? pending[chat.id] : initialChecked
                                  if (desired === initialChecked) continue
                                  changes.push({ chatId: chat.id, groupId: desired ? selectedGroupId : null, prevGroupId: chat.groupId || null })
                                }
                                for (const ch of changes) {
                                  await fetch(`/api/chats/${encodeURIComponent(ch.chatId)}/group`, {
                                    method: 'PATCH',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ groupId: ch.groupId })
                                  })
                                }
                                setGroups((prev) => prev.map((g: any) => {
                                  const change = changes.find((c) => c.chatId === g.id)
                                  if (change) return { ...g, groupId: change.groupId }
                                  return g
                                }))
                                setChatGroups((prev) => {
                                  const current = prev[bot.id] || []
                                  return {
                                    ...prev,
                                    [bot.id]: current.map((g) => {
                                      let count = g.chatCount || 0
                                      for (const ch of changes) {
                                        if (ch.groupId === g.id) count += 1
                                        if (ch.prevGroupId === g.id && ch.groupId !== g.id) count = Math.max(0, count - 1)
                                      }
                                      return { ...g, chatCount: count }
                                    })
                                  }
                                })
                                setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: true, selectedGroupId, pending: {} } }))
                                toast({ title: 'æˆåŠŸ', description: 'åˆ†ç»„æˆå‘˜å·²æ›´æ–°' })
                              } catch {
                                toast({ title: 'é”™è¯¯', description: 'ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•', variant: 'destructive' })
                              } finally {
                                setGroupSaving((prev) => ({ ...prev, [bot.id]: false }))
                              }
                            }}
                          >ä¿å­˜</button>
                        </div>
                      </div>
                    </div>

                    <div className="mt-4 flex justify-end gap-2">
                      <button
                        className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50"
                        onClick={() => {
                          setGroupDialogs((prev) => ({ ...prev, [bot.id]: { open: false } }))
                          setGroupForm({ name: '', description: '' })
                        }}
                      >å…³é—­</button>
                    </div>
                  </DialogContent>
                </Dialog>
              )
            })}

            {/* ç¾¤ç»„ç®¡ç†å¡ç‰‡ */}
            <div className="bg-white border rounded-lg p-6">
              <div className="flex items-start justify-between mb-4">
                <div>
                  <div className="flex items-center gap-2">
                    <div className="text-lg font-semibold text-slate-900">ç¾¤ç»„ç®¡ç†</div>
                    <Dialog>
                      <DialogTrigger asChild>
                        <button className="text-blue-600 hover:text-blue-700 text-sm font-medium">
                          â„¹ï¸ è¯´æ˜
                        </button>
                      </DialogTrigger>
                      <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
                        <DialogHeader>
                          <DialogTitle>ç¾¤ç»„ç®¡ç†è¯´æ˜</DialogTitle>
                          <DialogDescription className="space-y-4 pt-4">
                            <div>
                              <h3 className="font-semibold text-slate-900 mb-2">ğŸ“¥ è‡ªåŠ¨æ·»åŠ ç¾¤ç»„</h3>
                              <p className="text-sm text-slate-600 mb-2">
                                å½“æœºå™¨äººè¢«é‚€è¯·åŠ å…¥ç¾¤ç»„æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åœ¨ç¾¤ç»„ç®¡ç†ä¸­åˆ›å»ºè¯¥ç¾¤ç»„çš„è®°å½•ï¼Œå¹¶æ˜¾ç¤ºé‚€è¯·äººä¿¡æ¯ã€‚
                              </p>
                              <p className="text-sm text-slate-600">
                                å¦‚æœé‚€è¯·äººåœ¨ç™½åå•ä¸­ï¼Œè¯¥ç¾¤ç»„å°†è‡ªåŠ¨è¢«æˆæƒä½¿ç”¨ï¼ˆæ— éœ€æ‰‹åŠ¨æ‰¹å‡†ï¼‰ã€‚
                              </p>
                            </div>
                            
                            <div>
                              <h3 className="font-semibold text-slate-900 mb-2">ğŸ“¤ è‡ªåŠ¨åˆ é™¤ç¾¤ç»„</h3>
                              <p className="text-sm text-slate-600">
                                å½“æœºå™¨äººè¢«è¸¢å‡ºç¾¤ç»„æˆ–ç¦»å¼€ç¾¤ç»„æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨åˆ é™¤è¯¥ç¾¤ç»„çš„è®°å½•åŠç›¸å…³æ•°æ®ã€‚
                              </p>
                            </div>
                            
                            <div>
                              <h3 className="font-semibold text-slate-900 mb-2">ğŸ”„ æ•°æ®åˆ·æ–°è¯´æ˜</h3>
                              <p className="text-sm text-slate-600 mb-2">
                                å¦‚æœæ•°æ®æ²¡æœ‰æ›´æ–°ï¼ˆå¦‚æ–°æ·»åŠ çš„ç¾¤ç»„ã€é‚€è¯·äººä¿¡æ¯ç­‰ï¼‰ï¼Œè¯·åˆ·æ–°é¡µé¢ï¼š
                              </p>
                              <ul className="list-disc list-inside text-sm text-slate-600 space-y-1 mb-2">
                                <li>æŒ‰ F5 æˆ– Ctrl+Rï¼ˆWindows/Linuxï¼‰åˆ·æ–°é¡µé¢</li>
                                <li>æŒ‰ Cmd+Rï¼ˆMacï¼‰åˆ·æ–°é¡µé¢</li>
                                <li>æˆ–ç‚¹å‡»æµè§ˆå™¨çš„åˆ·æ–°æŒ‰é’®</li>
                              </ul>
                              <p className="text-sm text-slate-600">
                                ç³»ç»Ÿä¼šè‡ªåŠ¨åˆ·æ–°ç¾¤ç»„åˆ—è¡¨ï¼ˆæ¯30ç§’ï¼‰ï¼Œä½†å¦‚æœé‚€è¯·äººä¿¡æ¯æœªæ˜¾ç¤ºï¼Œä»éœ€è¦æ‰‹åŠ¨åˆ·æ–°é¡µé¢ã€‚
                              </p>
                            </div>
                            
                            <div>
                              <h3 className="font-semibold text-slate-900 mb-2">ğŸ—‘ï¸ åˆ é™¤åŠŸèƒ½</h3>
                              <p className="text-sm text-slate-600 mb-2">
                                <strong>å•ä¸ªåˆ é™¤ï¼š</strong>ç‚¹å‡»ç¾¤ç»„è¡Œå³ä¾§çš„ ğŸ—‘ï¸ æŒ‰é’®ï¼Œå¯ä»¥åˆ é™¤è¯¥ç¾¤ç»„åŠå…¶æ‰€æœ‰ç›¸å…³æ•°æ®ï¼ˆåŒ…æ‹¬è´¦å•ã€è®¾ç½®ã€æ“ä½œå‘˜ç­‰ï¼‰ã€‚æ­¤æ“ä½œä¸å¯æ¢å¤ã€‚
                              </p>
                              <p className="text-sm text-slate-600">
                                <strong>æ‰¹é‡åˆ é™¤ï¼š</strong>å‹¾é€‰å¤šä¸ªç¾¤ç»„å‰çš„å¤é€‰æ¡†ï¼Œç„¶åç‚¹å‡»"åˆ é™¤é€‰ä¸­"æŒ‰é’®ï¼Œå¯ä»¥æ‰¹é‡åˆ é™¤é€‰ä¸­çš„ç¾¤ç»„ã€‚æ­¤æ“ä½œä¸å¯æ¢å¤ã€‚
                              </p>
                            </div>
                            
                            <div>
                              <h3 className="font-semibold text-slate-900 mb-2">âš™ï¸ å¿«æ·è®¾ç½®</h3>
                              <p className="text-sm text-slate-600 mb-2">
                                ç‚¹å‡»ç¾¤ç»„è¡Œå·¦ä¾§çš„å±•å¼€æŒ‰é’®ï¼ˆâ–¶ï¼‰ï¼Œå¯ä»¥å±•å¼€è¯¥ç¾¤ç»„çš„å¿«æ·è®¾ç½®ï¼ŒåŒ…æ‹¬ï¼š
                              </p>
                              <ul className="list-disc list-inside text-sm text-slate-600 space-y-1">
                                <li><strong>åŠŸèƒ½å¼€å…³ï¼š</strong>åŸºç¡€è®°è´¦ç­‰åŠŸèƒ½çš„å¯ç”¨/ç¦ç”¨</li>
                                <li><strong>åœ°å€éªŒè¯ï¼š</strong>å¯ç”¨åæ£€æµ‹é’±åŒ…åœ°å€å˜æ›´å¹¶æé†’</li>
                                <li><strong>åˆ é™¤è´¦å•ç¡®è®¤ï¼š</strong>å¯ç”¨ååˆ é™¤è´¦å•éœ€è¦äºŒæ¬¡ç¡®è®¤</li>
                                <li><strong>è®¡ç®—å™¨ï¼š</strong>å¯ç”¨åæ”¯æŒæ•°å­¦è®¡ç®—åŠŸèƒ½ï¼ˆå¦‚288-32ã€288*2ç­‰ï¼‰</li>
                              </ul>
                              <p className="text-sm text-slate-600 mt-2">
                                å¿«æ·è®¾ç½®ä¸ç¾¤ç»„è®¾ç½®é¡µé¢çš„è®¾ç½®ä¿æŒåŒæ­¥ï¼Œä¿®æ”¹åä¼šç«‹å³ç”Ÿæ•ˆã€‚
                              </p>
                            </div>
                            
                            <div>
                              <h3 className="font-semibold text-slate-900 mb-2">â• æ‰‹åŠ¨æ·»åŠ ç¾¤ç»„</h3>
                              <p className="text-sm text-slate-600 mb-2">
                                å¦‚æœæœºå™¨äººå·²ç»åœ¨ç¾¤ç»„ä¸­ï¼Œä½†ç¾¤ç»„ç®¡ç†ä¸­æ²¡æœ‰æ˜¾ç¤ºï¼Œå¯ä»¥ä½¿ç”¨"æ‰‹åŠ¨æ·»åŠ ç¾¤"åŠŸèƒ½ï¼š
                              </p>
                              <ol className="list-decimal list-inside text-sm text-slate-600 space-y-1">
                                <li>ç‚¹å‡»"æ‰‹åŠ¨æ·»åŠ ç¾¤"æŒ‰é’®</li>
                                <li>è¾“å…¥ç¾¤ç»„çš„ Chat IDï¼ˆæ ¼å¼ï¼š-1001234567890ï¼‰</li>
                                <li>é€‰æ‹©è¦ç»‘å®šçš„æœºå™¨äºº</li>
                                <li>ç‚¹å‡»"ç¡®å®šæ·»åŠ "</li>
                              </ol>
                              <p className="text-sm text-slate-600 mt-2">
                                æ‰‹åŠ¨æ·»åŠ çš„ç¾¤ç»„ï¼Œé‚€è¯·äºº/æ–¹å¼ä¼šæ˜¾ç¤ºä¸º"æ‰‹åŠ¨"ã€‚
                              </p>
                            </div>
                            
                            <div>
                              <h3 className="font-semibold text-slate-900 mb-2">ğŸ‘¤ é‚€è¯·äºº/æ–¹å¼</h3>
                              <p className="text-sm text-slate-600 mb-2">
                                æ­¤åˆ—æ˜¾ç¤ºå°†æœºå™¨äººé‚€è¯·åˆ°ç¾¤ç»„çš„ç”¨æˆ·ä¿¡æ¯ï¼š
                              </p>
                              <ul className="list-disc list-inside text-sm text-slate-600 space-y-1">
                                <li>å¦‚æœæ˜¾ç¤ºç”¨æˆ·åï¼ˆå¦‚ @Thy1ccï¼‰ï¼Œè¡¨ç¤ºè¯¥ç”¨æˆ·é‚€è¯·çš„æœºå™¨äºº</li>
                                <li>å¦‚æœæ˜¾ç¤º"æ‰‹åŠ¨"ï¼Œè¡¨ç¤ºè¯¥ç¾¤ç»„æ˜¯é€šè¿‡"æ‰‹åŠ¨æ·»åŠ ç¾¤"åŠŸèƒ½æ·»åŠ çš„</li>
                                <li>å¦‚æœæ˜¾ç¤º"-"ï¼Œè¡¨ç¤ºæ— æ³•è·å–é‚€è¯·äººä¿¡æ¯ï¼ˆå¯èƒ½æ˜¯æ—§æ•°æ®æˆ–æœºå™¨äººè¢«è¸¢å‡ºåé‡æ–°åŠ å…¥ï¼‰</li>
                              </ul>
                            </div>
                          </DialogDescription>
                        </DialogHeader>
                      </DialogContent>
                    </Dialog>
                  </div>
                  <div className="text-sm text-slate-600 mt-1">{groupsCount === 0 ? 'æš‚æ— ç¾¤ç»„' : (groupsCount == null ? 'åŠ è½½ä¸­...' : `å…± ${groupsCount} ä¸ªç¾¤ç»„`)}</div>
                </div>
                <div className="flex gap-2">
                  {selectedGroups.size > 0 && (
                    <button
                      className="px-3 py-1.5 text-sm border rounded-md hover:bg-red-50 text-red-600 font-medium"
                      onClick={() => {
                        showConfirm(
                          'æ‰¹é‡åˆ é™¤ç¾¤ç»„',
                          `ç¡®è®¤åˆ é™¤é€‰ä¸­çš„ ${selectedGroups.size} ä¸ªç¾¤ç»„åŠå…¶ç›¸å…³æ•°æ®ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤`,
                          async () => {
                            let successCount = 0
                            let failCount = 0
                            
                            for (const chatId of selectedGroups) {
                              try {
                                const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}`, { method: 'DELETE' })
                                if (res.status === 204) {
                                  successCount++
                                } else {
                                  failCount++
                                }
                              } catch {
                                failCount++
                              }
                            }
                            
                            setSelectedGroups(new Set())
                            toast({ title: 'æ‰¹é‡åˆ é™¤å®Œæˆ', description: `æˆåŠŸï¼š${successCount} ä¸ªï¼Œå¤±è´¥ï¼š${failCount} ä¸ª` })
                            
                            // é‡æ–°åŠ è½½ç¾¤åˆ—è¡¨
                            setTimeout(() => window.location.reload(), 500)
                          }
                        )
                      }}
                    >ğŸ—‘ï¸ åˆ é™¤é€‰ä¸­ ({selectedGroups.size})</button>
                  )}
                  <button
                    className="px-3 py-1.5 text-sm border rounded-md hover:bg-blue-50 text-blue-600 font-medium disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled={batchSaving || groups.length === 0}
                    onClick={() => {
                      showConfirm(
                        'æ‰¹é‡ä¿å­˜è®¾ç½®',
                        `ç¡®è®¤ä¿å­˜æ‰€æœ‰ ${groups.length} ä¸ªç¾¤ç»„çš„è®¾ç½®ï¼Ÿ`,
                        async () => {
                          setBatchSaving(true)
                          let successCount = 0
                          let failCount = 0
                          
                          for (const it of groups) {
                            const latest = drafts[it.id]
                            if (!latest) continue
                            
                            try {
                              const res = await fetch(`/api/chats/${encodeURIComponent(it.id)}`, {
                                method: 'PATCH',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                  status: latest.status,
                                  botId: latest.botId ?? null,
                                  allowed: latest.allowed,
                                }),
                              })
                              if (res.ok) {
                                successCount++
                              } else {
                                failCount++
                              }
                            } catch {
                              failCount++
                            }
                          }
                          
                          setBatchSaving(false)
                          toast({ title: 'æ‰¹é‡ä¿å­˜å®Œæˆ', description: `æˆåŠŸï¼š${successCount} ä¸ªï¼Œå¤±è´¥ï¼š${failCount} ä¸ª` })
                          
                          // æ¸…é™¤ç¼“å­˜ï¼Œé‡æ–°åŠ è½½
                          if (typeof window !== 'undefined') {
                            localStorage.removeItem('dashboard_cache_groups')
                            localStorage.removeItem('dashboard_cache_bots')
                          }
                          setTimeout(() => window.location.reload(), 1000)
                        }
                      )
                    }}
                  >{batchSaving ? 'æ‰¹é‡ä¿å­˜ä¸­...' : 'ğŸ’¾ ä¸€é”®ä¿å­˜å…¨éƒ¨'}</button>
                  <button
                    className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50"
                    onClick={() => setManualAdd({ open: true, chatId: '', botId: '' })}
                  >æ‰‹åŠ¨æ·»åŠ ç¾¤</button>
                </div>
              </div>

              {groupsCount === 0 ? (
                <div className="text-center text-slate-500 text-sm py-6">æš‚æ— ç¾¤ç»„</div>
              ) : (
                <>
                  {/* ğŸ”¥ æ–°å¢ï¼šé‚€è¯·äººç­›é€‰ä¸‹æ‹‰æ¡† */}
                  <div className="mb-4 flex items-center gap-3">
                    <label className="text-sm font-medium text-slate-700">æŒ‰é‚€è¯·äººç­›é€‰ï¼š</label>
                    <select
                      className="border rounded-md px-3 py-1.5 text-sm focus:ring-2 focus:ring-blue-500 focus:border-blue-500 min-w-[150px]"
                      value={inviterFilter}
                      onChange={(e) => setInviterFilter(e.target.value)}
                    >
                      <option value="å…¨éƒ¨">å…¨éƒ¨</option>
                      {inviterOptions.map(username => (
                        <option key={username} value={username}>{username}</option>
                      ))}
                    </select>
                    <span className="text-sm text-slate-500">
                      ï¼ˆæ˜¾ç¤º {filteredGroups.length} ä¸ªç¾¤ç»„ï¼‰
                    </span>
                  </div>
                  
                  <div className="w-full">
                    <table className="w-full border-collapse">
                    <thead className="bg-slate-50">
                      <tr className="border-b-2 border-slate-200">
                        <th className="text-center py-3 px-3 text-sm font-semibold text-slate-700 w-[4%]">
                          <input
                            type="checkbox"
                            className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                            checked={filteredGroups.length > 0 && selectedGroups.size === filteredGroups.length}
                            onChange={(e) => {
                              if (e.target.checked) {
                                setSelectedGroups(new Set(filteredGroups.map(g => g.id)))
                              } else {
                                setSelectedGroups(new Set())
                              }
                            }}
                          />
                        </th>
                        <th className="text-left py-3 px-3 text-sm font-semibold text-slate-700 w-[11%]">Chat ID</th>
                        <th className="text-left py-3 px-3 text-sm font-semibold text-slate-700 w-[15%]">ç¾¤ç»„åç§°</th>
                        <th className="text-left py-3 px-3 text-sm font-semibold text-slate-700 w-[15%]">ç»‘å®šæœºå™¨äºº</th>
                        <th className="text-left py-3 px-3 text-sm font-semibold text-slate-700 w-[14%]">é‚€è¯·äºº/æ–¹å¼</th>
                        <th className="text-center py-3 px-3 text-sm font-semibold text-slate-700 w-[12%]">å…è®¸ä½¿ç”¨</th>
                        <th className="text-left py-3 px-3 text-sm font-semibold text-slate-700 w-[18%]">åˆ›å»ºæ—¶é—´</th>
                        <th className="text-center py-3 px-3 text-sm font-semibold text-slate-700 w-[22%]">æ“ä½œ</th>
                      </tr>
                    </thead>
                    <tbody>
                      {filteredGroups.map((it, idx) => {
                          const draft = drafts[it.id] || { status: 'PENDING', botId: it.botId ?? null, allowed: !!it.allowed }
                          // ğŸ”¥ ä½¿ç”¨æ•°æ®åº“è¿”å›çš„é‚€è¯·äººä¿¡æ¯ï¼Œä¼˜å…ˆä½¿ç”¨ invitedByUsernameï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨æ‰‹åŠ¨æ·»åŠ æ ‡è®°
                          const inviterLabel = it.invitedByUsername || (manualAddedSet.has(it.id) ? 'æ‰‹åŠ¨' : '-')
                        return (
                          <Fragment key={it.id}>
                            <tr className={`border-b hover:bg-slate-50 transition-colors ${idx % 2 === 0 ? 'bg-white' : 'bg-slate-25'}`}>
                              <td className="py-3 px-3 text-center">
                                <input
                                  type="checkbox"
                                  className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                  checked={selectedGroups.has(it.id)}
                                  onChange={(e) => {
                                    const newSelected = new Set(selectedGroups)
                                    if (e.target.checked) {
                                      newSelected.add(it.id)
                                    } else {
                                      newSelected.delete(it.id)
                                    }
                                    setSelectedGroups(newSelected)
                                  }}
                                />
                              </td>
                              <td className="py-3 px-3 text-sm text-slate-900 font-mono truncate" title={it.id}>{it.id}</td>
                              <td className="py-3 px-3 text-sm text-slate-900 font-medium truncate" title={it.title || '-'}>{it.title || '-'}</td>
                              <td className="py-3 px-3">
                                <select
                                  className="border rounded-md px-2 py-1.5 text-xs w-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                  value={draft.botId || ''}
                                  onChange={(e) => {
                                    const value = e.target.value || null
                                    setDrafts((d) => ({
                                      ...d,
                                      [it.id]: {
                                        status: (d[it.id]?.status || draft.status) as typeof draft.status,
                                        botId: value,
                                        allowed: d[it.id]?.allowed ?? draft.allowed,
                                      },
                                    }))
                                  }}
                                >
                                  <option value="">æœªç»‘å®š</option>
                                  {(eligibleBots[it.id] || []).map((b) => (
                                    <option key={b.id} value={b.id}>{b.name}</option>
                                  ))}
                                </select>
                              </td>
                              <td className="py-3 px-3 text-sm text-slate-900 truncate" title={inviterLabel}>{inviterLabel}</td>
                              <td className="py-3 px-3 text-center">
                                <input
                                  type="checkbox"
                                  className="w-4 h-4 text-blue-600 rounded focus:ring-blue-500"
                                  checked={draft.allowed}
                                  onChange={(e) => {
                                    const allowed = e.target.checked
                                    const status = allowed ? 'APPROVED' : 'PENDING'
                                    setDrafts((d) => ({
                                      ...d,
                                      [it.id]: {
                                        status,
                                        allowed,
                                        botId: (d[it.id]?.botId ?? draft.botId) ?? null,
                                      },
                                    }))
                                  }}
                                />
                              </td>
                              <td className="py-3 px-3 text-xs text-slate-600">{new Date(it.createdAt).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' })}</td>
                              <td className="py-3 px-3">
                                <div className="flex items-center justify-center gap-1 flex-wrap">
                                  <button
                                    className="px-2.5 py-1 text-xs border rounded hover:bg-slate-50 whitespace-nowrap"
                                    onClick={() => router.push(`/dashboard?chatId=${encodeURIComponent(it.id)}`)}
                                  >ğŸ“Š è´¦å•</button>
                                  <button
                                    className="px-2.5 py-1 text-xs border rounded hover:bg-slate-50 whitespace-nowrap"
                                    onClick={async () => {
                                      setExpandedRows((r) => ({ ...r, [it.id]: !r[it.id] }))
                                      const chatId = it.id
                                      // æ€»æ˜¯é‡æ–°æ‹‰å–ï¼Œé¿å…å‘½ä»¤æ“ä½œä¸UIä¸åŒæ­¥
                                      setFeatureCache((c) => ({ ...c, [chatId]: { items: [], loading: true } }))
                                      try {
                                        const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/features`)
                                        if (res.ok) {
                                          const json = await res.json()
                                          const items = Array.isArray(json?.items) ? json.items : []
                                          setFeatureCache((c) => ({ ...c, [chatId]: { items } }))
                                        } else {
                                          setFeatureCache((c) => ({ ...c, [chatId]: { items: [] } }))
                                        }
                                      } catch {
                                        setFeatureCache((c) => ({ ...c, [chatId]: { items: [] } }))
                                      }
                                      // åŒæ­¥æ‹‰å–å¿«æ·è®¾ç½®ï¼ˆè®¡ç®—å™¨ç­‰ï¼‰
                                      setQuickSettingsCache((c) => ({ ...c, [chatId]: { addressVerificationEnabled: false, deleteBillConfirm: false, calculatorEnabled: true, showAuthPrompt: true, loading: true } }))
                                      try {
                                        const sres = await fetch(`/api/chats/${encodeURIComponent(chatId)}/settings`)
                                        if (sres.ok) {
                                          const json = await sres.json()
                                          const settings = json?.settings || {}
                                          setQuickSettingsCache((c) => ({ ...c, [chatId]: {
                                            addressVerificationEnabled: settings.addressVerificationEnabled ?? false,
                                            deleteBillConfirm: settings.deleteBillConfirm ?? false,
                                            calculatorEnabled: settings.calculatorEnabled ?? true,
                                            showAuthPrompt: settings.showAuthPrompt ?? true,
                                            loading: false
                                          }}))
                                        } else {
                                          setQuickSettingsCache((c) => ({ ...c, [chatId]: { addressVerificationEnabled: false, deleteBillConfirm: false, calculatorEnabled: true, showAuthPrompt: true, loading: false } }))
                                        }
                                      } catch {
                                        setQuickSettingsCache((c) => ({ ...c, [chatId]: { addressVerificationEnabled: false, deleteBillConfirm: false, calculatorEnabled: true, showAuthPrompt: true, loading: false } }))
                                      }
                                    }}
                                  >{expandedRows[it.id] ? 'â¬†ï¸ æ”¶èµ·' : 'âš™ï¸ åŠŸèƒ½'}</button>
                                  <button
                                    className="px-2.5 py-1 text-xs border rounded hover:bg-slate-50 whitespace-nowrap"
                                    onClick={() => router.push(`/chats/${encodeURIComponent(it.id)}?chatId=${encodeURIComponent(it.id)}`)}
                                  >ğŸ”§ è®¾ç½®</button>
                                  <button
                                    className="px-2.5 py-1 text-xs border rounded hover:bg-green-50 text-green-700 font-medium whitespace-nowrap disabled:opacity-50"
                                    disabled={!!saving[it.id]}
                                    onClick={async () => {
                                      const latest = drafts[it.id]
                                      if (!latest) return
                                      setSaving((s) => ({ ...s, [it.id]: true }))
                                      try {
                                        const res = await fetch(`/api/chats/${encodeURIComponent(it.id)}`, {
                                          method: 'PATCH',
                                          headers: { 'Content-Type': 'application/json' },
                                          body: JSON.stringify({
                                            status: latest.status,
                                            botId: latest.botId ?? null,
                                            allowed: latest.allowed,
                                          }),
                                        })
                                        if (!res.ok) {
                                          const msg = await res.text().catch(() => '')
                                          throw new Error(msg || 'save failed')
                                        }
                                        toast({ title: 'æˆåŠŸ', description: 'ä¿å­˜æˆåŠŸ' })
                                      } catch (e) {
                                        toast({ title: 'é”™è¯¯', description: `ä¿å­˜å¤±è´¥ï¼š${(e as Error).message}`, variant: 'destructive' })
                                      } finally {
                                        setSaving((s) => ({ ...s, [it.id]: false }))
                                      }
                                    }}
                                  >{saving[it.id] ? 'â³' : 'ğŸ’¾'}</button>
                                  <button
                                    className="px-2.5 py-1 text-xs border rounded hover:bg-red-50 text-red-600 whitespace-nowrap"
                                    onClick={() => {
                                      showConfirm(
                                        'åˆ é™¤ç¾¤ç»„',
                                        'ç¡®è®¤åˆ é™¤è¯¥ç¾¤ç»„åŠå…¶ç›¸å…³æ•°æ®ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤',
                                        async () => {
                                          try {
                                            const res = await fetch(`/api/chats/${encodeURIComponent(it.id)}`, { method: 'DELETE' })
                                            if (res.status === 204) {
                                              setGroups((prev) => prev.filter((g) => g.id !== it.id))
                                              const n = (groupsCount || 0) - 1
                                              setGroupsCount(n < 0 ? 0 : n)
                                              toast({ title: 'æˆåŠŸ', description: 'åˆ é™¤æˆåŠŸ' })
                                            } else {
                                              const msg = await res.text().catch(() => '')
                                              toast({ title: 'é”™è¯¯', description: `åˆ é™¤å¤±è´¥ï¼š${msg || 'Server error'}`, variant: 'destructive' })
                                            }
                                          } catch {
                                            toast({ title: 'é”™è¯¯', description: 'åˆ é™¤å¤±è´¥ï¼šç½‘ç»œé”™è¯¯', variant: 'destructive' })
                                          }
                                        }
                                      )
                                    }}
                                  >ğŸ—‘ï¸</button>
                                </div>
                              </td>
                            </tr>
                            {expandedRows[it.id] && (
                              <tr>
                                <td colSpan={7} className="bg-slate-50 p-3">
                                  <div className="space-y-4">
                                    {/* åŠŸèƒ½å¼€å…³ */}
                                    <div>
                                      <div className="text-sm text-slate-700 mb-2">åŠŸèƒ½å¼€å…³ï¼ˆç¾¤ç»„ {it.title || it.id}ï¼‰</div>
                                      <div className="flex flex-wrap gap-4 items-center">
                                        {((featureCache[it.id]?.items) || []).map((f, idx) => (
                                          <label key={f.feature + idx} className="inline-flex items-center gap-2 text-sm">
                                            <input
                                              type="checkbox"
                                              checked={!!f.enabled}
                                              onChange={(e) => {
                                                const enabled = e.target.checked
                                                const chatId = it.id
                                                setFeatureCache((c) => ({
                                                  ...c,
                                                  [chatId]: { items: (c[chatId]?.items || []).map(x => x.feature === f.feature ? { ...x, enabled } : x) },
                                                }))
                                              }}
                                            />
                                            <span>{FEATURE_NAME_MAP[f.feature] || f.feature}</span>
                                          </label>
                                        ))}
                                        <button
                                          className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
                                          disabled={featureSaving[it.id]}
                                          onClick={async () => {
                                            const chatId = it.id
                                            const payload = { features: (featureCache[chatId]?.items || []) }
                                            setFeatureSaving((s) => ({ ...s, [chatId]: true }))
                                            try {
                                              const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/features`, {
                                                method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                                              })
                                              if (!res.ok) {
                                                const msg = await res.text().catch(() => '')
                                                throw new Error(msg || 'ä¿å­˜åŠŸèƒ½å¼€å…³å¤±è´¥')
                                              }
                                              const fres = await fetch(`/api/chats/${encodeURIComponent(chatId)}/features`)
                                              if (fres.ok) {
                                                const json = await fres.json().catch(() => ({}))
                                                const items = Array.isArray(json?.items) ? json.items : []
                                                setFeatureCache((c) => ({ ...c, [chatId]: { items } }))
                                              }
                                              toast({ title: 'æˆåŠŸ', description: 'å·²ä¿å­˜åŠŸèƒ½å¼€å…³' })
                                            } catch (e) {
                                              toast({ title: 'é”™è¯¯', description: (e as Error).message, variant: 'destructive' })
                                            } finally {
                                              setFeatureSaving((s) => ({ ...s, [chatId]: false }))
                                            }
                                          }}
                                        >{featureSaving[it.id] ? 'ä¿å­˜ä¸­...' : 'ä¿å­˜åŠŸèƒ½'}</button>
                                      </div>
                                    </div>
                                    
                                    {/* ğŸ”¥ å¿«æ·è®¾ç½® */}
                                    <div>
                                      <div className="text-sm text-slate-700 mb-2">å¿«æ·è®¾ç½®</div>
                                      <div className="flex flex-wrap gap-4 items-center">
                                        <label className="inline-flex items-center gap-2 text-sm">
                                          <input
                                            type="checkbox"
                                            checked={quickSettingsCache[it.id]?.addressVerificationEnabled ?? false}
                                            onChange={(e) => {
                                              const chatId = it.id
                                              setQuickSettingsCache((c) => ({
                                                ...c,
                                                [chatId]: { ...(c[chatId] || { addressVerificationEnabled: false, deleteBillConfirm: false, calculatorEnabled: true, showAuthPrompt: true }), addressVerificationEnabled: e.target.checked }
                                              }))
                                            }}
                                          />
                                          <span>åœ°å€éªŒè¯</span>
                                        </label>
                                        <label className="inline-flex items-center gap-2 text-sm">
                                          <input
                                            type="checkbox"
                                            checked={quickSettingsCache[it.id]?.deleteBillConfirm ?? false}
                                            onChange={(e) => {
                                              const chatId = it.id
                                              setQuickSettingsCache((c) => ({
                                                ...c,
                                                [chatId]: { ...(c[chatId] || { addressVerificationEnabled: false, deleteBillConfirm: false, calculatorEnabled: true, showAuthPrompt: true }), deleteBillConfirm: e.target.checked }
                                              }))
                                            }}
                                          />
                                          <span>åˆ é™¤è´¦å•ç¡®è®¤</span>
                                        </label>
                                        <label className="inline-flex items-center gap-2 text-sm">
                                          <input
                                            type="checkbox"
                                            checked={quickSettingsCache[it.id]?.calculatorEnabled ?? true}
                                            onChange={(e) => {
                                              const chatId = it.id
                                              setQuickSettingsCache((c) => ({
                                                ...c,
                                                [chatId]: { ...(c[chatId] || { addressVerificationEnabled: false, deleteBillConfirm: false, calculatorEnabled: true, showAuthPrompt: true }), calculatorEnabled: e.target.checked }
                                              }))
                                            }}
                                          />
                                          <span>è®¡ç®—å™¨</span>
                                        </label>
                                        <label className="inline-flex items-center gap-2 text-sm">
                                          <input
                                            type="checkbox"
                                            checked={quickSettingsCache[it.id]?.showAuthPrompt ?? true}
                                            onChange={(e) => {
                                              const chatId = it.id
                                              setQuickSettingsCache((c) => ({
                                                ...c,
                                                [chatId]: { ...(c[chatId] || { addressVerificationEnabled: false, deleteBillConfirm: false, calculatorEnabled: true, showAuthPrompt: true }), showAuthPrompt: e.target.checked }
                                              }))
                                            }}
                                          />
                                          <span>æ˜¾ç¤ºæˆæƒæç¤º</span>
                                        </label>
                                        <div className="mt-2">
                                          <label className="block text-sm font-medium mb-1">æ¬¢è¿æ¶ˆæ¯</label>
                                          <textarea
                                            className="w-full px-3 py-2 border rounded-md text-sm"
                                            placeholder="æœºå™¨äººåŠ å…¥ç¾¤ç»„åå‘é€çš„æ¬¢è¿æ¶ˆæ¯ï¼Œæ”¯æŒ Markdown æ ¼å¼"
                                            rows={2}
                                            value={quickSettingsCache[it.id]?.welcomeMessage || ''}
                                            onChange={(e) => {
                                              const chatId = it.id
                                              setQuickSettingsCache((c) => ({
                                                ...c,
                                                [chatId]: { ...(c[chatId] || { addressVerificationEnabled: false, deleteBillConfirm: false, calculatorEnabled: true, showAuthPrompt: true, welcomeMessage: '' }), welcomeMessage: e.target.value }
                                              }))
                                            }}
                                          />
                                        </div>
                                        <button
                                          className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
                                          disabled={quickSettingsSaving[it.id]}
                                          onClick={async () => {
                                            const chatId = it.id
                                            const settings = quickSettingsCache[chatId]
                                            if (!settings) return
                                            setQuickSettingsSaving((s) => ({ ...s, [chatId]: true }))
                                            try {
                                              const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/settings`, {
                                                method: 'PATCH',
                                                headers: { 'Content-Type': 'application/json' },
                                                body: JSON.stringify({
                                                  addressVerificationEnabled: settings.addressVerificationEnabled,
                                                  deleteBillConfirm: settings.deleteBillConfirm,
                                                  calculatorEnabled: settings.calculatorEnabled,
                                                  showAuthPrompt: settings.showAuthPrompt,
                                                  welcomeMessage: settings.welcomeMessage || null
                                                })
                                              })
                                              if (!res.ok) {
                                                const msg = await res.text().catch(() => '')
                                                throw new Error(msg || 'ä¿å­˜å¿«æ·è®¾ç½®å¤±è´¥')
                                              }
                                              toast({ title: 'æˆåŠŸ', description: 'å·²ä¿å­˜å¿«æ·è®¾ç½®' })
                                            } catch (e) {
                                              toast({ title: 'é”™è¯¯', description: (e as Error).message, variant: 'destructive' })
                                            } finally {
                                              setQuickSettingsSaving((s) => ({ ...s, [chatId]: false }))
                                            }
                                          }}
                                        >{quickSettingsSaving[it.id] ? 'ä¿å­˜ä¸­...' : 'ä¿å­˜è®¾ç½®'}</button>
                                      </div>
                                    </div>
                                  </div>
                                </td>
                              </tr>
                            )}
                          </Fragment>
                        )
                      })}
                    </tbody>
                  </table>
                </div>
              </>
              )}
            </div>
          </div>
        ) : (
          <div className="space-y-6 mt-6">
            <StatisticsCards 
              currentDate={currentDate} 
              chatId={chatId}
              onBillDataChange={handleBillDataChange}
            />
            <TransactionTables currentDate={currentDate} chatId={chatId} />
            <CategoryStats currentDate={currentDate} chatId={chatId} />
          </div>
        )}
      </div>
      
      {/* ğŸ”¥ ç¡®è®¤å¯¹è¯æ¡† */}
      <AlertDialog open={confirmDialog.open} onOpenChange={(open) => setConfirmDialog(prev => ({ ...prev, open }))}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>{confirmDialog.title}</AlertDialogTitle>
            <AlertDialogDescription>{confirmDialog.description}</AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setConfirmDialog(prev => ({ ...prev, open: false }))}>
              å–æ¶ˆ
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                confirmDialog.onConfirm()
                setConfirmDialog(prev => ({ ...prev, open: false }))
              }}
            >
              ç¡®è®¤
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* æ¬¢è¿æŒ‡ä»¤è®¾ç½®å¯¹è¯æ¡† */}
      <Dialog open={welcomeDialog.open} onOpenChange={(open) => {
        if (!open) {
          setWelcomeDialog({ open: false })
        }
      }}>
        <DialogContent className="w-[98vw] max-w-md">
          <DialogHeader>
            <DialogTitle>ğŸ‰ æ¬¢è¿æŒ‡ä»¤è®¾ç½®</DialogTitle>
            <DialogDescription>
              è®¾ç½®æœºå™¨äººæ‹‰ç¾¤æˆåŠŸåè‡ªåŠ¨å‘é€çš„æ¬¢è¿æ¶ˆæ¯
            </DialogDescription>
          </DialogHeader>

          <div className="mt-4">
            <label className="block text-sm font-medium mb-2">æ¬¢è¿æ¶ˆæ¯å†…å®¹</label>
            <textarea
              className="w-full px-3 py-2 border rounded-md text-sm min-h-[100px]"
              placeholder="è¾“å…¥æ¬¢è¿æ¶ˆæ¯å†…å®¹ï¼Œæ”¯æŒ Markdown æ ¼å¼ã€‚å¦‚æœç•™ç©ºåˆ™ä¸å‘é€æ¬¢è¿æ¶ˆæ¯ã€‚"
              value={welcomeDialog.message || ''}
              onChange={(e) => setWelcomeDialog(prev => ({ ...prev, message: e.target.value }))}
              disabled={welcomeDialog.loading || welcomeDialog.saving}
            />
            <p className="text-xs text-slate-500 mt-1">
              ğŸ’¡ æ”¯æŒ Markdown æ ¼å¼ï¼Œå¯ä½¿ç”¨è¡¨æƒ…ç¬¦å·å’Œæ ¼å¼åŒ–æ–‡æœ¬
            </p>
          </div>

          <div className="flex justify-end gap-2 mt-6">
            <button
              className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50"
              onClick={() => setWelcomeDialog({ open: false })}
              disabled={welcomeDialog.saving}
            >
              å–æ¶ˆ
            </button>
            <button
              className="px-3 py-1.5 text-sm border rounded-md hover:bg-slate-50 disabled:opacity-50"
              disabled={welcomeDialog.loading || welcomeDialog.saving}
              onClick={async () => {
                if (!welcomeDialog.botId) return

                setWelcomeDialog(prev => ({ ...prev, saving: true }))
                try {
                  const token = localStorage.getItem('auth_token') || ''
                  const res = await fetch(`/api/bots/${encodeURIComponent(welcomeDialog.botId!)}/welcome-message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'x-auth-token': token },
                    body: JSON.stringify({ message: welcomeDialog.message || null })
                  })

                  if (!res.ok) {
                    const msg = await res.text().catch(() => '')
                    throw new Error(msg || 'ä¿å­˜å¤±è´¥')
                  }

                  toast({ title: 'æˆåŠŸ', description: 'æ¬¢è¿æ¶ˆæ¯è®¾ç½®å·²ä¿å­˜' })
                  setWelcomeDialog({ open: false })
                } catch (e) {
                  toast({ title: 'é”™è¯¯', description: (e as Error).message || 'ä¿å­˜å¤±è´¥', variant: 'destructive' })
                } finally {
                  setWelcomeDialog(prev => ({ ...prev, saving: false }))
                }
              }}
            >
              {welcomeDialog.saving ? 'ä¿å­˜ä¸­...' : 'ä¿å­˜'}
            </button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  )
}

export default function DashboardPage() {
  return (
    <Suspense fallback={<div className="min-h-screen flex items-center justify-center text-slate-500">åŠ è½½ä¸­...</div>}>
      <DashboardPageInner />
    </Suspense>
  )
}
import type React from "react"
import type { Metadata } from "next"
import "./globals.css"
import { Toaster } from "@/components/ui/toaster"
import { ErrorBoundary } from "@/components/error-boundary"

// ä½¿ç”¨ç³»ç»Ÿå­—ä½“ï¼Œé¿å…æ„å»ºæ—¶ä» Google æ‹‰å–å­—ä½“å¯¼è‡´å¤±è´¥

export const metadata: Metadata = {
  title: "æ˜Ÿç©ºè®°è´¦æœºå™¨äººåå°",
  description: "Telegram è®°è´¦æœºå™¨äººåå°ç®¡ç†ç³»ç»Ÿ",
  generator: 'v0.app'
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="zh-CN" className={`antialiased`}>
      <body className="font-sans">
        <ErrorBoundary>
          {children}
        </ErrorBoundary>
        <Toaster />
      </body>
    </html>
  )
}
import { NextRequest } from 'next/server'

export async function POST(req: NextRequest) {
  try {
    const body = await req.json().catch(() => ({})) as { token?: string }
    const token = (body.token || '').trim()
    if (!token) return Response.json({ error: 'Missing token' }, { status: 400 })

    const url = `https://api.telegram.org/bot${encodeURIComponent(token)}/getMe`
    const controller = new AbortController()
    const timeout = setTimeout(() => controller.abort(), 10000)

    const resp = await fetch(url, { method: 'GET', signal: controller.signal })

    clearTimeout(timeout)
    if (!resp.ok) {
      return Response.json({ error: `Telegram getMe failed: ${resp.status}` }, { status: 400 })
    }
    const data = await resp.json()
    if (!data?.ok) {
      return Response.json({ error: 'Telegram getMe returned not ok' }, { status: 400 })
    }
    const me = data.result || {}
    return Response.json({
      id: me.id,
      is_bot: me.is_bot,
      first_name: me.first_name,
      username: me.username,
      can_join_groups: me.can_join_groups,
      can_read_all_group_messages: me.can_read_all_group_messages,
      supports_inline_queries: me.supports_inline_queries,
    })
  } catch (e) {
    console.error(e)
    return Response.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin } from '@/app/api/_auth'

export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šå‡å°‘æŸ¥è¯¢å­—æ®µï¼Œç§»é™¤ featureFlagsï¼ˆå·²åºŸå¼ƒï¼Œæ”¹ç”¨ chatFeatureFlagsï¼‰
    // å‡å°‘ chats å­—æ®µæŸ¥è¯¢æ·±åº¦
    const bots = await prisma.bot.findMany({
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        name: true,
        description: true,
        enabled: true,
        token: true, // ğŸ”¥ æ·»åŠ tokenå­—æ®µï¼Œç”¨äºè·å–çœŸå®åå­—
        createdAt: true,
        updatedAt: true,
        _count: {
          select: { chats: true }
        },
      },
    })
    
    // ğŸ”¥ å°è¯•ä»Telegram APIè·å–æœºå™¨äººçœŸå®åå­—
    const botsWithRealName = await Promise.all(
      bots.map(async (bot: any) => {
        if (!bot.token) {
          return { ...bot, realName: null }
        }
        try {
          const url = `https://api.telegram.org/bot${encodeURIComponent(bot.token)}/getMe`
          const controller = new AbortController()
          const timeout = setTimeout(() => controller.abort(), 5000)
          const resp = await fetch(url, { method: 'GET', signal: controller.signal })
          clearTimeout(timeout)
          
          if (resp.ok) {
            const data = await resp.json()
            if (data?.ok && data?.result) {
              // Telegram APIè¿”å›first_nameå­—æ®µï¼Œè¿™æ˜¯æœºå™¨äººçš„çœŸå®æ˜¾ç¤ºåç§°
              const realName = data.result.first_name || null
              return { ...bot, realName, token: undefined } // ä¸è¿”å›token
            }
          }
        } catch (e) {
          // é™é»˜å¤±è´¥ï¼Œè¿”å›åŸå§‹æ•°æ®
        }
        return { ...bot, realName: null, token: undefined } // ä¸è¿”å›token
      })
    )
    
    return NextResponse.json({ items: botsWithRealName })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json().catch(() => ({})) as {
      name?: string
      description?: string
      token?: string
      enabled?: boolean
    }

    if (!body.name || !body.token) {
      return new Response('Missing name or token', { status: 400 })
    }

    const bot = await prisma.bot.create({
      data: {
        name: body.name,
        description: body.description,
        token: body.token,
        enabled: body.enabled ?? true,
      },
      select: {
        id: true,
        name: true,
        description: true,
        enabled: true,
      },
    })
    return Response.json(bot, { status: 201 })
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}
import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'

type FeatureInput = { feature: string; enabled: boolean }
// ğŸ”¥ ç®€åŒ–åŠŸèƒ½å¼€å…³ï¼šåªä¿ç•™åŸºç¡€è®°è´¦
const DEFAULT_FEATURES: FeatureInput[] = [
  { feature: 'accounting_basic', enabled: true },
]

export async function GET(_: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params
    const flags = await prisma.botFeatureFlag.findMany({
      where: { botId: id },
      select: { feature: true, enabled: true },
      orderBy: { feature: 'asc' },
    })
    if (!flags.length) {
      // è¿”å›é»˜è®¤åŠŸèƒ½é¡¹ï¼ˆä¸å…¥åº“ï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»ä¿å­˜åå†å†™å…¥ï¼‰
      return Response.json({ items: DEFAULT_FEATURES })
    }
    return Response.json({ items: flags })
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}

export async function PUT(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params
    const body = await req.json().catch(() => ({})) as { features?: FeatureInput[] }
    if (!Array.isArray(body.features)) {
      return new Response('Invalid payload', { status: 400 })
    }

    const bot = await prisma.bot.findUnique({ where: { id }, select: { id: true } })
    if (!bot) return new Response('Not Found', { status: 404 })

    await prisma.botFeatureFlag.deleteMany({ where: { botId: id } })
    if (body.features.length) {
      await prisma.botFeatureFlag.createMany({
        data: body.features.map((f) => ({
          botId: id,
          feature: f.feature,
          enabled: Boolean(f.enabled),
        })),
      })
    }

    const flags = await prisma.botFeatureFlag.findMany({
      where: { botId: id },
      select: { feature: true, enabled: true },
      orderBy: { feature: 'asc' },
    })
    return Response.json({ items: flags })
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}
import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin } from '@/app/api/_auth'

// æ›´æ–°åˆ†ç»„
export async function PATCH(req: NextRequest, context: { params: Promise<{ id: string; groupId: string }> }) {
  try {
    const unauth = assertAdmin(req) // ğŸ”¥ æ·»åŠ å®‰å…¨æ£€æŸ¥
    if (unauth) return unauth

    const { id, groupId } = await context.params
    const body = await req.json().catch(() => ({})) as { name?: string; description?: string }

    const existing = await prisma.chatGroup.findFirst({
      where: { id: groupId, botId: id }
    })
    if (!existing) {
      return Response.json({ error: 'åˆ†ç»„ä¸å­˜åœ¨æˆ–ä¸å±äºè¯¥æœºå™¨äºº' }, { status: 404 })
    }

    // å¦‚æœæ›´æ–°åç§°ï¼Œæ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–åˆ†ç»„é‡å
    if (body.name && body.name.trim() !== existing.name) {
      const name = body.name.trim()
      const duplicate = await prisma.chatGroup.findUnique({
        where: { botId_name: { botId: id, name } }
      })
      if (duplicate) {
        return Response.json({ error: 'åˆ†ç»„åç§°å·²å­˜åœ¨' }, { status: 400 })
      }
    }

    const group = await prisma.chatGroup.update({
      where: { id: groupId },
      data: {
        ...(body.name ? { name: body.name.trim() } : {}),
        ...(body.description !== undefined ? { description: body.description?.trim() || null } : {})
      },
      include: {
        _count: {
          select: { chats: true }
        }
      }
    })

    return Response.json({
      id: group.id,
      name: group.name,
      description: group.description,
      createdAt: group.createdAt,
      updatedAt: group.updatedAt,
      chatCount: group._count.chats
    })
  } catch (e) {
    console.error(e)
    return Response.json({ error: 'Server error' }, { status: 500 })
  }
}

// åˆ é™¤åˆ†ç»„
export async function DELETE(req: NextRequest, context: { params: Promise<{ id: string; groupId: string }> }) {
  try {
    const unauth = assertAdmin(req) // ğŸ”¥ æ·»åŠ å®‰å…¨æ£€æŸ¥
    if (unauth) return unauth

    const { id, groupId } = await context.params

    console.log(`[Delete Group] Attempting to delete group ${groupId} for bot ${id}`) // ğŸ”¥ æ·»åŠ æ—¥å¿—

    // éªŒè¯åˆ†ç»„æ˜¯å¦å­˜åœ¨ä¸”å±äºè¯¥æœºå™¨äºº
    const existing = await prisma.chatGroup.findFirst({
      where: { id: groupId, botId: id }
    })

    if (!existing) {
      console.log(`[Delete Group] Not found. GroupId: ${groupId}, BotId: ${id}`)
      return Response.json({ error: 'åˆ†ç»„ä¸å­˜åœ¨æˆ–ä¸å±äºè¯¥æœºå™¨äºº' }, { status: 404 })
    }

    // å¦‚æœ Prisma schema ä¸­ Chat.groupId æ˜¯å¯é€‰çš„ï¼Œåˆ é™¤åˆ†ç»„ä¼šè‡ªåŠ¨ç½®ç©ºï¼ˆå¦‚æœæ²¡è®¾ç½® onDelete è¡Œä¸ºï¼Œæ‰‹åŠ¨ç½®ç©ºæ›´å®‰å…¨ï¼‰
    await prisma.chat.updateMany({
        where: { groupId: groupId },
        data: { groupId: null }
    })
    await prisma.chatGroup.delete({
      where: { id: groupId }
    })

    return Response.json({ ok: true })
  } catch (e: any) {
    console.error('[Delete Group] Error:', e)
    return Response.json({ error: 'Server error' }, { status: 500 })
  }
}

import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin } from '@/app/api/_auth'

// è·å–æ‰€æœ‰åˆ†ç»„
export async function GET(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req) // ğŸ”¥ æ·»åŠ å®‰å…¨æ£€æŸ¥
    if (unauth) return unauth

    const { id } = await context.params
    const groups: any[] = await prisma.chatGroup.findMany({
      where: { botId: id },
      include: {
        _count: {
          select: { chats: true }
        }
      },
      orderBy: { createdAt: 'asc' }
    })
    return Response.json(groups.map((g: any) => ({
      id: g.id,
      name: g.name,
      description: g.description,
      createdAt: g.createdAt,
      updatedAt: g.updatedAt,
      chatCount: g._count.chats
    })))
  } catch (e) {
    console.error(e)
    return Response.json({ error: 'Server error' }, { status: 500 })
  }
}

// åˆ›å»ºåˆ†ç»„
export async function POST(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req) // ğŸ”¥ æ·»åŠ å®‰å…¨æ£€æŸ¥
    if (unauth) return unauth

    const { id } = await context.params
    const body = await req.json().catch(() => ({})) as { name?: string; description?: string }
    const name = (body.name || '').trim()
    if (!name) return Response.json({ error: 'ç¼ºå°‘ name' }, { status: 400 })

    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒååˆ†ç»„
    const existing = await prisma.chatGroup.findUnique({
      where: { botId_name: { botId: id, name } }
    })
    if (existing) {
      return Response.json({ error: 'åˆ†ç»„åç§°å·²å­˜åœ¨' }, { status: 400 })
    }

    const group = await prisma.chatGroup.create({
      data: {
        botId: id,
        name,
        description: body.description?.trim() || null
      }
    })

    return Response.json({
      id: group.id,
      name: group.name,
      description: group.description,
      createdAt: group.createdAt,
      updatedAt: group.updatedAt,
      chatCount: 0
    })
  } catch (e) {
    console.error(e)
    return Response.json({ error: 'Server error' }, { status: 500 })
  }
}

import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'

export async function GET(_: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id: botId } = await context.params

    // è·å–æœºå™¨äººåŠå…¶æ¬¢è¿æ¶ˆæ¯
    const bot = await prisma.bot.findUnique({
      where: { id: botId },
      select: { id: true, name: true, welcomeMessage: true }
    })

    if (!bot) {
      return new Response('Bot not found', { status: 404 })
    }

    return Response.json({
      bot: { id: bot.id, name: bot.name },
      message: bot.welcomeMessage || ''
    })
  } catch (e) {
    console.error('[GET /api/bots/[id]/welcome-message]', e)
    return new Response('Server error', { status: 500 })
  }
}

export async function POST(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id: botId } = await context.params
    const body = await req.json().catch(() => ({}))

    // éªŒè¯æœºå™¨äººæ˜¯å¦å­˜åœ¨
    const bot = await prisma.bot.findUnique({
      where: { id: botId },
      select: { id: true, name: true }
    })

    if (!bot) {
      return new Response('Bot not found', { status: 404 })
    }

    const { message } = body

    // éªŒè¯æ¶ˆæ¯é•¿åº¦
    if (message && message.length > 4000) {
      return new Response('Message too long (max 4000 characters)', { status: 400 })
    }

    // æ›´æ–°æœºå™¨äººçš„æ¬¢è¿æ¶ˆæ¯
    await prisma.bot.update({
      where: { id: botId },
      data: { welcomeMessage: message || null }
    })

    return Response.json({
      success: true,
      message: 'Welcome message setting saved successfully'
    })
  } catch (e) {
    console.error('[POST /api/bots/[id]/welcome-message]', e)
    return new Response('Server error', { status: 500 })
  }
}
import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'

export async function GET(_: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params
    const bot = await prisma.bot.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        description: true,
        enabled: true,
        createdAt: true,
        updatedAt: true,
        featureFlags: { select: { feature: true, enabled: true } },
        chats: {
          select: {
            id: true,
            title: true,
            status: true,
            createdAt: true,
          },
          orderBy: { createdAt: 'desc' },
        },
      },
    })
    if (!bot) return new Response('Not Found', { status: 404 })
    return Response.json(bot)
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}

export async function PATCH(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params
    const body = await req.json().catch(() => ({})) as {
      name?: string
      description?: string | null
      enabled?: boolean
      token?: string | null
    }

    const data: any = {}
    if (typeof body.name === 'string') data.name = body.name
    if (body.description !== undefined) data.description = body.description
    if (typeof body.enabled === 'boolean') data.enabled = body.enabled
    if (body.token !== undefined && body.token !== null) data.token = body.token

    if (Object.keys(data).length === 0) return new Response('Bad Request', { status: 400 })

    const bot = await prisma.bot.update({
      where: { id },
      data,
      select: {
        id: true,
        name: true,
        description: true,
        enabled: true,
        updatedAt: true,
      },
    })
    return Response.json(bot)
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}

export async function DELETE(_: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params
    await prisma.bot.delete({ where: { id } })
    return new Response(null, { status: 204 })
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}
import { NextRequest } from 'next/server'

function ok(data: any) { return Response.json(data) }
function bad(msg = 'Bad Request', code = 400) { return new Response(msg, { status: code }) }
function isAdmin(req: NextRequest) { return (req.headers.get('x-auth-token') || '') === 'authenticated' }

export async function GET(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    if (!isAdmin(req)) return bad('Unauthorized', 401)
    const p = await params
    const botId = p?.id
    if (!botId) return bad('Missing bot id', 400)

    // åŠ¨æ€å¯¼å…¥æœ¬åœ°å‘½ä»¤æ¸…å•ï¼ˆJSæ¨¡å—ï¼‰
    const mod = await import('../../../../../bot/commands-registry.js')
    const commands = Array.isArray((mod as any).commandsRegistry) ? (mod as any).commandsRegistry : []

    // åŸºæœ¬æ¸…æ´—ä¸é™åˆ¶ï¼Œé˜²æ­¢å¼‚å¸¸è†¨èƒ€
    const limited = commands.slice(0, 500).map((c: any) => ({
      type: String(c.type || ''),
      key: String(c.key || ''),
      title: String(c.title || ''),
      desc: String(c.desc || ''),
      examples: Array.isArray(c.examples) ? c.examples.slice(0, 5).map((x: any) => String(x)) : [],
      group: String(c.group || ''),
    }))

    return ok({ commands: limited })
  } catch (e) {
    console.error('[GET /api/bots/[id]/commands]', e)
    return new Response('Server error', { status: 500 })
  }
}
import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'
import { ProxyAgent } from 'undici'

export async function POST(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params
    const body = await req.json().catch(() => ({})) as { 
      message?: string
      chatIds?: string[] // ğŸ”¥ æ–°å¢ï¼šæŒ‡å®šè¦å‘é€çš„ç¾¤ç»„IDåˆ—è¡¨
      groupIds?: string[] // ğŸ”¥ æ–°å¢ï¼šæŒ‡å®šè¦å‘é€çš„åˆ†ç»„IDåˆ—è¡¨
    }
    const message = (body.message || '').trim()
    if (!message) return Response.json({ error: 'ç¼ºå°‘ message' }, { status: 400 })

    const bot = await prisma.bot.findUnique({
      where: { id },
      select: { token: true, enabled: true },
    })
    if (!bot || !bot.token) return Response.json({ error: 'æœªæ‰¾åˆ°æœºå™¨äºº' }, { status: 404 })
    if (!bot.enabled) return Response.json({ error: 'æœºå™¨äººæœªå¯ç”¨ï¼Œæ— æ³•ç¾¤å‘' }, { status: 400 })

    // ğŸ”¥ æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const where: any = {
      botId: id,
      status: 'APPROVED'
    }

    // ğŸ”¥ å¦‚æœæŒ‡å®šäº† chatIdsï¼Œåªå‘é€åˆ°è¿™äº›ç¾¤ç»„
    if (body.chatIds && body.chatIds.length > 0) {
      where.id = { in: body.chatIds }
    }
    // ğŸ”¥ å¦‚æœæŒ‡å®šäº† groupIdsï¼Œå‘é€åˆ°è¿™äº›åˆ†ç»„çš„æ‰€æœ‰ç¾¤ç»„
    else if (body.groupIds && body.groupIds.length > 0) {
      where.groupId = { in: body.groupIds }
    }

    // åªè·å–ç¾¤ç»„ï¼ˆIDä¸ºè´Ÿæ•°ï¼‰ï¼Œæ’é™¤ç§èŠç”¨æˆ·ï¼ˆIDä¸ºæ­£æ•°ï¼‰
    const chats = await prisma.chat.findMany({
      where,
      select: { id: true },
    })
    
    // è¿‡æ»¤å‡ºç¾¤ç»„ï¼ˆID ä»¥ - å¼€å¤´ï¼Œå³è´Ÿæ•°ï¼‰
    const groupChats = chats.filter((chat: any) => chat.id.startsWith('-'))
    
    if (!groupChats.length) return Response.json({ error: 'æš‚æ— å·²å…è®¸ä½¿ç”¨çš„ç¾¤ç»„' }, { status: 400 })

    const url = `https://api.telegram.org/bot${encodeURIComponent(bot.token)}/sendMessage`
    const proxyUrl = (process.env.PROXY_URL || '').trim()
    const dispatcher = proxyUrl ? new ProxyAgent(proxyUrl) : undefined

    let sent = 0
    // å…ˆè¿‡æ»¤æ‰æœºå™¨äººä¸åœ¨ç¾¤å†…çš„ chatï¼ˆé¿å…æŠ¥é”™ï¼‰
    const checkUrlBase = `https://api.telegram.org/bot${encodeURIComponent(bot.token)}/getChatMember`
    const validChats: { id: string }[] = []
    for (const chat of groupChats) {
      try {
        const checkUrl = `${checkUrlBase}?chat_id=${encodeURIComponent(chat.id)}&user_id=${encodeURIComponent(''+0)}`
        // ä¸Šé¢åªæ˜¯å ä½ï¼Œå®é™…åº”æŸ¥è¯¢æœºå™¨äººè‡ªèº«æ˜¯å¦åœ¨ç¾¤å†…ï¼šTelegram ä¸å…è®¸ getChatMember æŸ¥è¯¢è‡ªå·±ï¼Œ
        // å› æ­¤æ”¹ç”¨ getChatAdministrators/æˆ–å°è¯•å‘é€å‰å…ˆ getChatï¼ˆè‹¥è¢«è¸¢ä¼šæŠ¥é”™ï¼‰ã€‚è¿™é‡Œé‡‡ç”¨ getChat æ–¹å¼ã€‚
        const getChatUrl = `https://api.telegram.org/bot${encodeURIComponent(bot.token)}/getChat?chat_id=${encodeURIComponent(chat.id)}`
        const resp = await fetch(getChatUrl, { method: 'GET', ...(dispatcher ? { dispatcher } : {}) } as any)
        if (!resp.ok) throw new Error('getChat failed')
        const j = await resp.json().catch(() => null)
        if (j && j.ok) {
          validChats.push(chat)
        }
      } catch {}
    }

    for (const chat of validChats) {
      try {
        const payload = { chat_id: chat.id, text: message }
        const init: any = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          ...(dispatcher ? { dispatcher } : {}),
        }
        const resp = await fetch(url, init)
        if (resp.ok) {
          sent += 1
        }
      } catch (e) {
        console.error('broadcast sendMessage failed', e)
      }
    }

    return Response.json({ ok: true, sent, total: groupChats.length })
  } catch (e) {
    console.error(e)
    return Response.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'audit_logs_get', 60, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })

    const { searchParams } = new URL(req.url)
    const page = Math.max(1, Number(searchParams.get('page') || '1'))
    const size = Math.min(100, Math.max(1, Number(searchParams.get('size') || '20')))
    const username = (searchParams.get('username') || '').trim()
    const ip = (searchParams.get('ip') || '').trim()
    const action = (searchParams.get('action') || '').trim()
    const from = searchParams.get('from') ? new Date(searchParams.get('from') as string) : null
    const to = searchParams.get('to') ? new Date(searchParams.get('to') as string) : null

    // ensure table exists (DDL)
    const DDL = `CREATE TABLE IF NOT EXISTS AdminAuditLog (
      id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
      username TEXT, action TEXT, target TEXT, ip TEXT,
      createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
    );`
    try { await prisma.$executeRawUnsafe(DDL) } catch {}

    const where: any = {}
    if (username) where.username = username
    if (action) where.action = action
    if (ip) where.ip = ip
    if (from || to) {
      where.createdAt = {}
      if (from) (where.createdAt as any).gte = from
      if (to) (where.createdAt as any).lte = to
    }

    const [total, items] = await Promise.all([
      prisma.adminAuditLog.count({ where } as any).catch(async () => {
        // fallback for when Prisma model not generated; use raw
        const clauses: string[] = []
        const params: any[] = []
        if (username) { clauses.push('username = ?'); params.push(username) }
        if (action) { clauses.push('action = ?'); params.push(action) }
        if (ip) { clauses.push('ip = ?'); params.push(ip) }
        if (from) { clauses.push('createdAt >= ?'); params.push(from) }
        if (to) { clauses.push('createdAt <= ?'); params.push(to) }
        const whereSql = clauses.length ? ('WHERE ' + clauses.join(' AND ')) : ''
        const rows: any = await prisma.$queryRawUnsafe(`SELECT COUNT(1) as c FROM AdminAuditLog ${whereSql}`, ...params)
        return Array.isArray(rows) ? Number(rows[0]?.c || 0) : 0
      }),
      prisma.adminAuditLog.findMany({
        where
      } as any).catch(async () => {
        const clauses: string[] = []
        const params: any[] = []
        if (username) { clauses.push('username = ?'); params.push(username) }
        if (action) { clauses.push('action = ?'); params.push(action) }
        if (ip) { clauses.push('ip = ?'); params.push(ip) }
        if (from) { clauses.push('createdAt >= ?'); params.push(from) }
        if (to) { clauses.push('createdAt <= ?'); params.push(to) }
        const whereSql = clauses.length ? ('WHERE ' + clauses.join(' AND ')) : ''
        params.push(size)
        params.push((page - 1) * size)
        const rows: any = await prisma.$queryRawUnsafe(
          `SELECT id, username, action, target, ip, createdAt FROM AdminAuditLog ${whereSql} ORDER BY createdAt DESC LIMIT ? OFFSET ?`,
          ...params
        )
        return rows
      })
    ])

    return NextResponse.json({ page, size, total, items })
  } catch (e) {
    console.error('[audit-logs][GET]', e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import crypto from 'node:crypto'
import { prisma } from '@/lib/db'

const COOKIE_NAME = 'adm_sess'
const MAX_AGE = 60 * 60 * 8 // 8h

function getSecret() {
  const base = process.env.ADMIN_SESSION_SECRET || process.env.ADMIN_PWD_SALT || 'session_secret_fallback'
  const rotate = process.env.ADMIN_SESSION_ROTATE || ''
  return `${base}:${rotate}`
}

function sign(data: string) {
  return crypto.createHmac('sha256', getSecret()).update(data).digest('hex')
}

export function createSession(username: string, ver: number = 0) {
  const payload = JSON.stringify({ u: username, ver, iat: Date.now(), exp: Date.now() + MAX_AGE * 1000 })
  const b64 = Buffer.from(payload).toString('base64url')
  const sig = sign(b64)
  return `${b64}.${sig}`
}

export function verifySession(raw: string | null) {
  if (!raw) return null
  const [b64, sig] = raw.split('.')
  if (!b64 || !sig) return null
  if (sign(b64) !== sig) return null
  try {
    const json = JSON.parse(Buffer.from(b64, 'base64url').toString('utf8'))
    if (!json || !json.exp || Date.now() > json.exp) return null
    return json
  } catch {
    return null
  }
}

export function setSessionCookie(res: NextResponse, username: string, ver: number = 0) {
  const v = createSession(username, ver)

  // ğŸ”¥ å®‰å…¨å¢å¼ºï¼šå¼ºåˆ¶HTTPSç¯å¢ƒä¸‹çš„Cookieå®‰å…¨è®¾ç½®
  // ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä½¿ç”¨HTTPSï¼Œå¦åˆ™Cookieä¸å®‰å…¨
  const isHttps = process.env.NODE_ENV === 'production' ||
                  process.env.FORCE_HTTPS === 'true' ||
                  (typeof window !== 'undefined' && window.location?.protocol === 'https:')

  // ğŸ”¥ å®‰å…¨å¢å¼ºï¼šå¼ºåˆ¶SameSite=Strictï¼Œé˜²æ­¢CSRFæ”»å‡»
  // åªæœ‰åœ¨HTTPSç¯å¢ƒä¸‹æ‰è®¾ç½®Secureæ ‡å¿—
  res.cookies.set({
    name: COOKIE_NAME,
    value: v,
    httpOnly: true, // é˜²æ­¢JSè¯»å–
    sameSite: 'strict', // ğŸ”¥ æ”¹ä¸ºStrictï¼Œé˜²æ­¢CSRF
    secure: isHttps, // ğŸ”¥ åªæœ‰HTTPSæ—¶æ‰è®¾ç½®Secure
    path: '/',
    maxAge: MAX_AGE,
  })

  // ğŸ”¥ å®‰å…¨å¢å¼ºï¼šå¦‚æœåœ¨HTTPç¯å¢ƒä¸‹ï¼Œè®°å½•è­¦å‘Š
  if (!isHttps && process.env.NODE_ENV === 'production') {
    console.warn('âš ï¸ å®‰å…¨è­¦å‘Šï¼šç”Ÿäº§ç¯å¢ƒä½¿ç”¨HTTPï¼ŒCookieå¯èƒ½è¢«ä¸­é—´äººæ”»å‡»åŠ«æŒï¼è¯·é…ç½®HTTPSã€‚')
  }
}

export function getSession(req: NextRequest) {
  const raw = req.cookies.get(COOKIE_NAME)?.value || null
  return verifySession(raw)
}

export function requireAdmin(req: NextRequest) {
  const s = getSession(req)
  if (!s) return false
  return !!s.u
}

export function assertAdmin(req: NextRequest) {
  if (!requireAdmin(req)) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  if (req.method !== 'GET' && req.method !== 'HEAD') {
    const origin = req.headers.get('origin')
    const host = req.headers.get('host')
    if (origin && host) {
      try {
        const u = new URL(origin)
        if (u.host !== host) {
          return NextResponse.json({ error: 'Bad Origin' }, { status: 403 })
        }
      } catch {}
    }
  }
  return null
}

export async function rotateAllSessionsSecret() {
  const salt = crypto.randomBytes(16).toString('hex')
  process.env.ADMIN_SESSION_ROTATE = salt
  try {
    await prisma.globalConfig.upsert({
      where: { key: 'admin_session_rotate' },
      create: { key: 'admin_session_rotate', value: salt, description: 'Session rotation salt' },
      update: { value: salt, updatedAt: new Date(), updatedBy: 'system' }
    })
  } catch {}
}

// ===== Per-user session versioning (invalidate other sessions) =====
const VER_CACHE = new Map<string, { v: number; exp: number }>()
async function getUserSessionVersion(username: string): Promise<number> {
  const now = Date.now()
  const hit = VER_CACHE.get(username)
  if (hit && hit.exp > now) return hit.v
  try {
    const row = await prisma.globalConfig.findUnique({ where: { key: `admin_session_ver:${username}` } })
    const v = row?.value ? Number(row.value) || 0 : 0
    VER_CACHE.set(username, { v, exp: now + 5 * 60 * 1000 })
    return v
  } catch {
    return 0
  }
}

export async function bumpUserSessionVersion(username: string) {
  try {
    const cur = await getUserSessionVersion(username)
    const next = cur + 1
    await prisma.globalConfig.upsert({
      where: { key: `admin_session_ver:${username}` },
      create: { key: `admin_session_ver:${username}`, value: String(next), description: 'Per-user session version', updatedBy: username },
      update: { value: String(next), updatedAt: new Date(), updatedBy: username },
    })
    VER_CACHE.set(username, { v: next, exp: Date.now() + 5 * 60 * 1000 })
  } catch {}
}

export async function assertAdminAsync(req: NextRequest) {
  const sess = getSession(req)
  if (!sess || !sess.u) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  // Version check
  const curVer = await getUserSessionVersion(String(sess.u))
  if (Number(sess.ver || 0) !== curVer) {
    return NextResponse.json({ error: 'Session expired' }, { status: 401 })
  }
  // ç®€å•çš„ same-origin/Origin æ ¡éªŒï¼ˆä»…å¯¹ä¿®æ”¹ç±»è¯·æ±‚ï¼‰
  if (req.method !== 'GET' && req.method !== 'HEAD') {
    const origin = req.headers.get('origin')
    const host = req.headers.get('host')
    if (origin && host) {
      try {
        const u = new URL(origin)
        if (u.host !== host) {
          return NextResponse.json({ error: 'Bad Origin' }, { status: 403 })
        }
      } catch {}
    }
  }
  return null
}

export async function auditAdmin(username: string, action: string, ip: string, target?: string) {
  const DDL = `CREATE TABLE IF NOT EXISTS AdminAuditLog (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    username TEXT, action TEXT, target TEXT, ip TEXT,
    createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
  );`
  try { await prisma.$executeRawUnsafe(DDL) } catch {}
  try {
    await prisma.$executeRaw`INSERT INTO AdminAuditLog (username, action, target, ip) VALUES (${username}, ${action}, ${target || null}, ${ip || ''})`
  } catch {}
}

// ===== Simple in-memory rate limiter (per-process) =====
type Bucket = { count: number; resetAt: number }
const buckets = new Map<string, Bucket>()

export function getClientIp(req: NextRequest) {
  const xf = req.headers.get('x-forwarded-for')
  if (xf) return xf.split(',')[0].trim()
  const xr = req.headers.get('x-real-ip')
  if (xr) return xr.trim()
  try {
    const remote = (req as any)?.ip || ''
    if (remote) return String(remote)
  } catch {}
  return ''
}

export function rateLimit(req: NextRequest, key: string, limit: number, windowMs: number) {
  const ip = getClientIp(req)
  const k = `${key}:${ip}`
  const now = Date.now()
  const b = buckets.get(k)
  if (!b || now > b.resetAt) {
    buckets.set(k, { count: 1, resetAt: now + windowMs })
    return { ok: true }
  }
  if (b.count >= limit) return { ok: false, retryAfter: Math.ceil((b.resetAt - now) / 1000) }
  b.count++
  return { ok: true }
}
import { NextRequest, NextResponse } from 'next/server'

const COOKIE_NAME = 'adm_sess'

export async function POST(_req: NextRequest) {
  const res = NextResponse.json({ ok: true })
  res.cookies.set({ name: COOKIE_NAME, value: '', httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production', path: '/', maxAge: 0 })
  return res
}
import { NextRequest, NextResponse } from 'next/server'
import { getSession, bumpUserSessionVersion, getClientIp, auditAdmin } from '@/app/api/_auth'

const COOKIE_NAME = 'adm_sess'

export async function POST(req: NextRequest) {
  const s = getSession(req)
  if (!s?.u) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  try {
    await bumpUserSessionVersion(String(s.u))
    await auditAdmin(String(s.u), 'logout_all', getClientIp(req), undefined)
  } catch {}
  const res = NextResponse.json({ ok: true })
  res.cookies.set({ name: COOKIE_NAME, value: '', httpOnly: true, sameSite: 'lax', secure: process.env.NODE_ENV === 'production', path: '/', maxAge: 0 })
  return res
}
import { NextRequest, NextResponse } from 'next/server'
import { assertAdminAsync, getSession } from '@/app/api/_auth'

export async function GET(req: NextRequest) {
  const unauth = await assertAdminAsync(req)
  if (unauth) return unauth
  const s = getSession(req)
  return NextResponse.json({ authenticated: true, username: s?.u })
}
export const runtime = 'nodejs'
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import crypto from 'node:crypto'
import fs from 'node:fs'
import path from 'node:path'
import { assertAdmin, rateLimit, bumpUserSessionVersion, getClientIp, auditAdmin } from '@/app/api/_auth'

const TABLE_SQL = `CREATE TABLE IF NOT EXISTS Admin (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  username TEXT UNIQUE,
  passwordHash TEXT,
  createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
);`

function hashPassword(pwd: string) {
  const salt = process.env.ADMIN_PWD_SALT || 'tgbot_salt_v1'
  return crypto.createHash('sha256').update(`${salt}:${pwd}`).digest('hex')
}

export async function POST(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'change_pwd', 5, 5 * 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many attempts. Retry after ${rl.retryAfter}s` }, { status: 429 })
    try {
      const dbUrl = process.env.DATABASE_URL || ''
      if (dbUrl.startsWith('file:')) {
        let p = dbUrl.slice(5)
        if (!p) throw new Error('Empty sqlite path')
        if (!p.startsWith('/')) p = path.resolve(process.cwd(), p)
        const dir = path.dirname(p)
        if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true })
        if (!fs.existsSync(p)) fs.closeSync(fs.openSync(p, 'a'))
      }
    } catch {}
    const body = await req.json().catch(() => ({})) as { username?: string; oldPassword?: string; newPassword?: string }
    const username = (body.username || '').trim()
    const oldPassword = (body.oldPassword || '').trim()
    const newPassword = (body.newPassword || '').trim()

    if (!username || !oldPassword || !newPassword) return NextResponse.json({ error: 'Bad Request' }, { status: 400 })
    if (newPassword.length < 6) return NextResponse.json({ error: 'å¯†ç è‡³å°‘ 6 ä½' }, { status: 400 })

    // ensure table exists (use Unsafe for static DDL string)
    await prisma.$executeRawUnsafe(TABLE_SQL)

    const rows = await prisma.$queryRaw`SELECT id, username, passwordHash FROM Admin WHERE username = ${username} LIMIT 1` as any
    const user = Array.isArray(rows) ? rows[0] : null
    if (!user) return NextResponse.json({ error: 'ç”¨æˆ·ä¸å­˜åœ¨' }, { status: 404 })

    const ok = user.passwordHash === hashPassword(oldPassword)
    if (!ok) {
      try { await auditAdmin(username, 'change_password_failed', getClientIp(req), undefined) } catch {}
      return NextResponse.json({ error: 'åŸå¯†ç ä¸æ­£ç¡®' }, { status: 401 })
    }

    await prisma.$executeRaw`UPDATE Admin SET passwordHash = ${hashPassword(newPassword)}, updatedAt = CURRENT_TIMESTAMP WHERE id = ${user.id}`
    try {
      await bumpUserSessionVersion(username)
      await auditAdmin(username, 'change_password_success', getClientIp(req), undefined)
    } catch {}
    return new NextResponse(null, { status: 204 })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
export const runtime = 'nodejs'
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import crypto from 'node:crypto'
import fs from 'node:fs'
import path from 'node:path'
import { rateLimit, setSessionCookie, getClientIp, auditAdmin } from '@/app/api/_auth'

const TABLE_SQL = `CREATE TABLE IF NOT EXISTS Admin (
  id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
  username TEXT UNIQUE,
  passwordHash TEXT,
  createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP
);`

function hashPassword(pwd: string) {
  const salt = process.env.ADMIN_PWD_SALT || 'tgbot_salt_v1'
  return crypto.createHash('sha256').update(`${salt}:${pwd}`).digest('hex')
}

export async function POST(req: NextRequest) {
  try {
    // ç®€å•IPçº§é€Ÿç‡é™åˆ¶ï¼šæ¯5åˆ†é’Ÿæœ€å¤š10æ¬¡
    const rl = rateLimit(req, 'login', 10, 5 * 60 * 1000)
    if (!rl.ok) {
      return NextResponse.json({ error: `Too many attempts. Retry after ${rl.retryAfter}s` }, { status: 429 })
    }
    try {
      const dbUrl = process.env.DATABASE_URL || ''
      if (dbUrl.startsWith('file:')) {
        let p = dbUrl.slice(5)
        if (!p) throw new Error('Empty sqlite path')
        if (!p.startsWith('/')) p = path.resolve(process.cwd(), p)
        const dir = path.dirname(p)
        if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true })
        if (!fs.existsSync(p)) fs.closeSync(fs.openSync(p, 'a'))
      }
    } catch {}
    const body = await req.json().catch(() => ({})) as { username?: string; password?: string }
    const username = (body.username || '').trim()
    const password = (body.password || '').trim()
    if (!username || !password) return NextResponse.json({ error: 'Bad Request' }, { status: 400 })

    // ensure table exists (use Unsafe for static DDL string)
    await prisma.$executeRawUnsafe(TABLE_SQL)

    // persisted attempts table
    const ATTEMPT_DDL = `CREATE TABLE IF NOT EXISTS AdminLoginAttempt (
      id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
      username TEXT, ip TEXT, success INTEGER,
      createdAt DATETIME DEFAULT CURRENT_TIMESTAMP
    );`
    try { await prisma.$executeRawUnsafe(ATTEMPT_DDL) } catch {}


    // throttle by recent failures
    const ip = getClientIp(req)
    const winMin = Math.max(1, Number(process.env.ADMIN_LOGIN_FAIL_WINDOW_MIN || '15'))
    const limit = Math.max(1, Number(process.env.ADMIN_LOGIN_FAIL_LIMIT || '20'))
    const fifteenMinAgo = new Date(Date.now() - winMin * 60 * 1000)
    const recentFails: any = await prisma.$queryRaw`SELECT COUNT(1) as c FROM AdminLoginAttempt WHERE success = 0 AND (username = ${username} OR ip = ${ip}) AND createdAt >= ${fifteenMinAgo}`
    const failCount = Array.isArray(recentFails) ? Number(recentFails[0]?.c || 0) : 0
    if (failCount > limit) {
      return NextResponse.json({ error: 'Too many attempts, please try later.' }, { status: 429 })
    }


    // bootstrap default admin if none
    const rows = await prisma.$queryRaw`SELECT id, username, passwordHash FROM Admin LIMIT 1`
    if (!rows || rows.length === 0) {
      const defaultHash = hashPassword('admin123')
      // æä¾›æ˜¾å¼ idï¼Œå…¼å®¹å†å²ä¸Š Admin.id æ— é»˜è®¤å€¼çš„æƒ…å†µ
      await prisma.$executeRaw`INSERT INTO Admin (id, username, passwordHash) VALUES (lower(hex(randomblob(16))), ${'admin'}, ${defaultHash})`
    }

    const list = await prisma.$queryRaw`SELECT id, username, passwordHash FROM Admin WHERE username = ${username} LIMIT 1` as any
    const user = Array.isArray(list) ? list[0] : null
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

    const ok = user.passwordHash === hashPassword(password)
    try { await prisma.$executeRaw`INSERT INTO AdminLoginAttempt (username, ip, success) VALUES (${username}, ${ip}, ${ok ? 1 : 0})` } catch {}
    try { await auditAdmin(username, ok ? 'login_success' : 'login_failure', ip, undefined) } catch {}
    if (!ok) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

    // per-user session version
    let ver = 0
    try {
      const verRow: any = await prisma.$queryRaw`SELECT value FROM GlobalConfig WHERE key = ${'admin_session_ver:' + username} LIMIT 1`
      if (Array.isArray(verRow) && verRow[0]?.value != null) {
        const v = Number(verRow[0].value)
        if (!Number.isNaN(v)) ver = v
      }
    } catch {}

    const res = NextResponse.json({ ok: true, username })
    setSessionCookie(res, username, ver)
    return res
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import fs from 'node:fs/promises'
import path from 'node:path'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

export async function POST(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'upload', 3, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many uploads. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const form = await req.formData()
    const file = form.get('file') as File | null
    if (!file) return NextResponse.json({ error: 'file is required' }, { status: 400 })

    // Size limit: 3MB
    const MAX_SIZE = 3 * 1024 * 1024
    const arrayBuffer = await file.arrayBuffer()
    if (arrayBuffer.byteLength > MAX_SIZE) {
      return NextResponse.json({ error: 'File too large (max 3MB)' }, { status: 413 })
    }
    const buffer = Buffer.from(arrayBuffer)

    // MIME & extension whitelist
    const allowedExt = new Set(['.png', '.jpg', '.jpeg', '.gif', '.webp'])
    const ext = path.extname(file.name || '').toLowerCase()
    const mime = (file.type || '').toLowerCase()
    if (!allowedExt.has(ext) || !mime.startsWith('image/')) {
      return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 })
    }

    // Basic magic number check
    const sig = buffer.subarray(0, 12)
    const isPng = sig[0] === 0x89 && sig[1] === 0x50 && sig[2] === 0x4e && sig[3] === 0x47
    const isJpeg = sig[0] === 0xff && sig[1] === 0xd8 && sig[2] === 0xff
    const isGif = sig[0] === 0x47 && sig[1] === 0x49 && sig[2] === 0x46 // GIF
    const isWebp = sig.toString('utf8', 0, 4) === 'RIFF' && sig.toString('utf8', 8, 12) === 'WEBP'
    if (!(isPng || isJpeg || isGif || isWebp)) {
      return NextResponse.json({ error: 'Invalid image signature' }, { status: 400 })
    }

    const uploadsDir = path.join(process.cwd(), 'public', 'uploads')
    await fs.mkdir(uploadsDir, { recursive: true })

    const ts = Date.now()
    const safeName = (file.name || 'image').replace(/[^a-zA-Z0-9._-]/g, '_')
    const filename = `${ts}_${Math.random().toString(36).slice(2,8)}_${safeName}`
    const filepath = path.join(uploadsDir, filename)

    await fs.writeFile(filepath, buffer)

    const url = `/uploads/${filename}`
    return NextResponse.json({ url })
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || 'Upload failed' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin } from '@/app/api/_auth'

function parseDate(s: string | null) {
  if (!s) return null
  const d = new Date(s)
  return isNaN(d.getTime()) ? null : d
}

export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const { searchParams } = new URL(req.url)
    const chatId = searchParams.get('chatId') || undefined
    const type = (searchParams.get('type') || 'all').toLowerCase() as 'all'|'income'|'dispatch'
    const from = parseDate(searchParams.get('from'))
    const to = parseDate(searchParams.get('to'))
    const page = Math.max(1, Number(searchParams.get('page') || '1'))
    const size = Math.min(100, Math.max(1, Number(searchParams.get('size') || '20')))

    // ğŸ”¥ ä» BillItem è¡¨è·å–æ•°æ®ï¼ˆæ–°çš„å­˜å‚¨æ–¹å¼ï¼‰
    let chatIdFinal = chatId
    if (!chatIdFinal) {
      // è·å–æœ€è¿‘æœ‰æ´»åŠ¨çš„ç¾¤ç»„
      const latestBill = await prisma.bill.findFirst({ 
        orderBy: { openedAt: 'desc' },
        select: { chatId: true }
      })
      chatIdFinal = latestBill?.chatId || undefined
    }

    // æ„å»ºæ—¥æœŸè¿‡æ»¤ï¼šé€šè¿‡ bill çš„ openedAt æ¥è¿‡æ»¤
    const billWhere: any = {}
    if (chatIdFinal) billWhere.chatId = chatIdFinal
    if (from || to) {
      billWhere.openedAt = {}
      if (from) billWhere.openedAt.gte = from
      if (to) {
        const toEnd = new Date(to)
        toEnd.setHours(23, 59, 59, 999)
        billWhere.openedAt.lte = toEnd
      }
    }

    // è·å–ç¬¦åˆæ¡ä»¶çš„è´¦å•
    const bills = await prisma.bill.findMany({
      where: billWhere,
      select: { id: true }
    })
    const billIds = bills.map((b: any) => b.id)

    if (billIds.length === 0) {
      return NextResponse.json({ page, size, total: 0, items: [] })
    }

    // æ„å»º BillItem æŸ¥è¯¢æ¡ä»¶
    const itemWhere: any = { billId: { in: billIds } }
    if (type === 'income') {
      itemWhere.type = 'INCOME'
    } else if (type === 'dispatch') {
      itemWhere.type = 'DISPATCH'
    }

    // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šè·å–è®°å½•æ—¶åªé€‰æ‹©å¿…è¦å­—æ®µï¼Œå‡å°‘æ•°æ®ä¼ è¾“é‡
    const [total, items] = await Promise.all([
      prisma.billItem.count({ where: itemWhere }),
      prisma.billItem.findMany({
        where: itemWhere,
        select: {
          id: true,
          type: true,
          amount: true,
          rate: true,
          usdt: true,
          feeRate: true,
          remark: true,
          replier: true,
          operator: true,
          displayName: true,
          userId: true,
          messageId: true,
          createdAt: true,
        },
        orderBy: { createdAt: 'desc' },
        skip: (page - 1) * size,
        take: size,
      })
    ])

    // æ ¼å¼åŒ–æ•°æ®
    const formattedItems = items.map((item: any) => {
      if (item.type === 'INCOME') {
        return {
          id: item.id,
          type: 'income' as const,
          amount: Number(item.amount),
          usdt: item.usdt ? Number(item.usdt) : null,
          rate: item.rate ? Number(item.rate) : null,
          feeRate: item.feeRate ? Number(item.feeRate) : null, // ğŸ”¥ æ·»åŠ è´¹ç‡
          remark: item.remark || null, // ğŸ”¥ æ·»åŠ å¤‡æ³¨
          replier: item.replier || null,
          operator: item.operator || null,
          createdAt: item.createdAt,
        }
      } else {
        return {
          id: item.id,
          type: 'dispatch' as const,
          amount: Number(item.amount),
          usdt: item.usdt ? Number(item.usdt) : null,
          rate: item.rate ? Number(item.rate) : null,
          feeRate: item.feeRate ? Number(item.feeRate) : null, // ğŸ”¥ æ·»åŠ è´¹ç‡
          remark: item.remark || null, // ğŸ”¥ æ·»åŠ å¤‡æ³¨
          replier: item.replier || null,
          operator: item.operator || null,
          createdAt: item.createdAt,
        }
      }
    })

    return NextResponse.json({ page, size, total, items: formattedItems })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin } from '@/app/api/_auth'

function ok(data: any) {
  return NextResponse.json(data)
}
function bad(msg = 'Bad Request', code = 400) {
  return NextResponse.json({ error: msg }, { status: code })
}

const DEFAULT_VALUE = { exact_map: {}, prefix_map: {} }

export async function GET() {
  try {
    const row = await prisma.globalConfig.findUnique({ where: { key: 'command_alias_map' } })
    if (!row) return ok(DEFAULT_VALUE)
    try {
      const obj = JSON.parse(row.value || '{}')
      const exact_map = obj && typeof obj.exact_map === 'object' ? obj.exact_map : {}
      const prefix_map = obj && typeof obj.prefix_map === 'object' ? obj.prefix_map : {}
      return ok({ exact_map, prefix_map })
    } catch {
      return ok(DEFAULT_VALUE)
    }
  } catch (e) {
    console.error('[GET /api/global-config/commands]', e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

export async function POST(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const body = await req.json().catch(() => ({})) as any
    const exact_map = body?.exact_map
    const prefix_map = body?.prefix_map

    if (exact_map && typeof exact_map !== 'object') return bad('exact_map must be object')
    if (prefix_map && typeof prefix_map !== 'object') return bad('prefix_map must be object')

    // ç®€å•é…é¢é™åˆ¶ï¼Œé¿å…è¶…é•¿é…ç½®
    const sanitize = (obj: any) => {
      const out: Record<string, string> = {}
      if (!obj || typeof obj !== 'object') return out
      const entries = Object.entries(obj).slice(0, 200)
      for (const [k, v] of entries) {
        const kk = String(k || '').trim()
        const vv = String(v || '').trim()
        if (!kk || !vv) continue
        if (kk.length > 100 || vv.length > 100) continue
        out[kk] = vv
      }
      return out
    }

    const valueObj = {
      exact_map: sanitize(exact_map || {}),
      prefix_map: sanitize(prefix_map || {}),
    }

    await prisma.globalConfig.upsert({
      where: { key: 'command_alias_map' },
      create: { key: 'command_alias_map', value: JSON.stringify(valueObj), description: 'Global command alias map', updatedBy: 'admin' },
      update: { value: JSON.stringify(valueObj), description: 'Global command alias map', updatedBy: 'admin' },
    })

    return ok(valueObj)
  } catch (e) {
    console.error('[POST /api/global-config/commands]', e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin } from '@/app/api/_auth'

export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const { searchParams } = new URL(req.url)
    const chatId = searchParams.get('chatId') || undefined
    const page = Math.max(1, Number(searchParams.get('page') || '1'))
    const size = Math.min(100, Math.max(1, Number(searchParams.get('size') || '20')))

    const where = chatId ? { chatId } : {}
    const [total, bills] = await Promise.all([
      prisma.bill.count({ where }),
      prisma.bill.findMany({
        where,
        // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šåªé€‰æ‹©å¿…è¦çš„å­—æ®µ
        select: {
          id: true,
          chatId: true,
          status: true,
          openedAt: true,
          closedAt: true,
          savedAt: true,
        },
        orderBy: { savedAt: 'desc' },
        skip: (page - 1) * size,
        take: size,
      }),
    ])

    return NextResponse.json({
      page,
      size,
      total,
      items: bills,
    })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'

export async function GET(req: NextRequest, { params }: { params: { id: string } }) {
  try {
    const id = params.id
    const bill = await prisma.bill.findUnique({ where: { id } })
    if (!bill) return new Response('Not Found', { status: 404 })
    
    // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šåªé€‰æ‹©å¿…è¦çš„å­—æ®µ
    const items = await prisma.billItem.findMany({
      where: { billId: id },
      select: {
        id: true,
        type: true,
        amount: true,
        rate: true,
        usdt: true,
        feeRate: true, // ğŸ”¥ æ·»åŠ è´¹ç‡å­—æ®µ
        remark: true, // ğŸ”¥ æ·»åŠ å¤‡æ³¨å­—æ®µ
        replier: true,
        operator: true,
        createdAt: true,
      },
      orderBy: { createdAt: 'asc' }
    })

    // è·å–ç¾¤ç»„è®¾ç½®ï¼ˆåˆ¤æ–­æ˜¯å¦ç´¯è®¡æ¨¡å¼ï¼‰
    const settings = await prisma.setting.findUnique({
      where: { chatId: bill.chatId },
      select: {
        accountingMode: true,
        feePercent: true,
        fixedRate: true,
        realtimeRate: true,
        dailyCutoffHour: true, // ğŸ”¥ æ·»åŠ æ—¥åˆ‡æ—¶é—´å­—æ®µ
      }
    })

    // æ±‡æ€»ï¼ˆğŸ”¥ ä¿®å¤ï¼šæ”¯æŒè´Ÿæ•°å…¥è´¦ï¼‰
    const incomes = items.filter((i: any) => i.type === 'INCOME')
    const dispatches = items.filter((i: any) => i.type === 'DISPATCH')
    const totalIncome = incomes.reduce((s: number, i: any) => s + Number(i.amount || 0), 0)
    const totalDispatch = dispatches.reduce((s: number, d: any) => s + Number(d.amount || 0), 0)
    
    // è®¡ç®—æ±‡ç‡å’ŒUSDT
    const feePercent = settings?.feePercent ?? 0
    const fixedRate = settings?.fixedRate
    const realtimeRate = settings?.realtimeRate
    let effectiveRate = fixedRate ?? realtimeRate ?? 0
    
    if (!effectiveRate && incomes.length > 0) {
      // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šä»åå¾€å‰æŸ¥æ‰¾ï¼Œä¸éœ€è¦reverseæ•´ä¸ªæ•°ç»„
      for (let i = incomes.length - 1; i >= 0; i--) {
        if (incomes[i].rate && Number(incomes[i].rate) > 0) {
          effectiveRate = Number(incomes[i].rate)
          break
        }
      }
    }
    
    const fee = (totalIncome * feePercent) / 100
    const shouldDispatch = totalIncome - fee
    const shouldDispatchUSDT = effectiveRate ? Number((shouldDispatch / effectiveRate).toFixed(1)) : 0
    const dispatchedUSDT = effectiveRate ? Number((totalDispatch / effectiveRate).toFixed(1)) : 0
    const notDispatched = shouldDispatch - totalDispatch
    const notDispatchedUSDT = effectiveRate ? Number((notDispatched / effectiveRate).toFixed(1)) : 0


    return Response.json({
      bill,
      items,
      settings: {
        accountingMode: settings?.accountingMode ?? 'DAILY_RESET',
        feePercent,
        effectiveRate,
      },
      summary: {
        totalIncome,
        totalDispatch,
        incomeCount: incomes.length,
        dispatchCount: dispatches.length,
        shouldDispatch,
        shouldDispatchUSDT,
        dispatchedUSDT,
        notDispatched,
        notDispatchedUSDT,
        fee,
      },
    })
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}

export async function DELETE(req: NextRequest, { params }: { params: { id: string } }) {
  try {
    const id = params.id
    const bill = await prisma.bill.findUnique({ where: { id }, select: { id: true, chatId: true, status: true } })
    if (!bill) return new Response('Not Found', { status: 404 })
    
    // ğŸ”¥ åˆ é™¤è´¦å•å’Œæ‰€æœ‰è´¦å•é¡¹ï¼ˆä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§ï¼‰
    await prisma.$transaction(async (tx: any) => {
      await tx.billItem.deleteMany({ where: { billId: id } })
      await tx.bill.delete({ where: { id } })
    })
    
    return new Response(null, { status: 204 })
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db.js'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

function normalizeName(name: string) {
  return (name || '').trim().toLowerCase()
}

function buildKey(botId: string) {
  return `customcmds:bot:${botId}`
}

function isValidImageUrl(url?: string) {
  if (!url) return false
  // allow site-relative uploads path
  if (url.startsWith('/uploads/')) return true
  try {
    const u = new URL(url)
    return u.protocol === 'http:' || u.protocol === 'https:'
  } catch {
    return false
  }
}

export async function PUT(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'cc_img_put', 30, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const body = await req.json().catch(() => ({}))
    const botId = String(body.botId || '').trim()
    const rawName = String(body.name || '')
    const imageUrlRaw = body.imageUrl == null ? null : String(body.imageUrl)
    if (!botId || !rawName) return NextResponse.json({ error: 'botId and name are required' }, { status: 400 })
    const name = normalizeName(rawName)

    const key = buildKey(botId)
    const cfg = await prisma.globalConfig.findUnique({ where: { key } })
    let map: Record<string, any> = {}
    if (cfg?.value) {
      try { map = JSON.parse(String(cfg.value) || '{}') } catch {}
    }
    if (!map[name]) map[name] = {}

    if (imageUrlRaw === null || imageUrlRaw === '') {
      delete map[name].imageUrl
    } else {
      if (!isValidImageUrl(imageUrlRaw)) {
        return NextResponse.json({ error: 'invalid imageUrl' }, { status: 400 })
      }
      map[name].imageUrl = imageUrlRaw
    }
    map[name].updatedAt = new Date().toISOString()
    map[name].updatedBy = 'admin'

    await prisma.globalConfig.upsert({
      where: { key },
      update: { value: JSON.stringify(map), description: `Custom commands for bot ${botId}`, updatedBy: 'admin', updatedAt: new Date() },
      create: { key, value: JSON.stringify(map), description: `Custom commands for bot ${botId}`, updatedBy: 'admin' }
    })

    return NextResponse.json({ ok: true })
  } catch (e) {
    console.error('[custom-commands:image][PUT]', e)
    return NextResponse.json({ error: 'Internal error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db.js'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

function normalizeName(name: string) {
  return (name || '').trim().toLowerCase()
}

function buildKey(botId: string) {
  return `customcmds:bot:${botId}`
}

export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'cc_get', 60, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { searchParams } = new URL(req.url)
    const botId = (searchParams.get('botId') || '').trim()
    if (!botId) return NextResponse.json({ error: 'botId is required' }, { status: 400 })

    const cfg = await prisma.globalConfig.findUnique({ where: { key: buildKey(botId) } })
    let items: Array<{ name: string; text?: string; imageUrl?: string; updatedAt?: string; updatedBy?: string }> = []
    if (cfg?.value) {
      try {
        const map = JSON.parse(String(cfg.value) || '{}') as Record<string, any>
        items = Object.entries(map).map(([k, v]: any) => ({ name: k, text: v?.text || '', imageUrl: v?.imageUrl || undefined, updatedAt: v?.updatedAt, updatedBy: v?.updatedBy }))
      } catch {}
    }
    return NextResponse.json({ items })
  } catch (e) {
    console.error('[custom-commands][GET]', e)
    return NextResponse.json({ error: 'Internal error' }, { status: 500 })
  }
}

export async function POST(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'cc_post', 30, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const body = await req.json().catch(() => ({}))
    const botId = String(body.botId || '').trim()
    const rawName = String(body.name || '')
    const text = typeof body.text === 'string' ? body.text : ''
    if (!botId || !rawName) return NextResponse.json({ error: 'botId and name are required' }, { status: 400 })
    const name = normalizeName(rawName)

    const key = buildKey(botId)
    const cfg = await prisma.globalConfig.findUnique({ where: { key } })
    let map: Record<string, any> = {}
    if (cfg?.value) {
      try { map = JSON.parse(String(cfg.value) || '{}') } catch {}
    }
    const prev = map[name] || {}
    map[name] = { ...prev, text, updatedAt: new Date().toISOString(), updatedBy: 'admin' }

    await prisma.globalConfig.upsert({
      where: { key },
      update: { value: JSON.stringify(map), description: `Custom commands for bot ${botId}`, updatedBy: 'admin', updatedAt: new Date() },
      create: { key, value: JSON.stringify(map), description: `Custom commands for bot ${botId}`, updatedBy: 'admin' }
    })

    return NextResponse.json({ ok: true })
  } catch (e) {
    console.error('[custom-commands][POST]', e)
    return NextResponse.json({ error: 'Internal error' }, { status: 500 })
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'cc_del', 30, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const body = await req.json().catch(() => ({}))
    const botId = String(body.botId || '').trim()
    const rawName = String(body.name || '')
    if (!botId || !rawName) return NextResponse.json({ error: 'botId and name are required' }, { status: 400 })
    const name = normalizeName(rawName)

    const key = buildKey(botId)
    const cfg = await prisma.globalConfig.findUnique({ where: { key } })
    let map: Record<string, any> = {}
    if (cfg?.value) {
      try { map = JSON.parse(String(cfg.value) || '{}') } catch {}
    }
    if (!map[name]) return NextResponse.json({ error: 'not found' }, { status: 404 })
    delete map[name]

    if (Object.keys(map).length === 0) {
      await prisma.globalConfig.delete({ where: { key } }).catch(() => {})
      return NextResponse.json({ ok: true })
    }

    await prisma.globalConfig.upsert({
      where: { key },
      update: { value: JSON.stringify(map), updatedBy: 'admin', updatedAt: new Date() },
      create: { key, value: JSON.stringify(map), description: `Custom commands for bot ${botId}`, updatedBy: 'admin' }
    })

    return NextResponse.json({ ok: true })
  } catch (e) {
    console.error('[custom-commands][DELETE]', e)
    return NextResponse.json({ error: 'Internal error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

/**
 * é€šè¿‡ Bot API è·å– Telegram ç”¨æˆ·ä¿¡æ¯
 */
export async function POST(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'tg_get_user', 20, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const body = await req.json()
    const { userId } = body

    if (!userId) {
      return NextResponse.json({ error: 'userId is required' }, { status: 400 })
    }

    // è·å–ä»»ä¸€å¯ç”¨çš„ bot token
    const bot = await prisma.bot.findFirst({
      where: { enabled: true },
      select: { token: true }
    })

    if (!bot || !bot.token) {
      return NextResponse.json({ error: 'No active bot found' }, { status: 404 })
    }

    // è°ƒç”¨ Telegram Bot API è·å–ç”¨æˆ·ä¿¡æ¯
    const telegramApiUrl = `https://api.telegram.org/bot${bot.token}/getChat?chat_id=${userId}`
    
    const response = await fetch(telegramApiUrl)
    const data = await response.json()

    if (!data.ok) {
      console.error('[telegram-api][get-user][error]', data)
      return NextResponse.json({ 
        error: 'Failed to fetch user info from Telegram',
        details: data.description 
      }, { status: 400 })
    }

    const user = data.result
    const username = user.username ? `@${user.username}` : null
    const firstName = user.first_name || ''
    const lastName = user.last_name || ''
    const displayName = [firstName, lastName].filter(Boolean).join(' ') || username || userId

    return NextResponse.json({
      userId,
      username,
      firstName,
      lastName,
      displayName
    })
  } catch (error: any) {
    console.error('[telegram-api][get-user][exception]', error)
    return NextResponse.json({ 
      error: 'Failed to fetch user info',
      message: error.message 
    }, { status: 500 })
  }
}

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { ProxyAgent } from 'undici'
import { ensureDefaultFeatures } from '@/bot/constants'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

export async function POST(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'chat_manual_add', 10, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const body = await req.json().catch(() => ({})) as { chatId?: string; botId?: string }
    const chatId = (body.chatId || '').trim()
    const botId = (body.botId || '').trim()
    if (!chatId || !botId) return new NextResponse('ç¼ºå°‘ chatId æˆ– botId', { status: 400 })

    const bot = await prisma.bot.findUnique({ where: { id: botId }, select: { token: true, id: true, proxyUrl: true } })
    if (!bot?.token) return new NextResponse('æœºå™¨äººä¸å­˜åœ¨', { status: 400 })

    // æ”¯æŒä»£ç†é…ç½®ï¼ˆä¼˜å…ˆä½¿ç”¨botçš„proxyUrlï¼Œå…¶æ¬¡ä½¿ç”¨å…¨å±€PROXY_URLï¼‰
    const proxyUrl = (bot.proxyUrl || process.env.PROXY_URL || '').trim()
    const dispatcher = proxyUrl ? new ProxyAgent(proxyUrl) : undefined

    const url = `https://api.telegram.org/bot${encodeURIComponent(bot.token)}/getChat?chat_id=${encodeURIComponent(chatId)}`
    const resp = await fetch(url, { 
      method: 'GET',
      // @ts-ignore - undici dispatcher is compatible
      dispatcher 
    })
    
    if (!resp.ok) {
      const errorText = await resp.text().catch(() => '')
      console.error('getChat è°ƒç”¨å¤±è´¥:', { chatId, status: resp.status, error: errorText })
      return new NextResponse(`getChat è°ƒç”¨å¤±è´¥ (HTTP ${resp.status}): ${errorText || 'è¯·æ£€æŸ¥chatIdæ ¼å¼ï¼ˆç¾¤ç»„IDé€šå¸¸æ˜¯è´Ÿæ•°ï¼Œå¦‚-121321ï¼‰å’ŒBotæ˜¯å¦åœ¨ç¾¤å†…'}`, { status: 400 })
    }
    
    const j = await resp.json().catch(() => null)
    if (!j?.ok) {
      console.error('getChat è¿”å›é”™è¯¯:', j)
      return new NextResponse(`æœºå™¨äººä¸åœ¨è¯¥ç¾¤æˆ– chatId æ— æ•ˆ: ${j?.description || 'æœªçŸ¥é”™è¯¯'}`, { status: 400 })
    }

    // upsert chat and bind to bot
    const title = (j.result?.title || '') as string
    const chat = await prisma.chat.upsert({
      where: { id: chatId },
      update: { title, bot: { connect: { id: botId } } },
      create: { 
        id: chatId, 
        title, 
        status: 'PENDING', 
        allowed: false, 
        bot: { connect: { id: botId } },
        invitedBy: null, // ğŸ”¥ æ‰‹åŠ¨æ·»åŠ æ ‡è®°ä¸ºç©º
        invitedByUsername: 'æ‰‹åŠ¨' // ğŸ”¥ æ‰‹åŠ¨æ·»åŠ æ ‡è®°ä¸º"æ‰‹åŠ¨"
      },
      select: { id: true, title: true, status: true, botId: true },
    })

    // ğŸ”¥ ä¸ºæ‰‹åŠ¨æ·»åŠ çš„ç¾¤ç»„è‡ªåŠ¨å¼€å¯æ‰€æœ‰åŠŸèƒ½å¼€å…³
    await ensureDefaultFeatures(chatId, prisma)

    return NextResponse.json(chat)
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin } from '@/app/api/_auth'

export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const { searchParams } = new URL(req.url)
    const botId = searchParams.get('botId') || undefined
    const status = searchParams.get('status') || undefined

    // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šå¼‚æ­¥æ¸…ç†æœªç»‘å®šæœºå™¨äººçš„ç¾¤ç»„ï¼ˆä¸é˜»å¡ä¸»è¯·æ±‚ï¼‰
    // å°†æ¸…ç†ä»»åŠ¡ç§»åˆ°åå°ï¼Œé¿å…æ¯æ¬¡è¯·æ±‚éƒ½ç­‰å¾…
    const cleanupOrphans = async () => {
      try {
        const orphanChats = await prisma.chat.findMany({ where: { botId: null }, select: { id: true }, take: 10 })
        if (orphanChats.length) {
          const orphanIds = orphanChats.map((c: { id: string }) => c.id)
          const bills = await prisma.bill.findMany({ where: { chatId: { in: orphanIds } }, select: { id: true } })
          const billIds = bills.map((b: { id: string }) => b.id)
          if (billIds.length) {
            await prisma.billItem.deleteMany({ where: { billId: { in: billIds } } })
            await prisma.bill.deleteMany({ where: { id: { in: billIds } } })
          }
          await prisma.commission.deleteMany({ where: { chatId: { in: orphanIds } } })
          await prisma.dispatch.deleteMany({ where: { chatId: { in: orphanIds } } })
          await prisma.income.deleteMany({ where: { chatId: { in: orphanIds } } })
          await prisma.operator.deleteMany({ where: { chatId: { in: orphanIds } } })
          await prisma.setting.deleteMany({ where: { chatId: { in: orphanIds } } })
          await prisma.chatFeatureFlag.deleteMany({ where: { chatId: { in: orphanIds } } })
          await prisma.chat.deleteMany({ where: { id: { in: orphanIds } } })
        }
      } catch (e) {
        console.error('[cleanup-orphans] å¤±è´¥', e)
      }
    }
    // å¼‚æ­¥æ‰§è¡Œï¼Œä¸ç­‰å¾…ç»“æœ
    cleanupOrphans().catch(() => {})

    const where: any = {
      id: { startsWith: '-' },
      ...(botId ? { botId } : {}),
      ...(status ? { status } : {}),
      // UI ä»…å±•ç¤ºå·²ç»‘å®šæœºå™¨äººçš„ç¾¤ç»„
      botId: { not: null },
    }

    // ğŸ”¥ ä¼˜åŒ–ï¼šç›´æ¥è¿”å›ç¾¤ç»„æ•°æ®ï¼Œç§»é™¤å®æ—¶éªŒè¯ï¼ˆé¿å…ç¾¤ç»„æ¶ˆå¤±ï¼‰
    // éªŒè¯é€»è¾‘ç§»åˆ°åå°ä»»åŠ¡ï¼Œä¸é˜»å¡APIå“åº”
    // ğŸ”¥ ç›´æ¥æŸ¥è¯¢æ‰€æœ‰å­—æ®µï¼ˆåŒ…æ‹¬ invitedBy å’Œ invitedByUsernameï¼‰
    const chats = await prisma.chat.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        title: true,
        status: true,
        allowed: true,
        createdAt: true,
        botId: true,
        invitedBy: true, // é‚€è¯·äººID
        invitedByUsername: true, // é‚€è¯·äººç”¨æˆ·å
        groupId: true, // ğŸ”¥ æ–°å¢ï¼šåˆ†ç»„ID
        bot: { select: { id: true, name: true, token: true } },
        group: { select: { id: true, name: true } }, // ğŸ”¥ æ–°å¢ï¼šåˆ†ç»„ä¿¡æ¯
      },
    })
    
    // ğŸ”¥ ç§»é™¤å®æ—¶éªŒè¯ï¼Œç›´æ¥è¿”å›æ•°æ®ï¼ˆæå‡åŠ è½½é€Ÿåº¦ï¼‰
    // éªŒè¯é€»è¾‘å·²ç§»é™¤ï¼Œé¿å…é˜»å¡å“åº”å’Œå¯¼è‡´ç¾¤ç»„æ¶ˆå¤±
    
    return NextResponse.json({ items: chats })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'

export async function GET(_: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id: chatId } = await context.params
    const chat = await prisma.chat.findUnique({ where: { id: chatId }, select: { id: true, title: true } })
    if (!chat) return new Response('Not Found', { status: 404 })

    const setting = await prisma.setting.findUnique({ where: { chatId } })
    return Response.json({
      chat: { id: chat.id, title: chat.title },
      settings: {
        headerText: setting?.headerText ?? '',
        fixedRate: setting?.fixedRate ?? null,
        realtimeRate: setting?.realtimeRate ?? null,
        feePercent: setting?.feePercent ?? 0,
        accountingMode: setting?.accountingMode ?? 'DAILY_RESET',
        featureWarningMode: setting?.featureWarningMode ?? 'always',
        addressVerificationEnabled: setting?.addressVerificationEnabled ?? false,
        dailyCutoffHour: setting?.dailyCutoffHour ?? 0,
        hideHelpButton: setting?.hideHelpButton ?? false,
        hideOrderButton: setting?.hideOrderButton ?? false,
        deleteBillConfirm: setting?.deleteBillConfirm ?? false, // ğŸ”¥ åˆ é™¤è´¦å•ç¡®è®¤åŠŸèƒ½
        calculatorEnabled: setting?.calculatorEnabled ?? true, // ğŸ”¥ è®¡ç®—å™¨åŠŸèƒ½å¼€å…³
        showAuthPrompt: setting?.showAuthPrompt ?? true, // ğŸ”¥ æ˜¾ç¤ºæˆæƒæç¤ºå¼€å…³
        welcomeMessage: setting?.welcomeMessage ?? '', // ğŸ”¥ æ‹‰ç¾¤æ¬¢è¿æ¶ˆæ¯
      },
    })
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}

export async function PATCH(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id: chatId } = await context.params
    const body = (await req.json().catch(() => ({}))) as {
      title?: string
      headerText?: string | null
      fixedRate?: number | null
      realtimeRate?: number | null
      feePercent?: number | null
      accountingMode?: 'DAILY_RESET' | 'CARRY_OVER' | 'SINGLE_BILL_PER_DAY'
      featureWarningMode?: string
      addressVerificationEnabled?: boolean
      dailyCutoffHour?: number
      hideHelpButton?: boolean
      hideOrderButton?: boolean
      deleteBillConfirm?: boolean // ğŸ”¥ åˆ é™¤è´¦å•ç¡®è®¤åŠŸèƒ½
      calculatorEnabled?: boolean // ğŸ”¥ è®¡ç®—å™¨åŠŸèƒ½å¼€å…³
      showAuthPrompt?: boolean // ğŸ”¥ æ˜¾ç¤ºæˆæƒæç¤ºå¼€å…³
      welcomeMessage?: string | null // ğŸ”¥ æ‹‰ç¾¤æ¬¢è¿æ¶ˆæ¯
    }

    // Update Chat.title if provided
    if (typeof body.title === 'string') {
      await prisma.chat.update({ where: { id: chatId }, data: { title: body.title } })
    }

    // Normalize mutually exclusive fixedRate/realtimeRate
    let fixedRate: number | null | undefined = body.fixedRate
    let realtimeRate: number | null | undefined = body.realtimeRate
    if (fixedRate != null) {
      realtimeRate = null
    } else if (realtimeRate != null) {
      fixedRate = null
    }

    const patchData: any = {}
    // ğŸ”¥ ä¼˜åŒ–ï¼šåªè¦æœ‰å­—æ®µä¼ å…¥å°±å¤„ç†ï¼Œå³ä½¿å€¼ä¸ºé»˜è®¤å€¼ä¹Ÿå…è®¸ä¿å­˜
    if (typeof body.headerText === 'string') patchData.headerText = body.headerText
    if (fixedRate !== undefined) patchData.fixedRate = fixedRate
    if (realtimeRate !== undefined) patchData.realtimeRate = realtimeRate
    if (typeof body.feePercent === 'number') patchData.feePercent = body.feePercent
    if (body.accountingMode === 'DAILY_RESET' || body.accountingMode === 'CARRY_OVER' || body.accountingMode === 'SINGLE_BILL_PER_DAY') {
      patchData.accountingMode = body.accountingMode
    }
    if (body.featureWarningMode && ['always', 'once', 'daily', 'silent'].includes(body.featureWarningMode)) patchData.featureWarningMode = body.featureWarningMode
    // ğŸ”¥ ä¿®å¤ï¼šbooleanå­—æ®µå³ä½¿æ˜¯falseä¹Ÿè¦æ·»åŠ åˆ°patchDataä¸­
    if (typeof body.addressVerificationEnabled === 'boolean') patchData.addressVerificationEnabled = body.addressVerificationEnabled
    if (typeof body.dailyCutoffHour === 'number' && body.dailyCutoffHour >= 0 && body.dailyCutoffHour <= 23) patchData.dailyCutoffHour = body.dailyCutoffHour
    if (typeof body.hideHelpButton === 'boolean') patchData.hideHelpButton = body.hideHelpButton
    if (typeof body.hideOrderButton === 'boolean') patchData.hideOrderButton = body.hideOrderButton
    if (typeof body.deleteBillConfirm === 'boolean') patchData.deleteBillConfirm = body.deleteBillConfirm // ğŸ”¥ åˆ é™¤è´¦å•ç¡®è®¤åŠŸèƒ½
    if (typeof body.calculatorEnabled === 'boolean') patchData.calculatorEnabled = body.calculatorEnabled // ğŸ”¥ è®¡ç®—å™¨åŠŸèƒ½å¼€å…³
    if (typeof body.showAuthPrompt === 'boolean') patchData.showAuthPrompt = body.showAuthPrompt // ğŸ”¥ æ˜¾ç¤ºæˆæƒæç¤ºå¼€å…³
    if (body.welcomeMessage !== undefined) patchData.welcomeMessage = body.welcomeMessage // ğŸ”¥ æ‹‰ç¾¤æ¬¢è¿æ¶ˆæ¯

    // ğŸ”¥ ä¼˜åŒ–ï¼šåªè¦æœ‰ä¼ å…¥ä»»ä½•è®¾ç½®å­—æ®µå°±å…è®¸ä¿å­˜ï¼ˆå³ä½¿å€¼ä¸ºé»˜è®¤å€¼ï¼‰
    // å¦‚æœpatchDataä¸ºç©ºä½†ä¼ å…¥äº†è®¾ç½®å­—æ®µï¼Œä»ç„¶å…è®¸ä¿å­˜ï¼ˆå¯èƒ½æ˜¯ä¿å­˜é»˜è®¤å€¼ï¼‰
    const hasSettingsFields = [
      'accountingMode',
      'featureWarningMode',
      'addressVerificationEnabled',
      'dailyCutoffHour',
      'hideHelpButton',
      'hideOrderButton',
      'deleteBillConfirm',
      'calculatorEnabled',
      'showAuthPrompt',
      'welcomeMessage',
      'feePercent',
      'fixedRate',
      'realtimeRate',
      'headerText'
    ].some(key => key in body)

    if (Object.keys(patchData).length === 0 && !hasSettingsFields && !body.title) {
      return new Response('Bad Request: No valid fields to update', { status: 400 })
    }
    
    // ğŸ”¥ å¦‚æœpatchDataä¸ºç©ºä½†æœ‰ä¼ å…¥å­—æ®µï¼Œè¯´æ˜å¯èƒ½æ˜¯ä¿å­˜é»˜è®¤å€¼ï¼Œä»ç„¶æ‰§è¡Œupsert

    await prisma.setting.upsert({
      where: { chatId },
      update: patchData,
      create: { chatId, ...patchData },
    })

    // ğŸ”¥ å¦‚æœæ›´æ–°äº†featureWarningModeï¼Œæ¸…é™¤ç›¸å…³çš„è­¦å‘Šè®°å½•ï¼Œç¡®ä¿æ–°è®¾ç½®ç«‹å³ç”Ÿæ•ˆ
    if (body.featureWarningMode && ['always', 'once', 'daily', 'silent'].includes(body.featureWarningMode)) {
      // æ¸…é™¤æ‰€æœ‰ç›¸å…³åŠŸèƒ½çš„è­¦å‘Šè®°å½•ï¼Œè®©æ–°è®¾ç½®ç«‹å³ç”Ÿæ•ˆ
      await prisma.featureWarningLog.deleteMany({
        where: { chatId }
      }).catch(() => {})
    }

    const updated = await prisma.setting.findUnique({ where: { chatId } })
    return Response.json({ ok: true, settings: updated })
  } catch (e) {
    console.error(e)
    return new Response('Server error', { status: 500 })
  }
}

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

function normalizeUsername(u?: string | null) {
  const x = (u || '').trim()
  if (!x) return ''
  return x.startsWith('@') ? x : `@${x}`
}

export async function DELETE(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'chat_ops_del', 30, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { id: chatId } = await context.params
    const body = await req.json().catch(() => ({})) as { username?: string }
    const username = normalizeUsername(body.username)
    if (!username) return new NextResponse('Bad Request', { status: 400 })

    await prisma.operator.delete({ where: { chatId_username: { chatId, username } } }).catch(() => {})
    const items = await prisma.operator.findMany({ where: { chatId }, orderBy: { username: 'asc' } })
    return NextResponse.json({ ok: true, items })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

export async function GET(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const { id: chatId } = await context.params
    const ops = await prisma.operator.findMany({ where: { chatId }, orderBy: { username: 'asc' } })
    return NextResponse.json({ items: ops })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

export async function POST(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'chat_ops_post', 30, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { id: chatId } = await context.params
    const body = await req.json().catch(() => ({})) as { username?: string }
    const username = normalizeUsername(body.username)
    if (!username || username.length < 2) return new NextResponse('Bad Request', { status: 400 })

    // ensure chat exists
    const chat = await prisma.chat.findUnique({ where: { id: chatId } })
    if (!chat) return new NextResponse('Not Found', { status: 404 })

    // upsert operator
    await prisma.operator.upsert({
      where: { chatId_username: { chatId, username } },
      update: {},
      create: { chatId, username },
    })

    const items = await prisma.operator.findMany({ where: { chatId }, orderBy: { username: 'asc' } })
    return NextResponse.json({ ok: true, items })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest } from 'next/server'
import { prisma } from '@/lib/db'

// è®¾ç½®ç¾¤ç»„çš„åˆ†ç»„
export async function PATCH(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params
    const body = await req.json().catch(() => ({})) as { groupId?: string | null }
    
    const chat = await prisma.chat.findUnique({
      where: { id },
      select: { botId: true }
    })
    if (!chat) {
      return Response.json({ error: 'ç¾¤ç»„ä¸å­˜åœ¨' }, { status: 404 })
    }

    // å¦‚æœæä¾›äº† groupIdï¼ŒéªŒè¯åˆ†ç»„æ˜¯å¦å­˜åœ¨ä¸”å±äºè¯¥æœºå™¨äºº
    if (body.groupId) {
      const group = await prisma.chatGroup.findFirst({
        where: { id: body.groupId, botId: chat.botId || '' }
      })
      if (!group) {
        return Response.json({ error: 'åˆ†ç»„ä¸å­˜åœ¨' }, { status: 404 })
      }
    }

    await prisma.chat.update({
      where: { id },
      data: { groupId: body.groupId || null }
    })

    return Response.json({ ok: true })
  } catch (e) {
    console.error(e)
    return Response.json({ error: 'Server error' }, { status: 500 })
  }
}

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'
import { DEFAULT_FEATURES } from '@/bot/constants'

type FeatureInput = { feature: string; enabled: boolean }

// GET /api/chats/[id]/features - è·å–ç¾¤ç»„çš„åŠŸèƒ½å¼€å…³
export async function GET(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'chat_features_get', 60, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { id: chatId } = await context.params
    
    // æ£€æŸ¥ç¾¤ç»„æ˜¯å¦å­˜åœ¨
    const chat = await prisma.chat.findUnique({
      where: { id: chatId },
      select: { id: true }
    })
    if (!chat) {
      return new NextResponse('Chat not found', { status: 404 })
    }
    
    const flags = await prisma.chatFeatureFlag.findMany({
      where: { chatId },
      select: { feature: true, enabled: true },
      orderBy: { feature: 'asc' },
    })
    
    // ğŸ”¥ ç®€åŒ–åŠŸèƒ½å¼€å…³ï¼šåªè¿”å›åŸºç¡€è®°è´¦åŠŸèƒ½ï¼Œè¿‡æ»¤æ‰å…¶ä»–ä¸éœ€è¦çš„åŠŸèƒ½
    const validFeatures = new Set(DEFAULT_FEATURES)
    const filteredFlags = flags.filter((f: any) => validFeatures.has(f.feature))
    
    if (!filteredFlags.length) {
      // ğŸ”¥ å¦‚æœæ²¡æœ‰åŠŸèƒ½å¼€å…³ï¼Œè¿”å›é»˜è®¤çš„åŸºç¡€è®°è´¦åŠŸèƒ½ï¼ˆé»˜è®¤å¯ç”¨ï¼‰
      const defaultItems = DEFAULT_FEATURES.map(f => ({ feature: f, enabled: true }))
      return NextResponse.json({ items: defaultItems, isDefault: true })
    }
    
    // ğŸ”¥ åªè¿”å›åŸºç¡€è®°è´¦åŠŸèƒ½
    return NextResponse.json({ items: filteredFlags, isDefault: false })
  } catch (e) {
    console.error('[GET /api/chats/[id]/features]', e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

// PUT /api/chats/[id]/features - æ›´æ–°ç¾¤ç»„çš„åŠŸèƒ½å¼€å…³
export async function PUT(req: NextRequest, context: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'chat_features_put', 30, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { id: chatId } = await context.params
    const body = await req.json().catch(() => ({})) as { features?: FeatureInput[] }
    
    if (!Array.isArray(body.features)) {
      return new NextResponse('Invalid payload', { status: 400 })
    }

    // æ£€æŸ¥ç¾¤ç»„æ˜¯å¦å­˜åœ¨
    const chat = await prisma.chat.findUnique({
      where: { id: chatId },
      select: { id: true }
    })
    if (!chat) {
      return new Response('Chat not found', { status: 404 })
    }

    // ğŸ”¥ åªä¿å­˜åŸºç¡€è®°è´¦åŠŸèƒ½ï¼Œåˆ é™¤å…¶ä»–ä¸éœ€è¦çš„åŠŸèƒ½å¼€å…³
    const validFeatures = new Set(DEFAULT_FEATURES)
    const validFeaturesToSave = body.features.filter(f => validFeatures.has(f.feature))
    
    // åˆ é™¤æ‰€æœ‰ç°æœ‰çš„åŠŸèƒ½å¼€å…³ï¼ˆåŒ…æ‹¬ä¸éœ€è¦çš„ï¼‰
    await prisma.chatFeatureFlag.deleteMany({ where: { chatId } })
    
    // ğŸ”¥ ç¡®ä¿åŸºç¡€è®°è´¦åŠŸèƒ½å§‹ç»ˆæœ‰è®°å½•ï¼ˆå³ä½¿å…³é—­ä¹Ÿè¦åˆ›å»º enabled: false è®°å½•ï¼‰
    const accountingBasicFeature = validFeaturesToSave.find(f => f.feature === 'accounting_basic')
    if (accountingBasicFeature) {
      // å¦‚æœè¯·æ±‚ä¸­åŒ…å«åŸºç¡€è®°è´¦åŠŸèƒ½ï¼Œä½¿ç”¨è¯·æ±‚çš„å€¼
      await prisma.chatFeatureFlag.create({
        data: {
          chatId,
          feature: accountingBasicFeature.feature,
          enabled: Boolean(accountingBasicFeature.enabled),
        },
      })
    } else {
      // ğŸ”¥ å¦‚æœè¯·æ±‚ä¸­æ²¡æœ‰åŸºç¡€è®°è´¦åŠŸèƒ½ï¼Œè¯´æ˜ç”¨æˆ·å…³é—­äº†å®ƒï¼Œåˆ›å»º enabled: false è®°å½•
      await prisma.chatFeatureFlag.create({
        data: {
          chatId,
          feature: 'accounting_basic',
          enabled: false,
        },
      })
    }

    // è¿”å›åªåŒ…å«åŸºç¡€è®°è´¦åŠŸèƒ½çš„ç»“æœ
    const flags = await prisma.chatFeatureFlag.findMany({
      where: { chatId },
      select: { feature: true, enabled: true },
      orderBy: { feature: 'asc' },
    })
    
    // å†æ¬¡è¿‡æ»¤ï¼Œç¡®ä¿åªè¿”å›æœ‰æ•ˆçš„åŠŸèƒ½
    const filteredFlags = flags.filter((f: any) => validFeatures.has(f.feature))
    return NextResponse.json({ items: filteredFlags })
  } catch (e) {
    console.error('[PUT /api/chats/[id]/features]', e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'
import { ProxyAgent } from 'undici'

export async function PATCH(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'chat_patch', 30, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { id } = await params
    const body = await req.json().catch(() => ({})) as {
      allowed?: boolean
      title?: string
      status?: string
      botId?: string | null
    }

    const data: any = {}
    if (typeof body.allowed === 'boolean') data.allowed = body.allowed
    if (typeof body.title === 'string') data.title = body.title
    if (typeof body.status === 'string') {
      data.status = body.status as any
      if (body.status === 'APPROVED') {
        data.allowed = true
      } else if (body.status === 'PENDING' || body.status === 'BLOCKED') {
        data.allowed = false
      }
    }
    if (body.botId !== undefined) {
      if (!body.botId) {
        data.bot = { disconnect: true }
      } else {
        // éªŒè¯è¯¥ bot æ˜¯å¦å·²åŠ å…¥è¯¥ç¾¤
        const bot = await prisma.bot.findUnique({ 
          where: { id: body.botId }, 
          select: { token: true, featureFlags: { select: { feature: true, enabled: true } } } 
        })
        if (!bot?.token) return new NextResponse('æœºå™¨äººä¸å­˜åœ¨', { status: 400 })
        const getChatUrl = `https://api.telegram.org/bot${encodeURIComponent(bot.token)}/getChat?chat_id=${encodeURIComponent(id)}`
        const resp = await fetch(getChatUrl, { method: 'GET' })
        if (!resp.ok) return new NextResponse('æœºå™¨äººæœªåŠ å…¥è¯¥ç¾¤ï¼Œæ— æ³•ç»‘å®š', { status: 400 })
        const json = await resp.json().catch(() => null)
        if (!json?.ok) return new NextResponse('æœºå™¨äººæœªåŠ å…¥è¯¥ç¾¤ï¼Œæ— æ³•ç»‘å®š', { status: 400 })
        data.bot = { connect: { id: body.botId } }
        
        // è‡ªåŠ¨ä¸ºè¯¥ç¾¤å¯ç”¨è¯¥æœºå™¨äººçš„æ‰€æœ‰åŠŸèƒ½
        const enabledFeatures = bot.featureFlags?.filter((f: { enabled: boolean; feature: string }) => f.enabled).map((f: { feature: string }) => f.feature) || []
        if (enabledFeatures.length > 0) {
          // å…ˆåˆ é™¤è¯¥ç¾¤çš„æ—§åŠŸèƒ½æ ‡å¿—
          await prisma.chatFeatureFlag.deleteMany({ where: { chatId: id } })
          // åˆ›å»ºæ–°çš„åŠŸèƒ½æ ‡å¿—ï¼ˆç»§æ‰¿æœºå™¨äººçš„å¯ç”¨åŠŸèƒ½ï¼‰
          // SQLite ä¸æ”¯æŒ skipDuplicatesï¼Œæ‰€ä»¥å…ˆåˆ é™¤å†æ‰¹é‡åˆ›å»º
          for (const feature of enabledFeatures) {
            await prisma.chatFeatureFlag.create({
              data: {
                chatId: id,
                feature,
                enabled: true,
              },
            }).catch(() => {}) // å¿½ç•¥é‡å¤é”™è¯¯
          }
        }
      }
    }
    if (Object.keys(data).length === 0) return new NextResponse('Bad Request', { status: 400 })

    const updated = await prisma.chat.update({
      where: { id },
      data,
      select: {
        id: true,
        title: true,
        allowed: true,
        status: true,
        botId: true,
      },
    })
    return NextResponse.json(updated)
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

export async function GET(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const { id } = await params
    const chat = await prisma.chat.findUnique({
      where: { id },
      select: {
        id: true,
        title: true,
        allowed: true,
        status: true,
        createdAt: true,
        botId: true,
        bot: { select: { name: true } },
        featureFlags: { select: { feature: true, enabled: true } },
      },
    })
    if (!chat) return new NextResponse('Not Found', { status: 404 })
    return NextResponse.json(chat)
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}

export async function DELETE(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'chat_delete', 10, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { id } = await params
    // Ensure chat exists
    const exists = await prisma.chat.findUnique({ where: { id }, select: { id: true } })
    if (!exists) return new NextResponse('Not Found', { status: 404 })

    // ğŸ”¥ æŸ¥è¯¢æ‰€æœ‰å¯ç”¨çš„æœºå™¨äººï¼Œæ£€æŸ¥å®ƒä»¬æ˜¯å¦åœ¨è¯¥ç¾¤ä¸­ï¼Œå¦‚æœæ˜¯åˆ™è®©å®ƒä»¬é€€ç¾¤
    const bots = await prisma.bot.findMany({
      where: { enabled: true },
      select: { id: true, token: true }
    })
    
    // ğŸ”¥ å¹¶å‘è®©æ‰€æœ‰åœ¨è¯¥ç¾¤ä¸­çš„æœºå™¨äººé€€ç¾¤
    const leavePromises = bots.map(async (bot: any) => {
      if (!bot.token) return
      try {
        // å…ˆæ£€æŸ¥æœºå™¨äººæ˜¯å¦åœ¨è¯¥ç¾¤ä¸­
        const getChatUrl = `https://api.telegram.org/bot${encodeURIComponent(bot.token)}/getChat?chat_id=${encodeURIComponent(id)}`
        const resp = await fetch(getChatUrl, { 
          method: 'GET',
          signal: AbortSignal.timeout(2000) // 2ç§’è¶…æ—¶
        })
        if (resp.ok) {
          const json = await resp.json().catch(() => null)
          if (json?.ok) {
            // æœºå™¨äººç¡®å®åœ¨è¯¥ç¾¤ä¸­ï¼Œè®©å®ƒé€€ç¾¤
            const leaveChatUrl = `https://api.telegram.org/bot${encodeURIComponent(bot.token)}/leaveChat?chat_id=${encodeURIComponent(id)}`
            await fetch(leaveChatUrl, { 
              method: 'POST',
              signal: AbortSignal.timeout(2000) // 2ç§’è¶…æ—¶
            }).catch(() => {}) // å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­å¤„ç†
            console.log('[åˆ é™¤ç¾¤èŠ] æœºå™¨äººå·²é€€ç¾¤', { chatId: id, botId: bot.id })
          }
        }
      } catch (e) {
        // å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªæœºå™¨äºº
        console.error('[åˆ é™¤ç¾¤èŠ] æ£€æŸ¥/é€€ç¾¤å¤±è´¥', { chatId: id, botId: bot.id, error: e })
      }
    })
    
    // ğŸ”¥ ç­‰å¾…æ‰€æœ‰é€€ç¾¤æ“ä½œå®Œæˆï¼ˆæœ€å¤šç­‰å¾…5ç§’ï¼‰
    try {
      await Promise.race([
        Promise.all(leavePromises),
        new Promise(resolve => setTimeout(resolve, 5000)) // 5ç§’è¶…æ—¶
      ])
    } catch (e) {
      console.error('[åˆ é™¤ç¾¤èŠ] é€€ç¾¤æ“ä½œå¤±è´¥', e)
    }

    // Delete related data first to satisfy FKs
    try { await prisma.billItem.deleteMany({ where: { bill: { chatId: id } } }) } catch {}
    try { await prisma.bill.deleteMany({ where: { chatId: id } }) } catch {}
    try { await prisma.operator.deleteMany({ where: { chatId: id } }) } catch {}
    try { await prisma.setting.deleteMany({ where: { chatId: id } }) } catch {}

    // Finally delete chat
    await prisma.chat.delete({ where: { id } })
    return new NextResponse(null, { status: 204 })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

// ç®€æ˜“å†…å­˜ç¼“å­˜ï¼škey=chatIdï¼Œå€¼ä¸º { expires, items }
type EligibleItem = { id: string; name: string }
const cache = new Map<string, { expires: number; items: EligibleItem[] }>()
const TTL_MS = 5 * 60_000 // ğŸ”¥ å¢åŠ åˆ°5åˆ†é’Ÿç¼“å­˜ï¼Œå‡å°‘éªŒè¯é¢‘ç‡
const CONCURRENCY = 3 // ğŸ”¥ é€‚åº¦å¢åŠ å¹¶å‘æ•°ï¼Œæå‡é€Ÿåº¦
const REQUEST_TIMEOUT_MS = 1000 // ğŸ”¥ 1ç§’è¶…æ—¶ï¼Œå¿«é€Ÿå¤±è´¥

export async function GET(req: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'eligible_bots', 60, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { id } = await params
    const now = Date.now()
    const hit = cache.get(id)
    if (hit && hit.expires > now) {
      return NextResponse.json({ items: hit.items })
    }
    // ä»…è€ƒè™‘å¯ç”¨ä¸­çš„æœºå™¨äºº
    const bots = await prisma.bot.findMany({
      where: { enabled: true },
      select: { id: true, name: true, token: true },
    }) as Array<{ id: string; name: string; token: string | null }>
    const eligible: Array<{ id: string; name: string }> = []

    // å¹¶å‘é™åˆ¶æ‰§è¡Œå™¨
    let index = 0
    async function worker() {
      while (index < bots.length) {
        const b: { id: string; name: string; token: string | null } = bots[index++]
        if (!b?.token) continue
        try {
          const url = `https://api.telegram.org/bot${encodeURIComponent(b.token)}/getChat?chat_id=${encodeURIComponent(id)}`
          const resp = await fetch(url, { 
            method: 'GET',
            signal: AbortSignal.timeout(REQUEST_TIMEOUT_MS) // ğŸ”¥ å¿«é€Ÿè¶…æ—¶
          })
          if (!resp.ok) continue
          const j = await resp.json().catch(() => null)
          if (j && j.ok) eligible.push({ id: b.id, name: b.name })
        } catch {
          // è¶…æ—¶æˆ–å¤±è´¥æ—¶è·³è¿‡ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
        }
      }
    }
    const workers = Array.from({ length: Math.min(CONCURRENCY, Math.max(1, bots.length)) }, () => worker())
    await Promise.all(workers)

    // è‹¥æœªæ¢æµ‹åˆ°ä»»ä½•å¯ç»‘å®šæœºå™¨äººï¼Œåˆ™å›é€€è¿”å›æ‰€æœ‰å¯ç”¨ä¸­çš„æœºå™¨äººï¼ˆç”± PATCH ç«¯ä¸¥æ ¼æ ¡éªŒï¼‰
    const result = eligible.length > 0 ? eligible : bots.map((b: { id: string; name: string }) => ({ id: b.id, name: b.name }))

    // ä»…å½“ç»“æœéç©ºä¸”ä¸ºâ€œå·²æ¢æµ‹åˆ—è¡¨â€æ—¶ç¼“å­˜ï¼Œé¿å…æŠŠç©ºç»“æœç¼“å­˜å¯¼è‡´å‰ç«¯é•¿æœŸçœ‹ä¸åˆ°é€‰é¡¹
    if (eligible.length > 0) {
      cache.set(id, { expires: now + TTL_MS, items: result })
    }

    return NextResponse.json({ items: result })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

// GET: è·å–ç™½åå•ç”¨æˆ·åˆ—è¡¨
export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    // ğŸ”¥ ä¼˜åŒ–ï¼šç›´æ¥è¿”å›æ•°æ®ï¼Œç§»é™¤ N+1 æŸ¥è¯¢
    const usersRaw = await prisma.whitelistedUser.findMany({
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        userId: true,
        username: true,
        note: true,
        createdAt: true,
        updatedAt: true
      }
    })

    // ğŸ”¥ å…œåº•ï¼šå¦‚æœ username ä¸º nullï¼Œä½¿ç”¨ userId å ä½ï¼Œé¿å…å‰ç«¯æ˜¾ç¤ºä¸ºç©º
    const users = usersRaw.map((u: any) => ({
      ...u,
      username: u.username || (u.userId ? `user_${u.userId}` : 'unknown')
    }))
    
    return NextResponse.json({ items: users })
  } catch (error) {
    console.error('[whitelisted-users][GET]', error)
    return NextResponse.json({ error: 'Failed to fetch whitelisted users' }, { status: 500 })
  }
}

// POST: æ·»åŠ ç™½åå•ç”¨æˆ·
export async function POST(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'wlu_post', 20, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const body = await req.json()
    let { userId, username, note } = body

    if (!userId || !userId.trim()) {
      return NextResponse.json({ error: 'userId is required' }, { status: 400 })
    }

    userId = userId.trim()

    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const existing = await prisma.whitelistedUser.findUnique({
      where: { userId }
    })

    if (existing) {
      return NextResponse.json({ error: 'è¯¥ç”¨æˆ·IDå·²åœ¨ç™½åå•ä¸­' }, { status: 409 })
    }

    // ğŸ”¥ ä¼˜åŒ–ï¼šé€šè¿‡ Telegram Bot API è·å–ç”¨æˆ·å
    if (!username || !username.trim()) {
      try {
        const bot = await prisma.bot.findFirst({
          where: { enabled: true },
          select: { token: true }
        })

        if (bot?.token) {
          const response = await fetch(
            `https://api.telegram.org/bot${bot.token}/getChat?chat_id=${userId}`,
            { signal: AbortSignal.timeout(5000) }
          )
          const data = await response.json()

          if (data.ok && data.result) {
            const user = data.result
            username = user.username ? `@${user.username}` : 
                      (user.first_name || user.last_name) ? 
                      `${user.first_name || ''} ${user.last_name || ''}`.trim() :
                      null
            
            console.log('[whitelisted-users][telegram-api-success]', { userId, username })
          }
        }
      } catch (e) {
        console.log('[whitelisted-users][telegram-api-failed]', userId, (e as Error).message)
      }
    }

    // æœ€ç»ˆå…œåº•ï¼šè‹¥ä»æ— ç”¨æˆ·åï¼Œåˆ™ä½¿ç”¨ userId ä»£æ›¿ï¼Œé¿å…ä¸º null
    const finalUsername =
      (username && username.trim()) ||
      (userId ? `user_${userId}` : null)

    const user = await prisma.whitelistedUser.create({
      data: {
        userId,
        username: finalUsername,
        note: note?.trim() || null
      }
    })

    return NextResponse.json(user)
  } catch (error: any) {
    console.error('[whitelisted-users][POST]', error)
    if (error.code === 'P2002') {
      return NextResponse.json({ error: 'è¯¥ç”¨æˆ·IDå·²åœ¨ç™½åå•ä¸­' }, { status: 409 })
    }
    return NextResponse.json({ error: 'Failed to add whitelisted user' }, { status: 500 })
  }
}

// DELETE: åˆ é™¤ç™½åå•ç”¨æˆ·
export async function DELETE(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'wlu_del', 20, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const body = await req.json()
    const { userId } = body

    if (!userId) {
      return NextResponse.json({ error: 'userId is required' }, { status: 400 })
    }

    await prisma.whitelistedUser.delete({
      where: { userId }
    })

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('[whitelisted-users][DELETE]', error)
    return NextResponse.json({ error: 'Failed to delete whitelisted user' }, { status: 500 })
  }
}

import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

/**
 * æ—¥åˆ‡æ—¶é—´å‡½æ•° - æ”¯æŒè‡ªå®šä¹‰å°æ—¶
 * ğŸ”¥ ä¿®å¤ï¼šç»Ÿä¸€æ—¥åˆ‡é€»è¾‘ï¼Œä¸åç«¯ä¿æŒä¸€è‡´
 * ç”¨äºå®æ—¶æŸ¥è¯¢ï¼šæ ¹æ®å½“å‰æ—¶é—´åˆ¤æ–­åº”è¯¥å½’å…¥çš„è´¦å•å‘¨æœŸçš„å¼€å§‹æ—¶é—´
 * 
 * é€»è¾‘è¯´æ˜ï¼š
 * - å¦‚æœå½“å‰æ—¶é—´æ˜¯3å·ä¸Šåˆ10ç‚¹ï¼Œæ—¥åˆ‡æ˜¯2ç‚¹ï¼Œè¿”å›3å·02:00ï¼ˆä»Šå¤©è´¦å•çš„å¼€å§‹ï¼‰
 * - å¦‚æœå½“å‰æ—¶é—´æ˜¯3å·å‡Œæ™¨1ç‚¹ï¼Œæ—¥åˆ‡æ˜¯2ç‚¹ï¼Œè¿”å›2å·02:00ï¼ˆæ˜¨å¤©è´¦å•çš„å¼€å§‹ï¼‰
 */
function startOfDay(d: Date, cutoffHour: number = 0) {
  const now = new Date(d)
  
  // è®¡ç®—ä»Šå¤©çš„æ—¥åˆ‡å¼€å§‹æ—¶é—´
  const todayCutoff = new Date()
  todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
  todayCutoff.setHours(cutoffHour, 0, 0, 0)
  
  // åˆ¤æ–­å½“å‰æ—¶é—´æ˜¯å¦å·²ç»è¿‡äº†ä»Šå¤©çš„æ—¥åˆ‡ç‚¹
  if (now >= todayCutoff) {
    // å½“å‰æ—¶é—´ >= ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œè¿”å›ä»Šå¤©è´¦å•çš„å¼€å§‹æ—¶é—´
    return new Date(todayCutoff)
  } else {
    // å½“å‰æ—¶é—´ < ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œè¿”å›æ˜¨å¤©è´¦å•çš„å¼€å§‹æ—¶é—´
    const yesterdayCutoff = new Date(todayCutoff)
    yesterdayCutoff.setDate(yesterdayCutoff.getDate() - 1)
    return yesterdayCutoff
  }
}

/**
 * æ—¥åˆ‡æ—¶é—´å‡½æ•° - è®¡ç®—å½“å‰åº”è¯¥å½’å…¥çš„è´¦å•å‘¨æœŸçš„ç»“æŸæ—¶é—´
 */
function endOfDay(d: Date, cutoffHour: number = 0) {
  const start = startOfDay(d, cutoffHour)
  const end = new Date(start)
  end.setDate(end.getDate() + 1)
  return end
}

/**
 * ä»æ—¥æœŸå­—ç¬¦ä¸²è®¡ç®—æ—¥æœŸèŒƒå›´çš„èµ·å§‹æ—¶é—´
 * ç”¨äºæŸ¥è¯¢æŒ‡å®šæ—¥æœŸçš„æ•°æ®èŒƒå›´ï¼Œä¸ä¼šå› ä¸ºæ—¶é—´åˆ¤æ–­è€Œé€€åˆ°å‰ä¸€å¤©
 * @param dateStr - æ—¥æœŸå­—ç¬¦ä¸²ï¼Œæ ¼å¼ YYYY-MM-DD
 * @param cutoffHour - æ—¥åˆ‡å°æ—¶ï¼ˆ0-23ï¼‰
 * 
 * ç¤ºä¾‹ï¼šå¦‚æœ dateStr = "2025-11-03", cutoffHour = 2
 * è¿”å›ï¼š2025/11/03 02:00:00ï¼ˆè¯¥æ—¥æœŸçš„æ—¥åˆ‡å¼€å§‹æ—¶é—´ï¼‰
 */
function startOfDateRange(dateStr: string, cutoffHour: number = 0) {
  // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨æœ¬åœ°æ—¶é—´åˆ›å»ºæ—¥æœŸï¼Œé¿å…æ—¶åŒºé—®é¢˜
  // ä» YYYY-MM-DD è§£æå‡ºå¹´æœˆæ—¥
  const [year, month, day] = dateStr.split('-').map(Number)
  // åˆ›å»ºæœ¬åœ°æ—¶é—´æ—¥æœŸå¯¹è±¡ï¼ˆä¸æ˜¯UTCï¼‰
  // ä½¿ç”¨ Date.UTC ç„¶åè½¬æ¢å›æœ¬åœ°æ—¶é—´ï¼Œæˆ–è€…ç›´æ¥ç”¨æœ¬åœ°æ—¶é—´æ„é€ å‡½æ•°
  // è¿™é‡Œç›´æ¥ä½¿ç”¨æœ¬åœ°æ—¶é—´æ„é€ å‡½æ•°ï¼Œç¡®ä¿æ—¶é—´å°±æ˜¯æœ¬åœ°æ—¶é—´çš„ 02:00:00
  const d = new Date(year, month - 1, day, cutoffHour, 0, 0, 0)
  // ğŸ”¥ ç¡®ä¿è¿”å›çš„æ˜¯æœ¬åœ°æ—¶é—´çš„æ—¥æœŸå¯¹è±¡
  return d
}

/**
 * ä»æ—¥æœŸå­—ç¬¦ä¸²è®¡ç®—æ—¥æœŸèŒƒå›´çš„ç»“æŸæ—¶é—´
 * @param dateStr - æ—¥æœŸå­—ç¬¦ä¸²ï¼Œæ ¼å¼ YYYY-MM-DD
 * @param cutoffHour - æ—¥åˆ‡å°æ—¶ï¼ˆ0-23ï¼‰
 * 
 * ç¤ºä¾‹ï¼šå¦‚æœ dateStr = "2025-11-03", cutoffHour = 2
 * è¿”å›ï¼š2025/11/04 02:00:00ï¼ˆè¯¥æ—¥æœŸçš„ä¸‹ä¸€å¤©æ—¥åˆ‡æ—¶é—´ï¼‰
 */
function endOfDateRange(dateStr: string, cutoffHour: number = 0) {
  // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨æœ¬åœ°æ—¶é—´åˆ›å»ºæ—¥æœŸï¼Œé¿å…æ—¶åŒºé—®é¢˜
  // ä» YYYY-MM-DD è§£æå‡ºå¹´æœˆæ—¥
  const [year, month, day] = dateStr.split('-').map(Number)
  // åˆ›å»ºä¸‹ä¸€å¤©çš„æœ¬åœ°æ—¶é—´æ—¥æœŸå¯¹è±¡ï¼ˆä¸æ˜¯UTCï¼‰
  const d = new Date(year, month - 1, day + 1, cutoffHour, 0, 0, 0)
  // ğŸ”¥ ç¡®ä¿è¿”å›çš„æ˜¯æœ¬åœ°æ—¶é—´çš„æ—¥æœŸå¯¹è±¡
  return d
}

function addDays(d: Date, n: number) {
  const x = new Date(d)
  x.setDate(x.getDate() + n)
  return x
}

function formatTimeLocal(d: Date) {
  const dt = new Date(d)
  try {
    return dt.toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' })
  } catch (_) {
    // fallback
    const hh = String(dt.getHours()).padStart(2, '0')
    const mm = String(dt.getMinutes()).padStart(2, '0')
    const ss = String(dt.getSeconds()).padStart(2, '0')
    return `${hh}:${mm}:${ss}`
  }
}

export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'stats_today', 60, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { searchParams } = new URL(req.url)
    const dateStr = searchParams.get('date') // YYYY-MM-DD
    const chatIdParam = searchParams.get('chatId')
    const billIndexParam = searchParams.get('bill')
    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœæä¾›äº†dateStrï¼Œç›´æ¥ä½¿ç”¨å®ƒï¼Œä¸è¦è½¬æ¢ä¸ºDateå†è½¬æ¢ï¼ˆé¿å…æ—¶åŒºé—®é¢˜ï¼‰
    const now = dateStr ? new Date() : new Date() // nowåªç”¨äºå®æ—¶æŸ¥è¯¢ï¼Œä¸ç”¨äºæ—¥æœŸå­—ç¬¦ä¸²æŸ¥è¯¢

    // pick chatId: prefer latest bill if not explicitly provided
    let chatId = chatIdParam || ''
    if (!chatId) {
      const latestBill = await prisma.bill.findFirst({ orderBy: { savedAt: 'desc' } })
      chatId = latestBill?.chatId || ''
    }
    if (!chatId) {
      return NextResponse.json({
        billNumber: 0,
        totalIncome: 0,
        exchangeRate: 0,
        feeRate: 0,
        shouldDispatch: 0,
        shouldDispatchUSDT: 0,
        dispatched: 0,
        dispatchedUSDT: 0,
        notDispatched: 0,
        notDispatchedUSDT: 0,
        incomeRecords: [],
        dispatchRecords: [],
        incomeByReplier: {},
        incomeByOperator: {},
        incomeByRate: {},
        dispatchByReplier: {},
        dateRangeStart: new Date(),
        dateRangeEnd: new Date(),
      })
    }

    // ğŸ”¥ è·å–æ—¥åˆ‡æ—¶é—´è®¾ç½®
    const settings = await prisma.setting.findUnique({
      where: { chatId },
      select: {
        feePercent: true,
        fixedRate: true,
        realtimeRate: true,
        accountingMode: true,
        dailyCutoffHour: true,
      }
    })

    // ğŸ”¥ ä½¿ç”¨æ—¥åˆ‡æ—¶é—´è®¡ç®—æ—¥æœŸèŒƒå›´ï¼ˆä¼˜å…ˆä½¿ç”¨ç¾¤ç»„çº§åˆ«ï¼Œå¦åˆ™ä½¿ç”¨å…¨å±€é…ç½®ï¼‰
    let cutoffHour = 0 // é»˜è®¤å€¼
    if (settings?.dailyCutoffHour != null && settings.dailyCutoffHour >= 0 && settings.dailyCutoffHour <= 23) {
      cutoffHour = settings.dailyCutoffHour
    } else {
      // ğŸ”¥ æŸ¥è¯¢å…¨å±€é…ç½®è·å–é»˜è®¤æ—¥åˆ‡æ—¶é—´
      try {
        const globalConfig = await prisma.globalConfig.findUnique({
          where: { key: 'daily_cutoff_hour' },
          select: { value: true }
        })
        if (globalConfig?.value) {
          const hour = parseInt(globalConfig.value, 10)
          if (!isNaN(hour) && hour >= 0 && hour <= 23) {
            cutoffHour = hour
          }
        }
      } catch (e) {
        // æŸ¥è¯¢å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤å€¼0
        console.error('[stats/today] æŸ¥è¯¢å…¨å±€æ—¥åˆ‡æ—¶é—´å¤±è´¥:', e)
      }
    }
    // å¦‚æœæ˜¯ä»æ—¥æœŸå­—ç¬¦ä¸²æŸ¥è¯¢ï¼Œä½¿ç”¨ä¸“é—¨çš„å‡½æ•°ï¼›å¦åˆ™ä½¿ç”¨å®æ—¶æŸ¥è¯¢å‡½æ•°
    let gte: Date
    let lt: Date
    if (dateStr) {
      // ä»æ—¥æœŸå­—ç¬¦ä¸²æŸ¥è¯¢ï¼šç›´æ¥ä½¿ç”¨è¯¥æ—¥æœŸçš„æ—¥åˆ‡æ—¶é—´èŒƒå›´
      gte = startOfDateRange(dateStr, cutoffHour)
      lt = endOfDateRange(dateStr, cutoffHour)
    } else {
      // å®æ—¶æŸ¥è¯¢ï¼šæ ¹æ®å½“å‰æ—¶é—´åˆ¤æ–­ä»Šå¤©çš„èŒƒå›´
      gte = startOfDay(now, cutoffHour)
      lt = endOfDay(now, cutoffHour)
    }

    // ğŸ”¥ é‡æ–°æŸ¥è¯¢è´¦å•ï¼ˆä½¿ç”¨æ­£ç¡®çš„æ—¥åˆ‡æ—¶é—´ï¼‰
    // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šæŸ¥è¯¢æ‰€æœ‰è´¦å•ï¼ˆä¸é™åˆ¶æ—¥æœŸï¼‰ï¼ŒæŒ‰openedAtæ’åº
    // ğŸ”¥ æ¸…é›¶æ¨¡å¼ï¼šåªæŸ¥è¯¢å½“å¤©çš„OPENè´¦å•
    const isCumulativeMode = settings?.accountingMode === 'CARRY_OVER'
    
    let billsData: any[] = []
    
    if (isCumulativeMode) {
      // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šæŸ¥è¯¢æ‰€æœ‰è´¦å•ï¼ˆä¸é™åˆ¶æ—¥æœŸï¼‰
      billsData = await prisma.bill.findMany({
        where: { chatId },
        select: { id: true, openedAt: true, closedAt: true, status: true },
        orderBy: { openedAt: 'asc' }
      })
    } else {
      // ğŸ”¥ æ¸…é›¶æ¨¡å¼ï¼šåªæŸ¥è¯¢å½“å¤©çš„OPENè´¦å•
      billsData = await prisma.bill.findMany({
        where: { 
          chatId, 
          openedAt: { gte, lt },
          status: 'OPEN'
        },
        select: { id: true, openedAt: true, closedAt: true, status: true },
        orderBy: { openedAt: 'asc' }
      })
    }

    const billIds = billsData.map((b: any) => b.id)
      // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šå³ä½¿æœ‰å¤§é‡è®°å½•ï¼ˆå‡ åƒå‡ ä¸‡æ¡ï¼‰ï¼Œä¹Ÿä¸€æ¬¡æ€§æŸ¥è¯¢æ‰€æœ‰è®°å½•ç”¨äºè®¡ç®—
      // ä½¿ç”¨ select åªé€‰æ‹©å¿…è¦å­—æ®µï¼Œå‡å°‘æ•°æ®ä¼ è¾“é‡
      const billItems = billIds.length
      ? await prisma.billItem.findMany({
          where: { billId: { in: billIds } },
          select: {
            billId: true,
            type: true,
            amount: true,
            rate: true,
            usdt: true,
            feeRate: true, // ğŸ”¥ æ·»åŠ å•ç¬”è´¹ç‡å­—æ®µï¼Œç”¨äºæ­£ç¡®è®¡ç®—
            replier: true,
            operator: true,
            remark: true, // ğŸ”¥ æ·»åŠ å¤‡æ³¨å­—æ®µ
            displayName: true, // ğŸ”¥ æ·»åŠ ç”¨æˆ·æ˜µç§°å­—æ®µ
            userId: true, // ğŸ”¥ æ·»åŠ ç”¨æˆ·IDå­—æ®µ
            messageId: true, // ğŸ”¥ æ·»åŠ æ¶ˆæ¯IDå­—æ®µ
            createdAt: true, // ğŸ”¥ ç”¨äºè®¡ç®—ä»Šæ—¥å…¥æ¬¾ï¼ˆç´¯è®¡æ¨¡å¼ï¼‰
          },
          orderBy: { createdAt: 'asc' }
        })
      : []
    
    // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ Map é¢„å…ˆåˆ†ç»„ï¼Œé¿å…å¤šæ¬¡ filter
    const itemsByBillId = new Map<string, any[]>()
    for (const item of billItems) {
      const billId = item.billId
      if (!itemsByBillId.has(billId)) {
        itemsByBillId.set(billId, [])
      }
      itemsByBillId.get(billId)!.push(item)
    }
    
    const feePercent = settings?.feePercent ?? 0
    const fixedRate = settings?.fixedRate ?? null
    const realtimeRate = settings?.realtimeRate ?? null
    // Build per-bill aggregates and records
    const billsAgg: any[] = []
    const billsRecords: { incomeRecords: any[]; dispatchRecords: any[] }[] = []
    // ğŸ”¥ ä½¿ç”¨ billsData è€Œä¸æ˜¯ billsï¼ˆbills æ˜¯ç©ºæ•°ç»„ï¼‰
    for (const b of billsData) {
      const its = itemsByBillId.get(b.id) || []
      // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šä¸€æ¬¡æ€§åˆ†ç±»ï¼Œé¿å…å¤šæ¬¡éå†
      const incs: any[] = []
      const disps: any[] = []
      for (const item of its) {
        if (item.type === 'INCOME') {
          incs.push(item)
        } else if (item.type === 'DISPATCH') {
          disps.push(item)
        }
      }
      // ğŸ”¥ ä¿®å¤è´¹ç‡è®¡ç®—ï¼šåŒºåˆ†å•ç¬”è´¹ç‡ï¼ˆfeeRateï¼‰å’Œç¾¤ç»„è´¹ç‡ï¼ˆfeePercentï¼‰
      // å¯¹äºæœ‰å•ç¬”è´¹ç‡çš„è®°å½•ï¼Œé‡‘é¢å·²ç»æ˜¯æ‰£é™¤è´¹ç‡åçš„ï¼Œä¸éœ€è¦å†ç”¨ç¾¤ç»„è´¹ç‡æ‰£é™¤
      // å¯¹äºæ²¡æœ‰å•ç¬”è´¹ç‡çš„è®°å½•ï¼Œæ‰ç”¨ç¾¤ç»„è´¹ç‡æ‰£é™¤
      let totalGrossIncome = 0 // åŸå§‹æ€»é‡‘é¢ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
      let totalNetIncome = 0 // æ‰£é™¤è´¹ç‡åçš„æ€»é‡‘é¢ï¼ˆç”¨äºè®¡ç®—åº”ä¸‹å‘ï¼‰
      
      for (const inc of incs) {
        const amount = Number(inc.amount) || 0
        const itemFeeRate = inc.feeRate ? Number(inc.feeRate) : null
        
        if (itemFeeRate && itemFeeRate > 0 && itemFeeRate <= 1) {
          // æœ‰å•ç¬”è´¹ç‡ï¼šé‡‘é¢å·²ç»æ˜¯æ‰£é™¤è´¹ç‡åçš„ï¼Œéœ€è¦è¿˜åŸåŸå§‹é‡‘é¢ç”¨äºæ˜¾ç¤º
          const grossAmount = amount / itemFeeRate
          totalGrossIncome += grossAmount
          totalNetIncome += amount // å·²ç»æ˜¯æ‰£é™¤è´¹ç‡åçš„
        } else {
          // æ²¡æœ‰å•ç¬”è´¹ç‡ï¼šä½¿ç”¨ç¾¤ç»„è´¹ç‡
          const grossAmount = amount
          totalGrossIncome += grossAmount
          const netAmount = amount - (amount * (feePercent || 0)) / 100
          totalNetIncome += netAmount
        }
      }
      
      const tIncome = totalGrossIncome // ç”¨äºæ˜¾ç¤ºçš„æ€»å…¥æ¬¾ï¼ˆåŸå§‹é‡‘é¢ï¼‰
      const tDisp = disps.reduce((s: number, x: any) => s + (Number(x.amount) || 0), 0)
      let rateB = fixedRate ?? realtimeRate ?? 0
      if (!rateB) {
        // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šä»åå¾€å‰æ‰¾ç¬¬ä¸€ä¸ªæœ‰æ±‡ç‡çš„è®°å½•ï¼Œä¸éœ€è¦ reverse
        for (let i = incs.length - 1; i >= 0; i--) {
          if (incs[i].rate && Number(incs[i].rate) > 0) {
            rateB = Number(incs[i].rate)
            break
          }
        }
      }
      // ğŸ”¥ ä¿®å¤ï¼šåº”ä¸‹å‘ä½¿ç”¨æ‰£é™¤è´¹ç‡åçš„æ€»é‡‘é¢ï¼ˆå·²ç»è€ƒè™‘äº†å•ç¬”è´¹ç‡å’Œç¾¤ç»„è´¹ç‡ï¼‰
      const shouldB = totalNetIncome
      const toUSDTB = (n: number) => (rateB ? Number((n / rateB).toFixed(2)) : 0)
      const incomeRecordsSaved = incs.map((i: any) => {
        const amount = Number(i.amount) || 0
        const itemFeeRate = i.feeRate ? Number(i.feeRate) : null
        
        // ğŸ”¥ ä¿®å¤ï¼šè®¡ç®—åŸå§‹é‡‘é¢ï¼ˆgrossï¼‰å’Œæ‰£é™¤è´¹ç‡åçš„é‡‘é¢ï¼ˆnetï¼‰
        let gross: number
        let net: number
        
        if (itemFeeRate && itemFeeRate > 0 && itemFeeRate <= 1) {
          // æœ‰å•ç¬”è´¹ç‡ï¼šæ•°æ®åº“ä¸­çš„amountå·²ç»æ˜¯æ‰£é™¤è´¹ç‡åçš„ï¼Œéœ€è¦è¿˜åŸåŸå§‹é‡‘é¢
          gross = amount / itemFeeRate
          net = amount // å·²ç»æ˜¯æ‰£é™¤è´¹ç‡åçš„
        } else {
          // æ²¡æœ‰å•ç¬”è´¹ç‡ï¼šä½¿ç”¨ç¾¤ç»„è´¹ç‡
          gross = amount
          net = amount - (amount * (feePercent || 0)) / 100
        }
        
        const r = i.rate ? Number(i.rate) : rateB
        // ğŸ”¥ ä¿®å¤ï¼šUSDTè®¡ç®—ä½¿ç”¨æ‰£é™¤è´¹ç‡åçš„é‡‘é¢ï¼ˆnetï¼‰
        const usdt = r ? Number((Math.abs(net) / r).toFixed(2)) * (net < 0 ? -1 : 1) : 0
        return {
          time: formatTimeLocal(i.createdAt as Date),
          amount: `${gross}${r ? ` / ${r}=${usdt}` : ''}`, // ğŸ”¥ ä¿®å¤ï¼šæ˜¾ç¤ºåŸå§‹é‡‘é¢gross
          amountValue: gross,
          rate: (i.rate ? Number(i.rate) : null),
          replier: i.replier || '',
          operator: i.operator || '',
          remark: i.remark || null, // ğŸ”¥ æ·»åŠ å¤‡æ³¨å­—æ®µ
        }
      })
      const dispatchRecordsSaved = disps.map((d: any) => ({
        time: formatTimeLocal(d.createdAt as Date),
        amount: `${d.amount}`,
        remark: d.remark || '', // ğŸ”¥ æ·»åŠ å¤‡æ³¨å­—æ®µ
        replier: d.replier || '',
        operator: d.operator || '',
      }))
      // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šè®¡ç®—ä»Šæ—¥å…¥æ¬¾ï¼ˆå½“æ—¥åˆ‡æ—¥å†…çš„å…¥æ¬¾ï¼‰
      let todayIncome = tIncome // é»˜è®¤ç­‰äºæ€»å…¥æ¬¾
      if (isCumulativeMode) {
        // è®¡ç®—å½“æ—¥åˆ‡æ—¶é—´èŒƒå›´
        const todayStart = dateStr ? startOfDateRange(dateStr, cutoffHour) : gte
        const todayEnd = dateStr ? endOfDateRange(dateStr, cutoffHour) : lt
        
        // åªè®¡ç®—åœ¨å½“æ—¥åˆ‡æ—¶é—´èŒƒå›´å†…çš„å…¥æ¬¾
        todayIncome = 0
        for (const inc of incs) {
          const itemDate = new Date(inc.createdAt)
          if (itemDate >= todayStart && itemDate < todayEnd) {
            const amount = Number(inc.amount) || 0
            const itemFeeRate = inc.feeRate ? Number(inc.feeRate) : null
            
            if (itemFeeRate && itemFeeRate > 0 && itemFeeRate <= 1) {
              // æœ‰å•ç¬”è´¹ç‡ï¼šè¿˜åŸåŸå§‹é‡‘é¢
              todayIncome += amount / itemFeeRate
            } else {
              // æ²¡æœ‰å•ç¬”è´¹ç‡ï¼šç›´æ¥ä½¿ç”¨é‡‘é¢
              todayIncome += amount
            }
          }
        }
      }
      
      billsAgg.push({
        totalIncome: tIncome, // è¿™ä¸ªè´¦å•çš„æ€»å…¥æ¬¾
        todayIncome: todayIncome, // ğŸ”¥ ä»Šæ—¥å…¥æ¬¾ï¼ˆå½“æ—¥åˆ‡æ—¥å†…çš„å…¥æ¬¾ï¼Œç´¯è®¡æ¨¡å¼ä½¿ç”¨ï¼‰
        exchangeRate: rateB,
        feeRate: feePercent,
        shouldDispatch: shouldB,
        shouldDispatchUSDT: toUSDTB(shouldB),
        dispatched: tDisp,
        dispatchedUSDT: toUSDTB(tDisp),
        // ğŸ”¥ ä¿®å¤ï¼šæ”¯æŒè´Ÿæ•°ï¼Œä¸å¼ºåˆ¶ä¸º0
        notDispatched: shouldB - tDisp,
        notDispatchedUSDT: toUSDTB(shouldB - tDisp),
      })
      billsRecords.push({ incomeRecords: incomeRecordsSaved, dispatchRecords: dispatchRecordsSaved })
    }

    // Determine selected bill (1-based). Default latest.
    let selIdx = billsAgg.length ? (billsAgg.length - 1) : 0
    if (billIndexParam) {
      const v = Math.max(1, Math.min(Number(billIndexParam) || 1, billsAgg.length))
      selIdx = v - 1
    }
    const selectedBillAgg = billsAgg[selIdx] || {
      totalIncome: 0,
      exchangeRate: settings?.fixedRate ?? settings?.realtimeRate ?? 0,
      feeRate: settings?.feePercent ?? 0,
      shouldDispatch: 0,
      shouldDispatchUSDT: 0,
      dispatched: 0,
      dispatchedUSDT: 0,
      notDispatched: 0,
      notDispatchedUSDT: 0,
    }
    const incomeRecords = billsRecords[selIdx]?.incomeRecords || []
    const dispatchRecords = billsRecords[selIdx]?.dispatchRecords || []

    // Build breakdowns based on selected bill
    const incomeByReplier: Record<string, number> = {}
    const incomeByOperator: Record<string, number> = {}
    const incomeByRate: Record<string, number> = {}
    const selectedBillId = billsData[selIdx]?.id
    const selectedBill = billsData[selIdx] // ğŸ”¥ æ·»åŠ é€‰ä¸­çš„è´¦å•ä¿¡æ¯
    const selItems = selectedBillId ? (itemsByBillId.get(selectedBillId) || []) : []
    // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šå•æ¬¡éå†åŒæ—¶åˆ†ç±»å’Œç»Ÿè®¡ï¼Œå‡å°‘å†…å­˜åˆ†é…
    const dispatchByOperator: Record<string, number> = {}
    for (const item of selItems) {
      const amount = Number(item.amount) || 0
      if (item.type === 'INCOME') {
        const rate = Number(item.rate || 0) || undefined
        if (item.replier) incomeByReplier[item.replier] = (incomeByReplier[item.replier] || 0) + amount
        if (item.operator) incomeByOperator[item.operator] = (incomeByOperator[item.operator] || 0) + amount
        if (rate) incomeByRate[rate.toString()] = (incomeByRate[rate.toString()] || 0) + amount
      } else if (item.type === 'DISPATCH') {
        // ä¼˜å…ˆä½¿ç”¨operatorï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨replierä½œä¸ºåå¤‡
        const operator = item.operator || item.replier || 'æœªçŸ¥'
        if (operator) dispatchByOperator[operator] = (dispatchByOperator[operator] || 0) + amount
      }
    }

    const selected = selectedBillAgg

    // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šæ¯ä¸ªè´¦å•ç‹¬ç«‹è®¡ç®—
    let cumulativeTotalIncome = selected.totalIncome // é»˜è®¤ç­‰äºä»Šæ—¥å…¥æ¬¾ï¼ˆéç´¯è®¡æ¨¡å¼ï¼‰
    let billLabels: string[] = [] // ğŸ”¥ è´¦å•æ ‡ç­¾ï¼ˆç”¨äºæ˜¾ç¤º"ç¬¬Xç¬”"ï¼‰
    
    if (isCumulativeMode) {
      // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šç®€å•çš„"ç¬¬Xç¬”"æ ‡ç­¾
      billLabels = billsData.map((bill: any, idx: number) => {
        return `ç¬¬ ${idx + 1} ç¬”`
      })
      cumulativeTotalIncome = selected.totalIncome
    } else {
      // éç´¯è®¡æ¨¡å¼ï¼Œç”Ÿæˆæ™®é€šæ ‡ç­¾
      billLabels = billsData.map((_: any, idx: number) => `ç¬¬ ${idx + 1} ç¬”`)
    }

    return NextResponse.json({
      billNumber: billsAgg.length,
      bills: billsAgg,
      billLabels: billLabels, // ğŸ”¥ è´¦å•æ ‡ç­¾ï¼ˆç”¨äºæ˜¾ç¤º"æ˜¨æ—¥ç¬¬Xç¬”è®¢å•"ï¼‰
      ...selected,
      ...(isCumulativeMode
        ? {
            // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šè¿”å›è¿™ä¸ªè´¦å•çš„æ€»å…¥æ¬¾å’Œä»Šæ—¥å…¥æ¬¾
            todayIncome: selected.todayIncome ?? selected.totalIncome, // ğŸ”¥ ä»Šæ—¥å…¥æ¬¾ï¼ˆå½“æ—¥åˆ‡æ—¥å†…çš„å…¥æ¬¾ï¼‰
            totalIncome: selected.totalIncome, // ğŸ”¥ è¿™ä¸ªè´¦å•çš„æ€»å…¥æ¬¾é‡‘é¢ï¼ˆä¸æ˜¯ç´¯è®¡æ€»å…¥æ¬¾ï¼‰
            shouldDispatch: selected.shouldDispatch || 0,
            shouldDispatchUSDT: selected.shouldDispatchUSDT || 0,
            notDispatched: selected.notDispatched || 0,
            notDispatchedUSDT: selected.notDispatchedUSDT || 0,
          }
        : {}),
      selectedBillIndex: selIdx + 1,
      selectedBillId: selectedBillId, // ğŸ”¥ æ·»åŠ é€‰ä¸­çš„è´¦å•IDï¼Œç”¨äºåˆ é™¤
      incomeRecords,
      dispatchRecords,
      incomeByReplier,
      incomeByOperator,
      incomeByRate,
      dispatchByOperator, // ğŸ”¥ æ”¹ä¸ºæŒ‰æ“ä½œäººåˆ†ç±»
      // ğŸ”¥ è¿”å›å®é™…çš„æ—¥æœŸèŒƒå›´ï¼ˆè€ƒè™‘æ—¥åˆ‡æ—¶é—´ï¼‰
      // æ³¨æ„ï¼šDateå¯¹è±¡ä¼šè¢«JSONåºåˆ—åŒ–ä¸ºISOå­—ç¬¦ä¸²ï¼ˆUTCï¼‰ï¼Œå‰ç«¯è§£ææ—¶ä¼šè‡ªåŠ¨è½¬æ¢ä¸ºæœ¬åœ°æ—¶é—´
      dateRangeStart: gte.toISOString(),
      dateRangeEnd: lt.toISOString(),
      dailyCutoffHour: cutoffHour,
      // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šè¿”å›è´¦å•çš„å¼€å§‹å’Œç»“æŸæ—¶é—´
      ...(isCumulativeMode && billsData[selIdx] ? {
        billStartTime: billsData[selIdx].openedAt.toISOString(),
        billEndTime: billsData[selIdx].status === 'OPEN' 
          ? new Date().toISOString() // ğŸ”¥ æœ€æ–°è´¦å•æ˜¾ç¤ºå½“å‰æœåŠ¡å™¨æ—¶é—´
          : (billsData[selIdx].closedAt?.toISOString() || billsData[selIdx].openedAt.toISOString()), // ğŸ”¥ å·²ä¿å­˜è´¦å•æ˜¾ç¤ºclosedAt
        hasPreviousBill: selIdx > 0, // ğŸ”¥ æ˜¯å¦æœ‰ä¸Šä¸€ç¬”è´¦å•
        hasNextBill: selIdx < billsData.length - 1, // ğŸ”¥ æ˜¯å¦æœ‰ä¸‹ä¸€ç¬”è´¦å•
        totalBills: billsData.length, // ğŸ”¥ æ€»è´¦å•æ•°
      } : {}),
    })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

/**
 * è·å–å½“å‰åº”è¯¥æŸ¥çœ‹çš„æ—¥æœŸï¼ˆåŸºäºæ—¥åˆ‡æ—¶é—´ï¼‰
 * å¦‚æœç°åœ¨æ˜¯4å·1:12ï¼Œæ—¥åˆ‡æ˜¯2ç‚¹ï¼Œè¿”å›3å·çš„æ—¥æœŸå­—ç¬¦ä¸²
 */
export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'stats_current_date', 60, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { searchParams } = new URL(req.url)
    const chatIdParam = searchParams.get('chatId')
    
    // è·å–chatId
    let chatId = chatIdParam || ''
    if (!chatId) {
      const latestBill = await prisma.bill.findFirst({ orderBy: { savedAt: 'desc' } })
      chatId = latestBill?.chatId || ''
    }
    
    if (!chatId) {
      // å¦‚æœæ²¡æœ‰chatIdï¼Œè¿”å›ä»Šå¤©çš„æ—¥æœŸ
      const today = new Date()
      const year = today.getFullYear()
      const month = String(today.getMonth() + 1).padStart(2, '0')
      const day = String(today.getDate()).padStart(2, '0')
      return NextResponse.json({ date: `${year}-${month}-${day}` })
    }

    // ğŸ”¥ è·å–æ—¥åˆ‡æ—¶é—´è®¾ç½®
    const settings = await prisma.setting.findUnique({
      where: { chatId },
      select: { dailyCutoffHour: true }
    })

    // ğŸ”¥ ä½¿ç”¨æ—¥åˆ‡æ—¶é—´è®¡ç®—å½“å‰åº”è¯¥æŸ¥çœ‹çš„æ—¥æœŸ
    let cutoffHour = 0 // é»˜è®¤å€¼
    if (settings?.dailyCutoffHour != null && settings.dailyCutoffHour >= 0 && settings.dailyCutoffHour <= 23) {
      cutoffHour = settings.dailyCutoffHour
    } else {
      // ğŸ”¥ æŸ¥è¯¢å…¨å±€é…ç½®è·å–é»˜è®¤æ—¥åˆ‡æ—¶é—´
      try {
        const globalConfig = await prisma.globalConfig.findUnique({
          where: { key: 'daily_cutoff_hour' },
          select: { value: true }
        })
        if (globalConfig?.value) {
          const hour = parseInt(globalConfig.value, 10)
          if (!isNaN(hour) && hour >= 0 && hour <= 23) {
            cutoffHour = hour
          }
        }
      } catch (e) {
        // æŸ¥è¯¢å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤å€¼0
        console.error('[stats/current-date] æŸ¥è¯¢å…¨å±€æ—¥åˆ‡æ—¶é—´å¤±è´¥:', e)
      }
    }

    // è®¡ç®—å½“å‰åº”è¯¥æŸ¥çœ‹çš„æ—¥æœŸ
    const now = new Date()
    const todayCutoff = new Date()
    todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
    todayCutoff.setHours(cutoffHour, 0, 0, 0)
    
    let targetDate: Date
    if (now >= todayCutoff) {
      // å½“å‰æ—¶é—´ >= ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œåº”è¯¥æŸ¥çœ‹ä»Šå¤©
      targetDate = now
    } else {
      // å½“å‰æ—¶é—´ < ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œåº”è¯¥æŸ¥çœ‹æ˜¨å¤©
      targetDate = new Date(todayCutoff)
      targetDate.setDate(targetDate.getDate() - 1)
    }
    
    // æ ¼å¼åŒ–æ—¥æœŸå­—ç¬¦ä¸²
    const year = targetDate.getFullYear()
    const month = String(targetDate.getMonth() + 1).padStart(2, '0')
    const day = String(targetDate.getDate()).padStart(2, '0')
    
    return NextResponse.json({ date: `${year}-${month}-${day}` })
  } catch (e) {
    console.error('[stats/current-date] é”™è¯¯:', e)
    // å‡ºé”™æ—¶è¿”å›ä»Šå¤©çš„æ—¥æœŸ
    const today = new Date()
    const year = today.getFullYear()
    const month = String(today.getMonth() + 1).padStart(2, '0')
    const day = String(today.getDate()).padStart(2, '0')
    return NextResponse.json({ date: `${year}-${month}-${day}` })
  }
}
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/db'
import { assertAdmin, rateLimit } from '@/app/api/_auth'

function startOfDay(d: Date) {
  const x = new Date(d)
  x.setHours(0, 0, 0, 0)
  return x
}
function addDays(d: Date, n: number) {
  const x = new Date(d)
  x.setDate(x.getDate() + n)
  return x
}

export async function GET(req: NextRequest) {
  try {
    const unauth = assertAdmin(req)
    if (unauth) return unauth
    const rl = rateLimit(req, 'stats_30d', 60, 60 * 1000)
    if (!rl.ok) return NextResponse.json({ error: `Too many requests. Retry after ${rl.retryAfter}s` }, { status: 429 })
    const { searchParams } = new URL(req.url)
    const chatIdParam = searchParams.get('chatId')
    const endStr = searchParams.get('end') // YYYY-MM-DD (inclusive end)

    const today = endStr ? new Date(endStr) : new Date()
    const end = startOfDay(today)
    const start = startOfDay(addDays(end, -29))

    // pick chatId: prefer latest bill if not given
    let chatId = chatIdParam || ''
    if (!chatId) {
      const latestBill = await prisma.bill.findFirst({ orderBy: { savedAt: 'desc' } })
      chatId = latestBill?.chatId || ''
    }
    if (!chatId) {
      return NextResponse.json({
        totalIncome: 0,
        totalIncomeUSDT: 0,
        totalDispatch: 0,
        totalDispatchUSDT: 0,
        totalBills: 0,
        averageRate: 0,
        averageFee: 0,
        notDispatched: 0,
        notDispatchedUSDT: 0,
      })
    }

    const [settings, bills] = await Promise.all([
      prisma.setting.findUnique({ where: { chatId } }),
      prisma.bill.findMany({ where: { chatId, savedAt: { gte: start, lt: addDays(end, 1) } }, orderBy: { savedAt: 'asc' } }),
    ])

    const billIds = bills.map((b: any) => b.id)
    const items = billIds.length
      ? await prisma.billItem.findMany({ where: { billId: { in: billIds } } })
      : []

    const incomeItems = items.filter((i: any) => i.type === 'INCOME')
    const dispatchItems = items.filter((i: any) => i.type === 'DISPATCH')

    const totalIncome = incomeItems.reduce((s: number, i: any) => s + (Number(i.amount) || 0), 0)
    const totalDispatch = dispatchItems.reduce((s: number, d: any) => s + (Number(d.amount) || 0), 0)

    const feeRate = settings?.feePercent ?? 0
    const fixedRate = settings?.fixedRate ?? null
    const realtimeRate = settings?.realtimeRate ?? null
    let rate = fixedRate ?? realtimeRate ?? 0
    if (!rate) {
      const lastIncomeWithRate = [...incomeItems].reverse().find((i: any) => i.rate && i.rate > 0)
      if (lastIncomeWithRate?.rate) rate = Number(lastIncomeWithRate.rate)
    }

    const fee = (totalIncome * feeRate) / 100
    const shouldDispatch = Math.max(totalIncome - fee, 0)

    const toUSDT = (rmb: number) => (rate ? Number((rmb / rate).toFixed(2)) : 0)

    const totalIncomeUSDT = toUSDT(totalIncome)
    const totalDispatchUSDT = toUSDT(totalDispatch)
    const notDispatched = Math.max(shouldDispatch - totalDispatch, 0)
    const notDispatchedUSDT = toUSDT(notDispatched)

    return NextResponse.json({
      totalIncome,
      totalIncomeUSDT,
      totalDispatch,
      totalDispatchUSDT,
      totalBills: incomeItems.length,
      averageRate: rate,
      averageFee: feeRate,
      notDispatched,
      notDispatchedUSDT,
    })
  } catch (e) {
    console.error(e)
    return NextResponse.json({ error: 'Server error' }, { status: 500 })
  }
}
export async function GET() {
  return new Response('weekly endpoint removed', { status: 410 })
}
"use client"

import { useEffect, useState } from "react"
import { useRouter, useParams } from "next/navigation"
import { useToast } from "@/hooks/use-toast"

type AccountingMode = 'DAILY_RESET' | 'CARRY_OVER' | 'SINGLE_BILL_PER_DAY'

interface ChatSettings {
  chat: {
    id: string
    title: string
  }
  settings: {
    accountingMode: AccountingMode
    featureWarningMode?: string
    addressVerificationEnabled?: boolean
    dailyCutoffHour?: number
    hideHelpButton?: boolean
    hideOrderButton?: boolean
    deleteBillConfirm?: boolean // ğŸ”¥ åˆ é™¤è´¦å•ç¡®è®¤åŠŸèƒ½
  }
}

interface Operator {
  id: string
  username: string
  chatId: string
}

export default function ChatSettingsPage() {
  const router = useRouter()
  const params = useParams()
  const chatId = params?.id as string
  const { toast } = useToast()

  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [chatSettings, setChatSettings] = useState<ChatSettings | null>(null)
  const [operators, setOperators] = useState<Operator[]>([])
  
  // è®¾ç½®è¡¨å•çŠ¶æ€
  const [accountingMode, setAccountingMode] = useState<AccountingMode>('DAILY_RESET')
  const [featureWarningMode, setFeatureWarningMode] = useState<string>('always')
  const [addressVerificationEnabled, setAddressVerificationEnabled] = useState<boolean>(false)
  const [dailyCutoffHour, setDailyCutoffHour] = useState<number>(0)
  const [hideHelpButton, setHideHelpButton] = useState<boolean>(false)
  const [hideOrderButton, setHideOrderButton] = useState<boolean>(false)
  const [deleteBillConfirm, setDeleteBillConfirm] = useState<boolean>(false) // ğŸ”¥ åˆ é™¤è´¦å•ç¡®è®¤åŠŸèƒ½
  
  // æ“ä½œäººç®¡ç†çŠ¶æ€
  const [newOperator, setNewOperator] = useState('')
  const [addingOperator, setAddingOperator] = useState(false)
  const [deletingOperator, setDeletingOperator] = useState<string | null>(null)

  // åŠ è½½è®¾ç½®å’Œæ“ä½œäºº
  useEffect(() => {
    if (!chatId) return
    loadSettings()
    loadOperators()
  }, [chatId])

  const loadSettings = async () => {
    try {
      setLoading(true)
      const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/settings`)
      if (res.ok) {
        const data: ChatSettings = await res.json()
        setChatSettings(data)
        
        // åˆå§‹åŒ–è¡¨å•
        setAccountingMode(data.settings.accountingMode)
        setFeatureWarningMode(data.settings.featureWarningMode || 'always')
        setAddressVerificationEnabled(data.settings.addressVerificationEnabled || false)
        setDailyCutoffHour(data.settings.dailyCutoffHour ?? 0)
        setHideHelpButton(data.settings.hideHelpButton ?? false)
        setHideOrderButton(data.settings.hideOrderButton ?? false)
        setDeleteBillConfirm(data.settings.deleteBillConfirm ?? false)
      } else {
        toast({
          variant: "destructive",
          title: "åŠ è½½å¤±è´¥",
          description: "æ— æ³•åŠ è½½ç¾¤ç»„è®¾ç½®ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•",
        })
      }
    } catch (e) {
      console.error(e)
      toast({
        variant: "destructive",
        title: "åŠ è½½å¤±è´¥",
        description: "ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥åé‡è¯•",
      })
    } finally {
      setLoading(false)
    }
  }

  const loadOperators = async () => {
    try {
      const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/operators`)
      if (res.ok) {
        const data = await res.json()
        setOperators(data.items || [])
      }
    } catch (e) {
      console.error(e)
    }
  }

  // ä¿å­˜è®¾ç½®ï¼ˆä¼˜åŒ–ï¼šä¿å­˜æˆåŠŸåä¸é‡æ–°åŠ è½½ï¼Œåªæ›´æ–°æœ¬åœ°çŠ¶æ€ï¼‰
  const handleSaveSettings = async () => {
    try {
      setSaving(true)
      
      const payload = {
        accountingMode,
        featureWarningMode,
        addressVerificationEnabled,
        dailyCutoffHour,
        hideHelpButton,
        hideOrderButton,
        deleteBillConfirm,
      }

      // ğŸ”¥ æ·»åŠ è¶…æ—¶æ§åˆ¶ï¼Œé¿å…é•¿æ—¶é—´ç­‰å¾…
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 10000) // 10ç§’è¶…æ—¶

      const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/settings`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        signal: controller.signal
      })

      clearTimeout(timeoutId)

      if (res.ok) {
        // ğŸ”¥ ä¿å­˜æˆåŠŸåä¸é‡æ–°åŠ è½½ï¼Œåªæ›´æ–°æœ¬åœ°çŠ¶æ€ï¼Œæå‡å“åº”é€Ÿåº¦
        try {
          const data = await res.json()
          // APIè¿”å›çš„æ ¼å¼æ˜¯ { ok: true, settings: {...} }
          if (data.ok && data.settings) {
            setChatSettings(prev => prev ? {
              ...prev,
              settings: {
                ...prev.settings,
                accountingMode: data.settings.accountingMode || accountingMode,
                featureWarningMode: data.settings.featureWarningMode || featureWarningMode,
                addressVerificationEnabled: data.settings.addressVerificationEnabled ?? addressVerificationEnabled,
                dailyCutoffHour: data.settings.dailyCutoffHour ?? dailyCutoffHour,
                hideHelpButton: data.settings.hideHelpButton ?? hideHelpButton,
                hideOrderButton: data.settings.hideOrderButton ?? hideOrderButton,
              }
            } : prev)
          }
        } catch (parseError) {
          console.error('è§£æå“åº”å¤±è´¥', parseError)
          // å³ä½¿è§£æå¤±è´¥ï¼Œä¹Ÿè®¤ä¸ºä¿å­˜æˆåŠŸï¼ˆå› ä¸ºres.okä¸ºtrueï¼‰
        }
        
        toast({
          title: "ä¿å­˜æˆåŠŸ",
          description: "è®¾ç½®å·²ä¿å­˜",
        })
      } else {
        const errorText = await res.text().catch(() => 'ä¿å­˜å¤±è´¥')
        toast({
          title: "ä¿å­˜å¤±è´¥",
          description: errorText || "è¯·ç¨åé‡è¯•",
        })
      }
    } catch (e: any) {
      console.error(e)
      if (e.name === 'AbortError') {
        toast({
          title: "è¯·æ±‚è¶…æ—¶",
          description: "ä¿å­˜è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•",
        })
      } else {
        toast({
          title: "ä¿å­˜å¤±è´¥",
          description: e.message || "ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•",
        })
      }
    } finally {
      setSaving(false)
    }
  }

  // æ·»åŠ æ“ä½œäºº
  const handleAddOperator = async () => {
    if (!newOperator.trim()) {
      toast({
        variant: "destructive",
        title: "è¾“å…¥é”™è¯¯",
        description: "è¯·è¾“å…¥ç”¨æˆ·å",
      })
      return
    }

    try {
      setAddingOperator(true)
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 8000)
      
      const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/operators`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username: newOperator }),
        signal: controller.signal
      })

      clearTimeout(timeoutId)

      if (res.ok) {
        const data = await res.json()
        const addedUsername = newOperator // ä¿å­˜ç”¨æˆ·åï¼Œå› ä¸ºåé¢ä¼šæ¸…ç©º
        setOperators(data.items || [])
        setNewOperator('')
        toast({
          title: "æ·»åŠ æˆåŠŸ",
          description: `å·²æ·»åŠ æ“ä½œäºº ${addedUsername}`,
        })
      } else {
        const errorText = await res.text().catch(() => 'æ·»åŠ å¤±è´¥')
        toast({
          variant: "destructive",
          title: "æ·»åŠ å¤±è´¥",
          description: errorText || "è¯·ç¨åé‡è¯•",
        })
      }
    } catch (e: any) {
      console.error(e)
      if (e.name === 'AbortError') {
        toast({
          variant: "destructive",
          title: "è¯·æ±‚è¶…æ—¶",
          description: "è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•",
        })
      } else {
        toast({
          variant: "destructive",
          title: "æ·»åŠ å¤±è´¥",
          description: e.message || "ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•",
        })
      }
    } finally {
      setAddingOperator(false)
    }
  }

  // åˆ é™¤æ“ä½œäºº
  const handleDeleteOperator = async (username: string) => {
    // ğŸ”¥ ä½¿ç”¨toastç¡®è®¤å¯¹è¯æ¡†æ›¿ä»£confirm
    const confirmed = window.confirm(`ç¡®å®šåˆ é™¤æ“ä½œäºº ${username} å—ï¼Ÿ`)
    if (!confirmed) return

    try {
      setDeletingOperator(username)
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 8000)
      
      const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/operators`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username }),
        signal: controller.signal
      })

      clearTimeout(timeoutId)

      if (res.ok) {
        const data = await res.json()
        setOperators(data.items || [])
        toast({
          title: "åˆ é™¤æˆåŠŸ",
          description: `å·²åˆ é™¤æ“ä½œäºº ${username}`,
        })
      } else {
        const errorText = await res.text().catch(() => 'åˆ é™¤å¤±è´¥')
        toast({
          variant: "destructive",
          title: "åˆ é™¤å¤±è´¥",
          description: errorText || "è¯·ç¨åé‡è¯•",
        })
      }
    } catch (e: any) {
      console.error(e)
      if (e.name === 'AbortError') {
        toast({
          variant: "destructive",
          title: "è¯·æ±‚è¶…æ—¶",
          description: "è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•",
        })
      } else {
        toast({
          variant: "destructive",
          title: "åˆ é™¤å¤±è´¥",
          description: e.message || "ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•",
        })
      }
    } finally {
      setDeletingOperator(null)
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-gray-600">åŠ è½½ä¸­...</div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="max-w-6xl mx-auto p-4 md:p-6">
        {/* å¤´éƒ¨ */}
        <div className="mb-4">
          <button
            onClick={() => router.back()}
            className="mb-3 px-3 py-1 text-sm border rounded hover:bg-gray-100"
          >
            â† è¿”å›
          </button>
          <h1 className="text-xl md:text-2xl font-bold text-gray-900">
            ç¾¤ç»„è®¾ç½®
          </h1>
          {chatSettings && (
            <p className="text-sm md:text-base text-gray-600 mt-1">
              {chatSettings.chat.title || chatSettings.chat.id}
            </p>
          )}
        </div>

        {/* ğŸ”¥ ä¼˜åŒ–çš„ç®€æ´ç•Œé¢ï¼šä½¿ç”¨ç½‘æ ¼å¸ƒå±€ï¼Œæ‰€æœ‰é€‰é¡¹ä¸€ç›®äº†ç„¶ */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
          {/* è®°è´¦æ¨¡å¼ */}
          <div className="bg-white border rounded-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-base font-semibold">ğŸ“Š è®°è´¦æ¨¡å¼</h3>
              <span className={`text-xs px-2 py-1 rounded ${
                accountingMode === 'DAILY_RESET' ? 'bg-blue-100 text-blue-700' : 
                accountingMode === 'CARRY_OVER' ? 'bg-green-100 text-green-700' : 
                'bg-purple-100 text-purple-700'
              }`}>
                {accountingMode === 'DAILY_RESET' ? 'æ¯æ—¥æ¸…é›¶' : 
                 accountingMode === 'CARRY_OVER' ? 'ç´¯è®¡æ¨¡å¼' : 
                 'å•ç¬”è®¢å•'}
              </span>
            </div>
            <div className="space-y-2">
              <label className="flex items-center space-x-2 cursor-pointer">
                <input
                  type="radio"
                  name="accountingMode"
                  value="DAILY_RESET"
                  checked={accountingMode === 'DAILY_RESET'}
                  onChange={(e) => setAccountingMode(e.target.value as AccountingMode)}
                  className="w-4 h-4"
                />
                <span className="text-sm">ğŸ”„ æ¯æ—¥æ¸…é›¶ï¼ˆæ¯æ—¥ç‹¬ç«‹ç»“ç®—ï¼‰</span>
              </label>
              <label className="flex items-center space-x-2 cursor-pointer">
                <input
                  type="radio"
                  name="accountingMode"
                  value="CARRY_OVER"
                  checked={accountingMode === 'CARRY_OVER'}
                  onChange={(e) => setAccountingMode(e.target.value as AccountingMode)}
                  className="w-4 h-4"
                />
                <span className="text-sm">ğŸ“ˆ ç´¯è®¡æ¨¡å¼ï¼ˆæŒç»­ç´¯è®¡æœªä¸‹å‘ï¼‰</span>
              </label>
              <label className="flex items-center space-x-2 cursor-pointer">
                <input
                  type="radio"
                  name="accountingMode"
                  value="SINGLE_BILL_PER_DAY"
                  checked={accountingMode === 'SINGLE_BILL_PER_DAY'}
                  onChange={(e) => setAccountingMode(e.target.value as AccountingMode)}
                  className="w-4 h-4"
                />
                <span className="text-sm">ğŸ“‹ å•ç¬”è®¢å•ï¼ˆæ¯å¤©åªæœ‰ä¸€ç¬”ï¼Œä¸æ”¯æŒä¿å­˜ï¼‰</span>
              </label>
              <div className="mt-3 space-y-2 text-xs text-slate-600 leading-relaxed">
                <p>ğŸ’¡ <strong>æ¯æ—¥æ¸…é›¶ï¼š</strong> æ¯ä¸ªæ—¥åˆ‡å‘¨æœŸéƒ½ä¼šç”Ÿæˆå…¨æ–°çš„è´¦å•ï¼Œå†å²è´¦å•ä¸ä¼šå‚ä¸å½“æ—¥è®¡ç®—ï¼Œä¹Ÿä¸ä¼šç´¯è®¡æœªä¸‹å‘é‡‘é¢ã€‚æ”¯æŒè®¾ç½®æ—¥åˆ‡æ—¶é—´ã€‚</p>
                <p>ğŸ’¡ <strong>ç´¯è®¡æ¨¡å¼ï¼š</strong> å½“å‰è´¦å•ä¼šè‡ªåŠ¨å åŠ æ‰€æœ‰æ›´æ—©è´¦å•çš„æœªä¸‹å‘é‡‘é¢ï¼›åˆ é™¤è´¦å•æ—¶ä¼šåŒæ­¥åˆ é™¤è¯¥è´¦å•çš„å…¨éƒ¨æµæ°´ï¼Œåç»­è´¦å•çš„å†å²æ•°æ®ä¹Ÿä¼šéšä¹‹å›æ”¶ã€‚ä¸æ”¯æŒè®¾ç½®æ—¥åˆ‡æ—¶é—´ï¼Œè´¦å•æŒ‰ä¿å­˜æ—¶é—´è‡ªåŠ¨åˆ›å»ºã€‚</p>
                <p>ğŸ’¡ <strong>å•ç¬”è®¢å•ï¼š</strong> æ¯å¤©åªæœ‰ä¸€ç¬”è®¢å•ï¼Œä¸æ”¯æŒä¿å­˜è´¦å•ï¼Œä½†æ”¯æŒåˆ é™¤è´¦å•ã€‚æ—¥åˆ‡æ—¶ä¼šè‡ªåŠ¨å…³é—­æ˜¨å¤©çš„è´¦å•ï¼Œæ¯å¤©å•ç‹¬è®°è´¦ã€‚æ”¯æŒè®¾ç½®æ—¥åˆ‡æ—¶é—´ã€‚</p>
              </div>
            </div>
          </div>

          {/* åŠŸèƒ½æç¤ºé¢‘ç‡ */}
          <div className="bg-white border rounded-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-base font-semibold">ğŸ”” åŠŸèƒ½æç¤º</h3>
              <span className="text-xs text-gray-500">
                {featureWarningMode === 'always' ? 'æ¯æ¬¡' : featureWarningMode === 'daily' ? 'æ¯å¤©ä¸€æ¬¡' : featureWarningMode === 'once' ? 'åªä¸€æ¬¡' : 'é™é»˜'}
              </span>
            </div>
            <select
              value={featureWarningMode}
              onChange={(e) => setFeatureWarningMode(e.target.value)}
              className="w-full p-2 text-sm border rounded"
            >
              <option value="always">ğŸ” æ¯æ¬¡æç¤ºï¼ˆé»˜è®¤ï¼‰</option>
              <option value="daily">ğŸ“… æ¯å¤©ä¸€æ¬¡</option>
              <option value="once">1ï¸âƒ£ åªæç¤ºä¸€æ¬¡</option>
              <option value="silent">ğŸ”‡ é™é»˜æ¨¡å¼ï¼ˆå¤šæœºå™¨äººåä½œï¼‰</option>
            </select>
            <p className="text-xs text-gray-500 mt-2">
              ğŸ’¡ æ§åˆ¶åŠŸèƒ½å…³é—­æ—¶çš„æé†’é¢‘ç‡ã€‚ä¾‹å¦‚ï¼šè®¡ç®—å™¨å…³é—­ã€è®°è´¦æš‚åœç­‰åŠŸèƒ½æç¤ºçš„æ˜¾ç¤ºæ–¹å¼ã€‚
              <br />
              â€¢ æ¯æ¬¡æç¤ºï¼šæ¯æ¬¡ä½¿ç”¨éƒ½ä¼šæé†’
              <br />
              â€¢ æ¯å¤©ä¸€æ¬¡ï¼šæ¯å¤©åªæé†’ä¸€æ¬¡
              <br />
              â€¢ åªæç¤ºä¸€æ¬¡ï¼šåªæé†’ä¸€æ¬¡ï¼Œä¹‹åä¸å†æé†’
              <br />
              â€¢ é™é»˜æ¨¡å¼ï¼šä¸æé†’ï¼Œé€‚åˆå¤šæœºå™¨äººç¾¤ç»„
            </p>
          </div>

          {/* æ—¥åˆ‡æ—¶é—´ */}
          <div className="bg-white border rounded-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-base font-semibold">â° æ—¥åˆ‡æ—¶é—´</h3>
              <span className="text-xs font-mono">{dailyCutoffHour.toString().padStart(2, '0')}:00</span>
            </div>
            <select
              value={dailyCutoffHour}
              onChange={(e) => setDailyCutoffHour(Number(e.target.value))}
              disabled={accountingMode === 'CARRY_OVER'}
              className={`w-full p-2 text-sm border rounded ${accountingMode === 'CARRY_OVER' ? 'bg-gray-100 cursor-not-allowed opacity-60' : ''}`}
            >
              {Array.from({ length: 13 }, (_, i) => (
                <option key={i} value={i}>
                  {i.toString().padStart(2, '0')}:00 {i === 0 ? 'ï¼ˆé»˜è®¤ï¼‰' : ''}
                </option>
              ))}
            </select>
            {accountingMode === 'CARRY_OVER' ? (
              <p className="text-xs text-amber-600 mt-2">âš ï¸ ç´¯è®¡æ¨¡å¼ä¸‹ä¸æ”¯æŒè®¾ç½®æ—¥åˆ‡æ—¶é—´ï¼Œè´¦å•æŒ‰ä¿å­˜æ—¶é—´è‡ªåŠ¨åˆ›å»º</p>
            ) : (
              <p className="text-xs text-gray-500 mt-2">ğŸ’¡ è®¾ç½®æ¯å¤©ç»“ç®—çš„èµ·å§‹æ—¶é—´ç‚¹</p>
            )}
          </div>

          {/* åœ°å€éªŒè¯ */}
          <div className="bg-white border rounded-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-base font-semibold">ğŸ” åœ°å€éªŒè¯</h3>
              <label className="relative inline-flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  checked={addressVerificationEnabled}
                  onChange={(e) => setAddressVerificationEnabled(e.target.checked)}
                  className="sr-only peer"
                />
                <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
              </label>
            </div>
            <p className="text-xs text-gray-600">è‡ªåŠ¨è¯†åˆ«å’ŒéªŒè¯ç¾¤å†…å‘é€çš„é’±åŒ…åœ°å€ï¼Œé˜²æ­¢åœ°å€è¢«ç¯¡æ”¹</p>
          </div>

          {/* ç•Œé¢è®¾ç½® */}
          <div className="bg-white border rounded-lg p-4 space-y-4">
            <h3 className="text-base font-semibold mb-3">ğŸ¨ æŒ‰é’®æ˜¾ç¤ºè®¾ç½®</h3>
            
            {/* éšè—ä½¿ç”¨è¯´æ˜æŒ‰é’® */}
            <div className="flex items-center justify-between">
              <div>
                <div className="text-sm font-medium text-gray-700">éšè—ä½¿ç”¨è¯´æ˜æŒ‰é’®</div>
                <p className="text-xs text-gray-500 mt-1">éšè—è´¦å•æ¶ˆæ¯ä¸­çš„"ä½¿ç”¨è¯´æ˜"æŒ‰é’®</p>
              </div>
              <label className="relative inline-flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  checked={hideHelpButton}
                  onChange={(e) => setHideHelpButton(e.target.checked)}
                  className="sr-only peer"
                />
                <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
              </label>
            </div>
            
            {/* éšè—æŸ¥çœ‹å®Œæ•´è®¢å•æŒ‰é’® */}
            <div className="flex items-center justify-between">
              <div>
                <div className="text-sm font-medium text-gray-700">éšè—æŸ¥çœ‹å®Œæ•´è®¢å•æŒ‰é’®</div>
                <p className="text-xs text-gray-500 mt-1">éšè—è´¦å•æ¶ˆæ¯ä¸­çš„"æŸ¥çœ‹å®Œæ•´è®¢å•"æŒ‰é’®</p>
              </div>
              <label className="relative inline-flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  checked={hideOrderButton}
                  onChange={(e) => setHideOrderButton(e.target.checked)}
                  className="sr-only peer"
                />
                <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
              </label>
            </div>
          </div>
          
          {/* ğŸ”¥ å®‰å…¨è®¾ç½® */}
          <div className="bg-white border rounded-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-base font-semibold">ğŸ”’ å®‰å…¨è®¾ç½®</h3>
            </div>
            
            {/* åˆ é™¤è´¦å•ç¡®è®¤ */}
            <div className="flex items-center justify-between">
              <div>
                <div className="text-sm font-medium text-gray-700">åˆ é™¤è´¦å•ç¡®è®¤</div>
                <p className="text-xs text-gray-500 mt-1">å‘é€"åˆ é™¤è´¦å•"åéœ€è¦äºŒæ¬¡ç¡®è®¤ï¼Œé˜²æ­¢è¯¯åˆ é™¤</p>
              </div>
              <label className="relative inline-flex items-center cursor-pointer">
                <input
                  type="checkbox"
                  checked={deleteBillConfirm}
                  onChange={(e) => setDeleteBillConfirm(e.target.checked)}
                  className="sr-only peer"
                />
                <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
              </label>
            </div>
          </div>
        </div>

        {/* æ“ä½œäººç®¡ç† */}
        <div className="bg-white border rounded-lg p-4 mb-6">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-base font-semibold">ğŸ‘¥ æ“ä½œäººç®¡ç†</h3>
            <span className="text-xs text-gray-500">å…± {operators.length} äºº</span>
          </div>
          
          {/* æ·»åŠ æ“ä½œäºº */}
          <div className="flex gap-2 mb-4">
            <input
              type="text"
              placeholder="è¾“å…¥ç”¨æˆ·åï¼ˆå¦‚ï¼š@username æˆ– usernameï¼‰"
              value={newOperator}
              onChange={(e) => setNewOperator(e.target.value)}
              onKeyPress={(e) => {
                if (e.key === 'Enter') {
                  handleAddOperator()
                }
              }}
              className="flex-1 px-3 py-2 text-sm border rounded focus:ring-2 focus:ring-blue-500"
            />
            <button
              onClick={handleAddOperator}
              disabled={addingOperator || !newOperator.trim()}
              className="px-4 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50"
            >
              {addingOperator ? 'æ·»åŠ ä¸­...' : 'â•'}
            </button>
          </div>

          {/* æ“ä½œäººåˆ—è¡¨ */}
          <div className="border rounded overflow-hidden">
            {operators.length === 0 ? (
              <div className="p-6 text-center text-sm text-gray-500">
                æš‚æ— æ“ä½œäººï¼Œè¯·æ·»åŠ 
              </div>
            ) : (
              <div className="divide-y">
                {operators.map((op) => (
                  <div key={op.id} className="flex items-center justify-between p-3 hover:bg-gray-50">
                    <span className="text-sm font-mono">{op.username}</span>
                    <button
                      onClick={() => handleDeleteOperator(op.username)}
                      disabled={deletingOperator === op.username}
                      className="px-3 py-1 text-xs bg-red-600 text-white rounded hover:bg-red-700 disabled:opacity-50"
                    >
                      {deletingOperator === op.username ? 'åˆ é™¤ä¸­...' : 'åˆ é™¤'}
                    </button>
                  </div>
                ))}
              </div>
            )}
          </div>
          <p className="text-xs text-gray-500 mt-3">ğŸ’¡ æ“ä½œäººå¯ä»¥æ‰§è¡Œè®°è´¦ã€ç»“ç®—ç­‰æ“ä½œã€‚åœ¨ç¾¤å†…æ·»åŠ åä¼šè‡ªåŠ¨åŒæ­¥ã€‚</p>
        </div>

        {/* ä¿å­˜æŒ‰é’® */}
        <div className="flex justify-end gap-3">
          <button
            onClick={() => router.back()}
            className="px-4 py-2 text-sm border rounded hover:bg-gray-100"
          >
            å–æ¶ˆ
          </button>
          <button
            onClick={handleSaveSettings}
            disabled={saving}
            className="px-6 py-2 text-sm bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 font-medium"
          >
            {saving ? 'ä¿å­˜ä¸­...' : 'ğŸ’¾ ä¿å­˜è®¾ç½®'}
          </button>
        </div>
      </div>
    </div>
  )
}
"use client"

import { useEffect } from "react"
import { useRouter } from "next/navigation"

export default function ChatsPage() {
  const router = useRouter()
  useEffect(() => {
    router.replace('/dashboard')
  }, [router])
  return null
}
import { LoginForm } from "@/components/login-form"

export default function Home() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 to-slate-100">
      <LoginForm />
    </div>
  )
}
"use client"

import { useEffect, useState } from "react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ArrowLeft, ChevronLeft, ChevronRight } from "lucide-react"

export default function WeeklyPage() {
  const router = useRouter()
  useEffect(() => {
    router.replace('/summary')
  }, [router])
  return null
  const [mounted, setMounted] = useState(false)
  const [currentWeekStart, setCurrentWeekStart] = useState<Date>(new Date())
  const [summary, setSummary] = useState<any | null>(null)

  useEffect(() => {
    setMounted(true)
    const token = localStorage.getItem("auth_token")
    if (!token) {
      router.push("/")
      return
    }

    // Set to start of current week (Monday)
    const today = new Date()
    const dayOfWeek = today.getDay()
    const diff = dayOfWeek === 0 ? -6 : 1 - dayOfWeek // Adjust when day is Sunday
    const monday = new Date(today)
    monday.setDate(today.getDate() + diff)
    monday.setHours(0, 0, 0, 0)
    setCurrentWeekStart(monday)
  }, [router])

  if (!mounted) {
    return null
  }

  const handlePreviousWeek = () => {
    const newDate = new Date(currentWeekStart)
    newDate.setDate(newDate.getDate() - 7)
    setCurrentWeekStart(newDate)
  }

  const handleNextWeek = () => {
    const newDate = new Date(currentWeekStart)
    newDate.setDate(newDate.getDate() + 7)
    setCurrentWeekStart(newDate)
  }

  const weekEnd = new Date(currentWeekStart)
  weekEnd.setDate(weekEnd.getDate() + 6)

  const formatDate = (date: Date) => {
    return date.toLocaleDateString("zh-CN", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    })
  }

  useEffect(() => {
    if (!mounted) return
    const controller = new AbortController()
    const load = async () => {
      try {
        const params = new URLSearchParams()
        params.set('start', currentWeekStart.toISOString().slice(0,10))
        const res = await fetch(`/api/stats/weekly?${params.toString()}`, { signal: controller.signal })
        if (!res.ok) throw new Error('failed')
        const json = await res.json()
        setSummary(json)
      } catch (e) {
        if ((e as any).name !== 'AbortError') console.error(e)
      }
    }
    load()
    return () => controller.abort()
  }, [mounted, currentWeekStart])

  if (!summary) return null

  return (
    <div className="min-h-screen bg-slate-50">
      <div className="container mx-auto px-4 py-6 max-w-7xl">
        <Card className="mb-6">
          <CardHeader>
            <div className="flex items-center justify-between flex-wrap gap-4">
              <CardTitle className="text-2xl font-bold">å‘¨è´¦å•æ±‡æ€»</CardTitle>
              <Button variant="outline" onClick={() => router.back()}>
                <ArrowLeft className="w-4 h-4 mr-2" />
                è¿”å›
              </Button>
            </div>
            <div className="flex items-center gap-2 mt-4">
              <Button variant="outline" size="sm" onClick={handlePreviousWeek}>
                <ChevronLeft className="w-4 h-4 mr-1" />
                ä¸Šä¸€å‘¨
              </Button>
              <div className="text-sm font-medium text-slate-700 px-4 py-2 bg-slate-100 rounded-md">
                {formatDate(currentWeekStart)} - {formatDate(weekEnd)}
              </div>
              <Button variant="outline" size="sm" onClick={handleNextWeek}>
                ä¸‹ä¸€å‘¨
                <ChevronRight className="w-4 h-4 ml-1" />
              </Button>
            </div>
          </CardHeader>
        </Card>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
          <Card>
            <CardHeader>
              <CardTitle className="text-base">æ€»å…¥æ¬¾é‡‘é¢</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-green-600">{summary.totalIncome.toLocaleString()}</div>
              <div className="text-sm text-slate-500 mt-2">{summary.totalIncomeUSDT.toFixed(2)} USDT</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">æ€»ä¸‹å‘é‡‘é¢</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-blue-600">{summary.totalDispatch.toLocaleString()}</div>
              <div className="text-sm text-slate-500 mt-2">{summary.totalDispatchUSDT.toFixed(2)} USDT</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">æ€»è´¦å•æ•°</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-slate-900">{summary.totalBills}</div>
              <div className="text-sm text-slate-500 mt-2">ç¬”è´¦å•</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">å¹³å‡æ±‡ç‡</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-slate-900">{summary.averageRate.toFixed(2)}</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">å¹³å‡è´¹ç‡</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-slate-900">{summary.averageFee.toFixed(1)}%</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">æœªä¸‹å‘é‡‘é¢</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-orange-600">{summary.notDispatched.toLocaleString()}</div>
              <div className="text-sm text-slate-500 mt-2">{summary.notDispatchedUSDT.toFixed(2)} USDT</div>
            </CardContent>
          </Card>
        </div>

        <Card>
          <CardHeader>
            <CardTitle>æ¯æ—¥æ˜ç»†</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full">
                <thead>
                  <tr className="border-b">
                    <th className="text-left py-3 px-4 font-medium text-slate-700">æ—¥æœŸ</th>
                    <th className="text-right py-3 px-4 font-medium text-slate-700">å…¥æ¬¾é‡‘é¢</th>
                    <th className="text-right py-3 px-4 font-medium text-slate-700">ä¸‹å‘é‡‘é¢</th>
                    <th className="text-right py-3 px-4 font-medium text-slate-700">è´¦å•æ•°</th>
                    <th className="text-right py-3 px-4 font-medium text-slate-700">å¹³å‡æ±‡ç‡</th>
                  </tr>
                </thead>
                <tbody>
                  {summary.dailyBreakdown.map((day: any, index: number) => (
                    <tr key={index} className="border-b hover:bg-slate-50">
                      <td className="py-3 px-4">{day.date}</td>
                      <td className="text-right py-3 px-4 text-green-600 font-medium">{day.income.toLocaleString()}</td>
                      <td className="text-right py-3 px-4 text-blue-600 font-medium">
                        {day.dispatch.toLocaleString()}
                      </td>
                      <td className="text-right py-3 px-4">{day.bills}</td>
                      <td className="text-right py-3 px-4">{day.rate.toFixed(2)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}
"use client"

import { useEffect, useState } from "react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ArrowLeft } from "lucide-react"

export default function SummaryPage() {
  const router = useRouter()
  const [mounted, setMounted] = useState(false)
  const [summary, setSummary] = useState<any | null>(null)

  useEffect(() => { setMounted(true) }, [])

  useEffect(() => {
    if (!mounted) return
    const controller = new AbortController()
    const load = async () => {
      try {
        const res = await fetch(`/api/stats/30d`, { signal: controller.signal })
        if (!res.ok) throw new Error('failed')
        const json = await res.json()
        setSummary(json)
      } catch (e) {
        if ((e as any).name !== 'AbortError') console.error(e)
      }
    }
    load()
    return () => controller.abort()
  }, [mounted])

  if (!mounted) {
    return null
  }

  if (!summary) return null

  return (
    <div className="min-h-screen bg-slate-50">
      <div className="container mx-auto px-4 py-6 max-w-7xl">
        <Card className="mb-6">
          <CardHeader>
            <div className="flex items-center justify-between">
              <CardTitle className="text-2xl font-bold">æœ€è¿‘30å¤©æ±‡æ€»</CardTitle>
              <Button variant="outline" onClick={() => router.back()}>
                <ArrowLeft className="w-4 h-4 mr-2" />
                è¿”å›
              </Button>
            </div>
          </CardHeader>
        </Card>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          <Card>
            <CardHeader>
              <CardTitle className="text-base">æ€»å…¥æ¬¾é‡‘é¢</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-green-600">{summary.totalIncome.toLocaleString()}</div>
              <div className="text-sm text-slate-500 mt-2">{summary.totalIncomeUSDT.toFixed(2)} USDT</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">æ€»ä¸‹å‘é‡‘é¢</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-blue-600">{summary.totalDispatch.toLocaleString()}</div>
              <div className="text-sm text-slate-500 mt-2">{summary.totalDispatchUSDT.toFixed(2)} USDT</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">å¹³å‡æ±‡ç‡</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-slate-900">{summary.averageRate.toFixed(2)}</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">å¹³å‡è´¹ç‡</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-slate-900">{summary.averageFee.toFixed(1)}%</div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="text-base">æœªä¸‹å‘é‡‘é¢</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="text-3xl font-bold text-orange-600">{summary.notDispatched.toLocaleString()}</div>
              <div className="text-sm text-slate-500 mt-2">{summary.notDispatchedUSDT.toFixed(2)} USDT</div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  )
}
#!/usr/bin/env node

// SafeWå¹³å°å…¼å®¹æ€§æµ‹è¯•è„šæœ¬
const https = require('https')

const SAFEW_API_BASE = process.env.SAFEW_API_BASE || 'https://api.safew.org'
const BOT_TOKEN = process.env.BOT_TOKEN

if (!BOT_TOKEN) {
  console.error('âŒ è¯·è®¾ç½® BOT_TOKEN ç¯å¢ƒå˜é‡')
  process.exit(1)
}

console.log('ğŸ§ª å¼€å§‹SafeW APIå…¼å®¹æ€§æµ‹è¯•...')
console.log(`ğŸ“ APIç«¯ç‚¹: ${SAFW_API_BASE}`)
console.log(`ğŸ¤– Bot Token: ${BOT_TOKEN.substring(0, 10)}...`)

// æµ‹è¯•1: getMe
console.log('\n1ï¸âƒ£ æµ‹è¯• getMe...')
const getMeUrl = `${SAFW_API_BASE}/bot${BOT_TOKEN}/getMe`

https.get(getMeUrl, (res) => {
  let data = ''
  res.on('data', chunk => data += chunk)
  res.on('end', () => {
    try {
      const response = JSON.parse(data)
      if (response.ok) {
        console.log('âœ… getMe æˆåŠŸ')
        console.log(`   æœºå™¨äºº: ${response.result.first_name} (@${response.result.username})`)
      } else {
        console.log('âŒ getMe å¤±è´¥:', response.description)
      }
    } catch (e) {
      console.log('âŒ getMe å“åº”è§£æå¤±è´¥:', e.message)
    }
  })
}).on('error', (e) => {
  console.log('âŒ getMe è¯·æ±‚å¤±è´¥:', e.message)
})

// æµ‹è¯•2: getUpdates (æ£€æŸ¥è½®è¯¢æ”¯æŒ)
setTimeout(() => {
  console.log('\n2ï¸âƒ£ æµ‹è¯• getUpdates...')

  const getUpdatesUrl = `${SAFW_API_BASE}/bot${BOT_TOKEN}/getUpdates?limit=1`

  https.get(getUpdatesUrl, (res) => {
    let data = ''
    res.on('data', chunk => data += chunk)
    res.on('end', () => {
      try {
        const response = JSON.parse(data)
        if (response.ok) {
          console.log('âœ… getUpdates æˆåŠŸ')
          console.log(`   æ›´æ–°æ•°é‡: ${response.result.length}`)
        } else {
          console.log('âŒ getUpdates å¤±è´¥:', response.description)
        }
      } catch (e) {
        console.log('âŒ getUpdates å“åº”è§£æå¤±è´¥:', e.message)
      }

      console.log('\nğŸ¯ æµ‹è¯•å®Œæˆï¼')
      console.log('å¦‚æœæ‰€æœ‰æµ‹è¯•éƒ½é€šè¿‡ï¼Œè¯´æ˜SafeW APIå…¼å®¹æ€§è‰¯å¥½ã€‚')
    })
  }).on('error', (e) => {
    console.log('âŒ getUpdates è¯·æ±‚å¤±è´¥:', e.message)
  })
}, 2000)
// SafeWå¹³å°é€‚é…é…ç½®
export const SAFE_CONFIG = {
  API_BASE: process.env.SAFEW_API_BASE || 'https://api.safew.org',
  PLATFORM_NAME: 'SafeW',

  // SafeWæ”¯æŒçš„ç‰¹æ€§
  FEATURES: {
    WEBHOOK: true,
    POLLING: true,
    INLINE_KEYBOARD: true,
    CALLBACK_QUERIES: true,
    MEDIA_UPLOAD: true,
    CHAT_PERMISSIONS: true,
    ADMIN_RIGHTS: true
  },

  // APIé™åˆ¶
  LIMITS: {
    MAX_MESSAGE_LENGTH: 4096,
    MAX_CAPTION_LENGTH: 1024,
    MAX_FILE_SIZE: 50 * 1024 * 1024, // 50MB
    RATE_LIMIT: 30 // requests per second
  }
}

export function getSafeApiUrl(token, method) {
  return `${SAFE_CONFIG.API_BASE}/bot${token}/${method}`
}

export function isFeatureSupported(feature) {
  return SAFE_CONFIG.FEATURES[feature] || false
}
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

// ğŸ›¡ï¸ æœ€é«˜å®‰å…¨çº§åˆ«ï¼šæ•æ„Ÿè·¯å¾„ä¿æŠ¤
const SENSITIVE_PATHS = [
  '/api/auth',
  '/api/bots',
  '/api/chats',
  '/api/bills',
  '/api/admin',
  '/api/logs',
  '/dashboard',
  '/admin'
]

// ğŸ›¡ï¸ æœ€é«˜å®‰å…¨çº§åˆ«ï¼šAPIé€Ÿç‡é™åˆ¶å­˜å‚¨ï¼ˆå†…å­˜ä¸­ï¼Œç”Ÿäº§ç¯å¢ƒå»ºè®®ä½¿ç”¨Redisï¼‰
const RATE_LIMIT_STORE = new Map<string, { count: number; resetTime: number }>()
const RATE_LIMIT_MAX = 50 // é™ä½é™åˆ¶ï¼Œæ¯çª—å£æœ€å¤§è¯·æ±‚æ•°
const RATE_LIMIT_WINDOW = 15 * 60 * 1000 // 15åˆ†é’Ÿçª—å£

// ğŸ›¡ï¸ æœ€é«˜å®‰å…¨çº§åˆ«ï¼šå¯ç–‘IPé»‘åå•
const SUSPICIOUS_IPS = new Set<string>()
const BLOCKED_IPS = new Set<string>()

function checkRateLimit(clientId: string): boolean {
  const now = Date.now()
  const record = RATE_LIMIT_STORE.get(clientId)

  if (!record || now > record.resetTime) {
    // é‡ç½®æˆ–æ–°å»ºè®°å½•
    RATE_LIMIT_STORE.set(clientId, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
    return true
  }

  if (record.count >= RATE_LIMIT_MAX) {
    return false
  }

  record.count++
  return true
}

function getClientId(request: NextRequest): string {
  // ğŸ›¡ï¸ ä¼˜å…ˆä½¿ç”¨çœŸå®IPï¼Œå¢å¼ºå®‰å…¨æ€§
  const forwarded = request.headers.get('x-forwarded-for')
  const realIp = request.headers.get('x-real-ip')
  const cfConnectingIp = request.headers.get('cf-connecting-ip') // Cloudflare
  const ip = cfConnectingIp || realIp || forwarded?.split(',')[0].trim() || 'unknown'

  // ğŸ›¡ï¸ æ£€æŸ¥æ˜¯å¦ä¸ºå·²çŸ¥æ¶æ„IP
  if (BLOCKED_IPS.has(ip)) {
    console.warn(`[SECURITY] Blocked IP attempted access: ${ip}`)
    throw new Error('Access denied')
  }

  const ua = request.headers.get('user-agent') || ''
  return `${ip}:${ua.slice(0, 50)}` // é™åˆ¶UAé•¿åº¦
}

export function middleware(request: NextRequest) {
  const { pathname, searchParams } = request.nextUrl
  const method = request.method
  const userAgent = request.headers.get('user-agent') || ''
  const host = request.headers.get('host') || ''

  // ğŸ›¡ï¸ è·å–å®¢æˆ·ç«¯æ ‡è¯†
  let clientId: string
  try {
    clientId = getClientId(request)
  } catch (e) {
    return new NextResponse('Access Denied', { status: 403 })
  }

  // ğŸ›¡ï¸ æ£€æŸ¥Hostå¤´ - é˜²æ­¢Hostå¤´æ”»å‡»
  if (process.env.NODE_ENV === 'production') {
    const allowedHosts = (process.env.ALLOWED_HOSTS || 'localhost').split(',')
    if (!allowedHosts.some(allowedHost => host.includes(allowedHost.trim()))) {
      console.warn(`[SECURITY] Invalid host header: ${host} from ${clientId}`)
      return new NextResponse('Forbidden', { status: 403 })
    }
  }

  // ğŸ›¡ï¸ è®°å½•å¯ç–‘è¯·æ±‚
  if (pathname.includes('..') || pathname.includes('\\') || pathname.includes('%2e%2e')) {
    console.warn(`[SECURITY] Path traversal attempt: ${pathname} from ${clientId}`)
    SUSPICIOUS_IPS.add(clientId.split(':')[0])
    return new NextResponse('Forbidden', { status: 403 })
  }

  // ğŸ”¥ å®‰å…¨å¢å¼ºï¼šæ£€æŸ¥æ•æ„Ÿè·¯å¾„çš„é€Ÿç‡é™åˆ¶
  const isSensitivePath = SENSITIVE_PATHS.some(path => pathname.startsWith(path))
  if (isSensitivePath) {
    const clientId = getClientId(request)

    if (!checkRateLimit(clientId)) {
      console.warn(`[SECURITY] Rate limit exceeded for ${pathname} from ${clientId}`)
      return new NextResponse('Too Many Requests', {
        status: 429,
        headers: {
          'Retry-After': '900', // 15åˆ†é’Ÿåé‡è¯•
          'X-RateLimit-Limit': RATE_LIMIT_MAX.toString(),
          'X-RateLimit-Remaining': '0',
          'X-RateLimit-Reset': new Date(Date.now() + RATE_LIMIT_WINDOW).toISOString()
        }
      })
    }
  }

  // ğŸ”¥ å®‰å…¨å¢å¼ºï¼šå¼ºåˆ¶HTTPSé‡å®šå‘ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
  if (process.env.NODE_ENV === 'production' && process.env.FORCE_HTTPS === 'true') {
    const host = request.headers.get('host')
    const protocol = request.headers.get('x-forwarded-proto') || 'http'

    if (protocol !== 'https' && !host?.includes('localhost')) {
      const httpsUrl = `https://${host}${request.nextUrl.pathname}${request.nextUrl.search}`
      console.log(`[HTTPS] Redirecting to: ${httpsUrl}`)
      return NextResponse.redirect(httpsUrl, 301)
    }
  }

  // ğŸ›¡ï¸ æœ€é«˜å®‰å…¨çº§åˆ«ï¼šé˜»æ­¢å¸¸è§çš„æ”»å‡»è½½è·
  const suspiciousPatterns = [
    /(\.\.|\\|%2e%2e|%2e)/i, // è·¯å¾„éå†
    /(<script|javascript:|data:|vbscript:|onload=|onerror=)/i, // XSS
    /(union.*select|select.*from|insert.*into|update.*set|delete.*from|drop.*table)/i, // SQLæ³¨å…¥
    /(\.\.\/|\.\.\\|\/etc\/|\/proc\/|\/home\/)/, // ç›®å½•éå†
    /(eval\(|exec\(|system\(|shell_exec\()/i, // ä»£ç æ‰§è¡Œ
    /(<iframe|<object|<embed|<form|<input)/i, // HTMLæ³¨å…¥
    /(base64|data:text|javascript:void)/i, // æ•°æ®URLæ”»å‡»
    /([a-zA-Z0-9]{100,})/, // è¶…é•¿å­—ç¬¦ä¸²ï¼ˆå¯èƒ½ä¸ºç¼“å†²åŒºæº¢å‡ºï¼‰
  ]

  const url = request.url
  const body = request.body ? 'has-body' : 'no-body'

  for (const pattern of suspiciousPatterns) {
    if (pattern.test(url) || pattern.test(userAgent) || pattern.test(pathname)) {
      console.warn(`[SECURITY] Suspicious request blocked: ${method} ${url} UA: ${userAgent.slice(0, 100)}`)
      const clientIP = clientId.split(':')[0]
      SUSPICIOUS_IPS.add(clientIP)

      // å¦‚æœåŒä¸€IPæœ‰å¤šæ¬¡å¯ç–‘è¯·æ±‚ï¼ŒåŠ å…¥é»‘åå•
      if (SUSPICIOUS_IPS.has(clientIP)) {
        let suspiciousCount = 0
        for (const ip of SUSPICIOUS_IPS) {
          if (ip === clientIP) suspiciousCount++
        }
        if (suspiciousCount >= 3) {
          BLOCKED_IPS.add(clientIP)
          console.warn(`[SECURITY] IP blocked due to repeated suspicious activity: ${clientIP}`)
        }
      }

      return new NextResponse('Forbidden', { status: 403 })
    }
  }

  // ğŸ›¡ï¸ æœ€é«˜å®‰å…¨çº§åˆ«ï¼šæ£€æŸ¥è¯·æ±‚å¤´
  const contentType = request.headers.get('content-type')
  const contentLength = request.headers.get('content-length')
  const authorization = request.headers.get('authorization')

  // æ£€æŸ¥APIè¯·æ±‚çš„Content-Type
  if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && pathname.startsWith('/api/')) {
    if (!contentType?.includes('application/json')) {
      console.warn(`[SECURITY] Invalid content-type for API: ${contentType} on ${pathname}`)
      return new NextResponse('Bad Request', { status: 400 })
    }
  }

  // æ£€æŸ¥è¯·æ±‚ä½“å¤§å°é™åˆ¶
  if (contentLength && parseInt(contentLength) > 10 * 1024 * 1024) { // 10MBé™åˆ¶
    console.warn(`[SECURITY] Request too large: ${contentLength} bytes from ${clientId}`)
    return new NextResponse('Payload Too Large', { status: 413 })
  }

  // æ£€æŸ¥æ•æ„ŸAPIçš„è®¤è¯å¤´
  if (pathname.startsWith('/api/') && SENSITIVE_PATHS.some(path => pathname.startsWith(path))) {
    if (!authorization && method !== 'GET') {
      console.warn(`[SECURITY] Missing authorization for sensitive API: ${pathname} from ${clientId}`)
      return new NextResponse('Unauthorized', { status: 401 })
    }
  }

  // ğŸ›¡ï¸ å®šæœŸæ¸…ç†å®‰å…¨æ•°æ®
  if (Math.random() < 0.001) {
    const now = Date.now()

    // æ¸…ç†è¿‡æœŸçš„é€Ÿç‡é™åˆ¶è®°å½•
    for (const [key, record] of RATE_LIMIT_STORE.entries()) {
      if (now > record.resetTime) {
        RATE_LIMIT_STORE.delete(key)
      }
    }

    // æ¸…ç†è¿‡æœŸçš„å¯ç–‘IPè®°å½•ï¼ˆ24å°æ—¶åæ¸…é™¤ï¼‰
    const oneDayAgo = now - 24 * 60 * 60 * 1000
    // æ³¨æ„ï¼šè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…ç”Ÿäº§ç¯å¢ƒåº”è¯¥æœ‰æ›´å¥½çš„è¿‡æœŸæœºåˆ¶
  }

  return NextResponse.next()
}

// ğŸ”¥ å®‰å…¨å¢å¼ºï¼šé…ç½®ä¸­é—´ä»¶åŒ¹é…çš„è·¯å¾„
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/dev/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
'use client'

import * as AspectRatioPrimitive from '@radix-ui/react-aspect-ratio'

function AspectRatio({
  ...props
}: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />
}

export { AspectRatio }
'use client'

import * as React from 'react'
import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog'

import { cn } from '@/lib/utils'
import { buttonVariants } from '@/components/ui/button'

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className,
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg',
          className,
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        'flex flex-col-reverse gap-2 sm:flex-row sm:justify-end',
        className,
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn('text-lg font-semibold', className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: 'outline' }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
import * as React from 'react'

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener('change', onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener('change', onChange)
  }, [])

  return !!isMobile
}
import * as React from 'react'
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from 'lucide-react'

import { cn } from '@/lib/utils'
import { Button, buttonVariants } from '@/components/ui/button'

function Pagination({ className, ...props }: React.ComponentProps<'nav'>) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn('mx-auto flex w-full justify-center', className)}
      {...props}
    />
  )
}

function PaginationContent({
  className,
  ...props
}: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn('flex flex-row items-center gap-1', className)}
      {...props}
    />
  )
}

function PaginationItem({ ...props }: React.ComponentProps<'li'>) {
  return <li data-slot="pagination-item" {...props} />
}

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, 'size'> &
  React.ComponentProps<'a'>

function PaginationLink({
  className,
  isActive,
  size = 'icon',
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? 'page' : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? 'outline' : 'ghost',
          size,
        }),
        className,
      )}
      {...props}
    />
  )
}

function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn('gap-1 px-2.5 sm:pl-2.5', className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="hidden sm:block">Previous</span>
    </PaginationLink>
  )
}

function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn('gap-1 px-2.5 sm:pr-2.5', className)}
      {...props}
    >
      <span className="hidden sm:block">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  )
}

function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      aria-hidden
      data-slot="pagination-ellipsis"
      className={cn('flex size-9 items-center justify-center', className)}
      {...props}
    >
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}
'use client'

import * as React from 'react'
import * as TabsPrimitive from '@radix-ui/react-tabs'

import { cn } from '@/lib/utils'

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn('flex flex-col gap-2', className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        'bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]',
        className,
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn('flex-1 outline-none', className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'
import { Separator } from '@/components/ui/separator'

const buttonGroupVariants = cva(
  "flex w-fit items-stretch [&>*]:focus-visible:z-10 [&>*]:focus-visible:relative [&>[data-slot=select-trigger]:not([class*='w-'])]:w-fit [&>input]:flex-1 has-[select[aria-hidden=true]:last-child]:[&>[data-slot=select-trigger]:last-of-type]:rounded-r-md has-[>[data-slot=button-group]]:gap-2",
  {
    variants: {
      orientation: {
        horizontal:
          '[&>*:not(:first-child)]:rounded-l-none [&>*:not(:first-child)]:border-l-0 [&>*:not(:last-child)]:rounded-r-none',
        vertical:
          'flex-col [&>*:not(:first-child)]:rounded-t-none [&>*:not(:first-child)]:border-t-0 [&>*:not(:last-child)]:rounded-b-none',
      },
    },
    defaultVariants: {
      orientation: 'horizontal',
    },
  },
)

function ButtonGroup({
  className,
  orientation,
  ...props
}: React.ComponentProps<'div'> & VariantProps<typeof buttonGroupVariants>) {
  return (
    <div
      role="group"
      data-slot="button-group"
      data-orientation={orientation}
      className={cn(buttonGroupVariants({ orientation }), className)}
      {...props}
    />
  )
}

function ButtonGroupText({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'div'> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : 'div'

  return (
    <Comp
      className={cn(
        "bg-muted flex items-center gap-2 rounded-md border px-4 text-sm font-medium shadow-xs [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function ButtonGroupSeparator({
  className,
  orientation = 'vertical',
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="button-group-separator"
      orientation={orientation}
      className={cn(
        'bg-input relative !m-0 self-stretch data-[orientation=vertical]:h-auto',
        className,
      )}
      {...props}
    />
  )
}

export {
  ButtonGroup,
  ButtonGroupSeparator,
  ButtonGroupText,
  buttonGroupVariants,
}
import * as React from 'react'

import { cn } from '@/lib/utils'

function Card({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card"
      className={cn(
        'bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm',
        className,
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        '@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6',
        className,
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-title"
      className={cn('leading-none font-semibold', className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        'col-start-2 row-span-2 row-start-1 self-start justify-self-end',
        className,
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-content"
      className={cn('px-6', className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="card-footer"
      className={cn('flex items-center px-6 [.border-t]:pt-6', className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
'use client'

import * as React from 'react'
import * as SliderPrimitive from '@radix-ui/react-slider'

import { cn } from '@/lib/utils'

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max],
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        'relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col',
        className,
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={
          'bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5'
        }
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={
            'bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full'
          }
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary ring-ring/50 block size-4 shrink-0 rounded-full border bg-white shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }
'use client'

import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'

function InputGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="input-group"
      role="group"
      className={cn(
        'group/input-group border-input dark:bg-input/30 relative flex w-full items-center rounded-md border shadow-xs transition-[color,box-shadow] outline-none',
        'h-9 has-[>textarea]:h-auto',

        // Variants based on alignment.
        'has-[>[data-align=inline-start]]:[&>input]:pl-2',
        'has-[>[data-align=inline-end]]:[&>input]:pr-2',
        'has-[>[data-align=block-start]]:h-auto has-[>[data-align=block-start]]:flex-col has-[>[data-align=block-start]]:[&>input]:pb-3',
        'has-[>[data-align=block-end]]:h-auto has-[>[data-align=block-end]]:flex-col has-[>[data-align=block-end]]:[&>input]:pt-3',

        // Focus state.
        'has-[[data-slot=input-group-control]:focus-visible]:border-ring has-[[data-slot=input-group-control]:focus-visible]:ring-ring/50 has-[[data-slot=input-group-control]:focus-visible]:ring-[3px]',

        // Error state.
        'has-[[data-slot][aria-invalid=true]]:ring-destructive/20 has-[[data-slot][aria-invalid=true]]:border-destructive dark:has-[[data-slot][aria-invalid=true]]:ring-destructive/40',

        className,
      )}
      {...props}
    />
  )
}

const inputGroupAddonVariants = cva(
  "text-muted-foreground flex h-auto cursor-text items-center justify-center gap-2 py-1.5 text-sm font-medium select-none [&>svg:not([class*='size-'])]:size-4 [&>kbd]:rounded-[calc(var(--radius)-5px)] group-data-[disabled=true]/input-group:opacity-50",
  {
    variants: {
      align: {
        'inline-start':
          'order-first pl-3 has-[>button]:ml-[-0.45rem] has-[>kbd]:ml-[-0.35rem]',
        'inline-end':
          'order-last pr-3 has-[>button]:mr-[-0.4rem] has-[>kbd]:mr-[-0.35rem]',
        'block-start':
          'order-first w-full justify-start px-3 pt-3 [.border-b]:pb-3 group-has-[>input]/input-group:pt-2.5',
        'block-end':
          'order-last w-full justify-start px-3 pb-3 [.border-t]:pt-3 group-has-[>input]/input-group:pb-2.5',
      },
    },
    defaultVariants: {
      align: 'inline-start',
    },
  },
)

function InputGroupAddon({
  className,
  align = 'inline-start',
  ...props
}: React.ComponentProps<'div'> & VariantProps<typeof inputGroupAddonVariants>) {
  return (
    <div
      role="group"
      data-slot="input-group-addon"
      data-align={align}
      className={cn(inputGroupAddonVariants({ align }), className)}
      onClick={(e) => {
        if ((e.target as HTMLElement).closest('button')) {
          return
        }
        e.currentTarget.parentElement?.querySelector('input')?.focus()
      }}
      {...props}
    />
  )
}

const inputGroupButtonVariants = cva(
  'text-sm shadow-none flex gap-2 items-center',
  {
    variants: {
      size: {
        xs: "h-6 gap-1 px-2 rounded-[calc(var(--radius)-5px)] [&>svg:not([class*='size-'])]:size-3.5 has-[>svg]:px-2",
        sm: 'h-8 px-2.5 gap-1.5 rounded-md has-[>svg]:px-2.5',
        'icon-xs':
          'size-6 rounded-[calc(var(--radius)-5px)] p-0 has-[>svg]:p-0',
        'icon-sm': 'size-8 p-0 has-[>svg]:p-0',
      },
    },
    defaultVariants: {
      size: 'xs',
    },
  },
)

function InputGroupButton({
  className,
  type = 'button',
  variant = 'ghost',
  size = 'xs',
  ...props
}: Omit<React.ComponentProps<typeof Button>, 'size'> &
  VariantProps<typeof inputGroupButtonVariants>) {
  return (
    <Button
      type={type}
      data-size={size}
      variant={variant}
      className={cn(inputGroupButtonVariants({ size }), className)}
      {...props}
    />
  )
}

function InputGroupText({ className, ...props }: React.ComponentProps<'span'>) {
  return (
    <span
      className={cn(
        "text-muted-foreground flex items-center gap-2 text-sm [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function InputGroupInput({
  className,
  ...props
}: React.ComponentProps<'input'>) {
  return (
    <Input
      data-slot="input-group-control"
      className={cn(
        'flex-1 rounded-none border-0 bg-transparent shadow-none focus-visible:ring-0 dark:bg-transparent',
        className,
      )}
      {...props}
    />
  )
}

function InputGroupTextarea({
  className,
  ...props
}: React.ComponentProps<'textarea'>) {
  return (
    <Textarea
      data-slot="input-group-control"
      className={cn(
        'flex-1 resize-none rounded-none border-0 bg-transparent py-3 shadow-none focus-visible:ring-0 dark:bg-transparent',
        className,
      )}
      {...props}
    />
  )
}

export {
  InputGroup,
  InputGroupAddon,
  InputGroupButton,
  InputGroupText,
  InputGroupInput,
  InputGroupTextarea,
}
'use client'

import * as React from 'react'
import * as PopoverPrimitive from '@radix-ui/react-popover'

import { cn } from '@/lib/utils'

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = 'center',
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden',
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
'use client'

import * as React from 'react'
import * as ProgressPrimitive from '@radix-ui/react-progress'

import { cn } from '@/lib/utils'

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        'bg-primary/20 relative h-2 w-full overflow-hidden rounded-full',
        className,
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }
'use client'

import { useToast } from '@/hooks/use-toast'
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast'

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
'use client'

import * as React from 'react'
import { OTPInput, OTPInputContext } from 'input-otp'
import { MinusIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function InputOTP({
  className,
  containerClassName,
  ...props
}: React.ComponentProps<typeof OTPInput> & {
  containerClassName?: string
}) {
  return (
    <OTPInput
      data-slot="input-otp"
      containerClassName={cn(
        'flex items-center gap-2 has-disabled:opacity-50',
        containerClassName,
      )}
      className={cn('disabled:cursor-not-allowed', className)}
      {...props}
    />
  )
}

function InputOTPGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="input-otp-group"
      className={cn('flex items-center', className)}
      {...props}
    />
  )
}

function InputOTPSlot({
  index,
  className,
  ...props
}: React.ComponentProps<'div'> & {
  index: number
}) {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}

  return (
    <div
      data-slot="input-otp-slot"
      data-active={isActive}
      className={cn(
        'data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive dark:bg-input/30 border-input relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]',
        className,
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink bg-foreground h-4 w-px duration-1000" />
        </div>
      )}
    </div>
  )
}

function InputOTPSeparator({ ...props }: React.ComponentProps<'div'>) {
  return (
    <div data-slot="input-otp-separator" role="separator" {...props}>
      <MinusIcon />
    </div>
  )
}

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
'use client'

import * as React from 'react'
import * as RechartsPrimitive from 'recharts'

import { cn } from '@/lib/utils'

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: '', dark: '.dark' } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error('useChart must be used within a <ChartContainer />')
  }

  return context
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<'div'> & {
  config: ChartConfig
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >['children']
}) {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, '')}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className,
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color,
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join('\n')}
}
`,
          )
          .join('\n'),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = 'dot',
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<'div'> & {
    hideLabel?: boolean
    hideIndicator?: boolean
    indicator?: 'line' | 'dot' | 'dashed'
    nameKey?: string
    labelKey?: string
  }) {
  const { config } = useChart()

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }

    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || 'value'}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === 'string'
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label

    if (labelFormatter) {
      return (
        <div className={cn('font-medium', labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      )
    }

    if (!value) {
      return null
    }

    return <div className={cn('font-medium', labelClassName)}>{value}</div>
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])

  if (!active || !payload?.length) {
    return null
  }

  const nestLabel = payload.length === 1 && indicator !== 'dot'

  return (
    <div
      className={cn(
        'border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl',
        className,
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || 'value'}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload.fill || item.color

          return (
            <div
              key={item.dataKey}
              className={cn(
                '[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5',
                indicator === 'dot' && 'items-center',
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn(
                          'shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)',
                          {
                            'h-2.5 w-2.5': indicator === 'dot',
                            'w-1': indicator === 'line',
                            'w-0 border-[1.5px] border-dashed bg-transparent':
                              indicator === 'dashed',
                            'my-0.5': nestLabel && indicator === 'dashed',
                          },
                        )}
                        style={
                          {
                            '--color-bg': indicatorColor,
                            '--color-border': indicatorColor,
                          } as React.CSSProperties
                        }
                      />
                    )
                  )}
                  <div
                    className={cn(
                      'flex flex-1 justify-between leading-none',
                      nestLabel ? 'items-end' : 'items-center',
                    )}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}

const ChartLegend = RechartsPrimitive.Legend

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = 'bottom',
  nameKey,
}: React.ComponentProps<'div'> &
  Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & {
    hideIcon?: boolean
    nameKey?: string
  }) {
  const { config } = useChart()

  if (!payload?.length) {
    return null
  }

  return (
    <div
      className={cn(
        'flex items-center justify-center gap-4',
        verticalAlign === 'top' ? 'pb-3' : 'pt-3',
        className,
      )}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || 'value'}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)

        return (
          <div
            key={item.value}
            className={
              '[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3'
            }
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        )
      })}
    </div>
  )
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string,
) {
  if (typeof payload !== 'object' || payload === null) {
    return undefined
  }

  const payloadPayload =
    'payload' in payload &&
    typeof payload.payload === 'object' &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === 'string'
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === 'string'
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
'use client'

import * as React from 'react'
import * as HoverCardPrimitive from '@radix-ui/react-hover-card'

import { cn } from '@/lib/utils'

function HoverCard({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}

function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return (
    <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
  )
}

function HoverCardContent({
  className,
  align = 'center',
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Portal data-slot="hover-card-portal">
      <HoverCardPrimitive.Content
        data-slot="hover-card-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden',
          className,
        )}
        {...props}
      />
    </HoverCardPrimitive.Portal>
  )
}

export { HoverCard, HoverCardTrigger, HoverCardContent }
'use client'

import * as React from 'react'
import * as SheetPrimitive from '@radix-ui/react-dialog'
import { XIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className,
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = 'right',
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: 'top' | 'right' | 'bottom' | 'left'
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
          side === 'right' &&
            'data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm',
          side === 'left' &&
            'data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm',
          side === 'top' &&
            'data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b',
          side === 'bottom' &&
            'data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t',
          className,
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sheet-header"
      className={cn('flex flex-col gap-1.5 p-4', className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn('mt-auto flex flex-col gap-2 p-4', className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn('text-foreground font-semibold', className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
'use client'

import { useMemo } from 'react'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'
import { Label } from '@/components/ui/label'
import { Separator } from '@/components/ui/separator'

function FieldSet({ className, ...props }: React.ComponentProps<'fieldset'>) {
  return (
    <fieldset
      data-slot="field-set"
      className={cn(
        'flex flex-col gap-6',
        'has-[>[data-slot=checkbox-group]]:gap-3 has-[>[data-slot=radio-group]]:gap-3',
        className,
      )}
      {...props}
    />
  )
}

function FieldLegend({
  className,
  variant = 'legend',
  ...props
}: React.ComponentProps<'legend'> & { variant?: 'legend' | 'label' }) {
  return (
    <legend
      data-slot="field-legend"
      data-variant={variant}
      className={cn(
        'mb-3 font-medium',
        'data-[variant=legend]:text-base',
        'data-[variant=label]:text-sm',
        className,
      )}
      {...props}
    />
  )
}

function FieldGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="field-group"
      className={cn(
        'group/field-group @container/field-group flex w-full flex-col gap-7 data-[slot=checkbox-group]:gap-3 [&>[data-slot=field-group]]:gap-4',
        className,
      )}
      {...props}
    />
  )
}

const fieldVariants = cva(
  'group/field flex w-full gap-3 data-[invalid=true]:text-destructive',
  {
    variants: {
      orientation: {
        vertical: ['flex-col [&>*]:w-full [&>.sr-only]:w-auto'],
        horizontal: [
          'flex-row items-center',
          '[&>[data-slot=field-label]]:flex-auto',
          'has-[>[data-slot=field-content]]:items-start has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px',
        ],
        responsive: [
          'flex-col [&>*]:w-full [&>.sr-only]:w-auto @md/field-group:flex-row @md/field-group:items-center @md/field-group:[&>*]:w-auto',
          '@md/field-group:[&>[data-slot=field-label]]:flex-auto',
          '@md/field-group:has-[>[data-slot=field-content]]:items-start @md/field-group:has-[>[data-slot=field-content]]:[&>[role=checkbox],[role=radio]]:mt-px',
        ],
      },
    },
    defaultVariants: {
      orientation: 'vertical',
    },
  },
)

function Field({
  className,
  orientation = 'vertical',
  ...props
}: React.ComponentProps<'div'> & VariantProps<typeof fieldVariants>) {
  return (
    <div
      role="group"
      data-slot="field"
      data-orientation={orientation}
      className={cn(fieldVariants({ orientation }), className)}
      {...props}
    />
  )
}

function FieldContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="field-content"
      className={cn(
        'group/field-content flex flex-1 flex-col gap-1.5 leading-snug',
        className,
      )}
      {...props}
    />
  )
}

function FieldLabel({
  className,
  ...props
}: React.ComponentProps<typeof Label>) {
  return (
    <Label
      data-slot="field-label"
      className={cn(
        'group/field-label peer/field-label flex w-fit gap-2 leading-snug group-data-[disabled=true]/field:opacity-50',
        'has-[>[data-slot=field]]:w-full has-[>[data-slot=field]]:flex-col has-[>[data-slot=field]]:rounded-md has-[>[data-slot=field]]:border [&>*]:data-[slot=field]:p-4',
        'has-data-[state=checked]:bg-primary/5 has-data-[state=checked]:border-primary dark:has-data-[state=checked]:bg-primary/10',
        className,
      )}
      {...props}
    />
  )
}

function FieldTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="field-label"
      className={cn(
        'flex w-fit items-center gap-2 text-sm leading-snug font-medium group-data-[disabled=true]/field:opacity-50',
        className,
      )}
      {...props}
    />
  )
}

function FieldDescription({ className, ...props }: React.ComponentProps<'p'>) {
  return (
    <p
      data-slot="field-description"
      className={cn(
        'text-muted-foreground text-sm leading-normal font-normal group-has-[[data-orientation=horizontal]]/field:text-balance',
        'last:mt-0 nth-last-2:-mt-1 [[data-variant=legend]+&]:-mt-1.5',
        '[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4',
        className,
      )}
      {...props}
    />
  )
}

function FieldSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<'div'> & {
  children?: React.ReactNode
}) {
  return (
    <div
      data-slot="field-separator"
      data-content={!!children}
      className={cn(
        'relative -my-2 h-5 text-sm group-data-[variant=outline]/field-group:-mb-2',
        className,
      )}
      {...props}
    >
      <Separator className="absolute inset-0 top-1/2" />
      {children && (
        <span
          className="bg-background text-muted-foreground relative mx-auto block w-fit px-2"
          data-slot="field-separator-content"
        >
          {children}
        </span>
      )}
    </div>
  )
}

function FieldError({
  className,
  children,
  errors,
  ...props
}: React.ComponentProps<'div'> & {
  errors?: Array<{ message?: string } | undefined>
}) {
  const content = useMemo(() => {
    if (children) {
      return children
    }

    if (!errors) {
      return null
    }

    if (errors.length === 1 && errors[0]?.message) {
      return errors[0].message
    }

    return (
      <ul className="ml-4 flex list-disc flex-col gap-1">
        {errors.map(
          (error, index) =>
            error?.message && <li key={index}>{error.message}</li>,
        )}
      </ul>
    )
  }, [children, errors])

  if (!content) {
    return null
  }

  return (
    <div
      role="alert"
      data-slot="field-error"
      className={cn('text-destructive text-sm font-normal', className)}
      {...props}
    >
      {content}
    </div>
  )
}

export {
  Field,
  FieldLabel,
  FieldDescription,
  FieldError,
  FieldGroup,
  FieldLegend,
  FieldSeparator,
  FieldSet,
  FieldContent,
  FieldTitle,
}
'use client'

import * as React from 'react'
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area'

import { cn } from '@/lib/utils'

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn('relative', className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = 'vertical',
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        'flex touch-none p-px transition-colors select-none',
        orientation === 'vertical' &&
          'h-full w-2.5 border-l border-l-transparent',
        orientation === 'horizontal' &&
          'h-2.5 flex-col border-t border-t-transparent',
        className,
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
'use client'

import * as React from 'react'
import { GripVerticalIcon } from 'lucide-react'
import * as ResizablePrimitive from 'react-resizable-panels'

import { cn } from '@/lib/utils'

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        'flex h-full w-full data-[panel-group-direction=vertical]:flex-col',
        className,
      )}
      {...props}
    />
  )
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        'bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90',
        className,
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
'use client'

import * as React from 'react'
import * as LabelPrimitive from '@radix-ui/react-label'

import { cn } from '@/lib/utils'

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        'flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50',
        className,
      )}
      {...props}
    />
  )
}

export { Label }
'use client'

import { useTheme } from 'next-themes'
import { Toaster as Sonner, ToasterProps } from 'sonner'

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      style={
        {
          '--normal-bg': 'var(--popover)',
          '--normal-text': 'var(--popover-foreground)',
          '--normal-border': 'var(--border)',
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
import * as React from 'react'
import * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu'
import { cva } from 'class-variance-authority'
import { ChevronDownIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function NavigationMenu({
  className,
  children,
  viewport = true,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & {
  viewport?: boolean
}) {
  return (
    <NavigationMenuPrimitive.Root
      data-slot="navigation-menu"
      data-viewport={viewport}
      className={cn(
        'group/navigation-menu relative flex max-w-max flex-1 items-center justify-center',
        className,
      )}
      {...props}
    >
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  )
}

function NavigationMenuList({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return (
    <NavigationMenuPrimitive.List
      data-slot="navigation-menu-list"
      className={cn(
        'group flex flex-1 list-none items-center justify-center gap-1',
        className,
      )}
      {...props}
    />
  )
}

function NavigationMenuItem({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return (
    <NavigationMenuPrimitive.Item
      data-slot="navigation-menu-item"
      className={cn('relative', className)}
      {...props}
    />
  )
}

const navigationMenuTriggerStyle = cva(
  'group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 outline-none transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1',
)

function NavigationMenuTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
    <NavigationMenuPrimitive.Trigger
      data-slot="navigation-menu-trigger"
      className={cn(navigationMenuTriggerStyle(), 'group', className)}
      {...props}
    >
      {children}{' '}
      <ChevronDownIcon
        className="relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180"
        aria-hidden="true"
      />
    </NavigationMenuPrimitive.Trigger>
  )
}

function NavigationMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn(
        'data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto',
        'group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none',
        className,
      )}
      {...props}
    />
  )
}

function NavigationMenuViewport({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div
      className={'absolute top-full left-0 isolate z-50 flex justify-center'}
    >
      <NavigationMenuPrimitive.Viewport
        data-slot="navigation-menu-viewport"
        className={cn(
          'origin-top-center bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border shadow md:w-[var(--radix-navigation-menu-viewport-width)]',
          className,
        )}
        {...props}
      />
    </div>
  )
}

function NavigationMenuLink({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return (
    <NavigationMenuPrimitive.Link
      data-slot="navigation-menu-link"
      className={cn(
        "data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus-visible:ring-ring/50 [&_svg:not([class*='text-'])]:text-muted-foreground flex flex-col gap-1 rounded-sm p-2 text-sm transition-all outline-none focus-visible:ring-[3px] focus-visible:outline-1 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function NavigationMenuIndicator({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator
      data-slot="navigation-menu-indicator"
      className={cn(
        'data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden',
        className,
      )}
      {...props}
    >
      <div className="bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm shadow-md" />
    </NavigationMenuPrimitive.Indicator>
  )
}

export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle,
}
'use client'

import * as React from 'react'
import * as AccordionPrimitive from '@radix-ui/react-accordion'
import { ChevronDownIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn('border-b last:border-b-0', className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          'focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180',
          className,
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn('pt-0 pb-4', className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
'use client'

import * as React from 'react'
import { Drawer as DrawerPrimitive } from 'vaul'

import { cn } from '@/lib/utils'

function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />
}

function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />
}

function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />
}

function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />
}

function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className,
      )}
      {...props}
    />
  )
}

function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn(
          'group/drawer-content bg-background fixed z-50 flex h-auto flex-col',
          'data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg data-[vaul-drawer-direction=top]:border-b',
          'data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg data-[vaul-drawer-direction=bottom]:border-t',
          'data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:border-l data-[vaul-drawer-direction=right]:sm:max-w-sm',
          'data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:border-r data-[vaul-drawer-direction=left]:sm:max-w-sm',
          className,
        )}
        {...props}
      >
        <div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  )
}

function DrawerHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="drawer-header"
      className={cn(
        'flex flex-col gap-0.5 p-4 group-data-[vaul-drawer-direction=bottom]/drawer-content:text-center group-data-[vaul-drawer-direction=top]/drawer-content:text-center md:gap-1.5 md:text-left',
        className,
      )}
      {...props}
    />
  )
}

function DrawerFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn('mt-auto flex flex-col gap-2 p-4', className)}
      {...props}
    />
  )
}

function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn('text-foreground font-semibold', className)}
      {...props}
    />
  )
}

function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  )
}

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'

function Empty({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="empty"
      className={cn(
        'flex min-w-0 flex-1 flex-col items-center justify-center gap-6 rounded-lg border-dashed p-6 text-center text-balance md:p-12',
        className,
      )}
      {...props}
    />
  )
}

function EmptyHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="empty-header"
      className={cn(
        'flex max-w-sm flex-col items-center gap-2 text-center',
        className,
      )}
      {...props}
    />
  )
}

const emptyMediaVariants = cva(
  'flex shrink-0 items-center justify-center mb-2 [&_svg]:pointer-events-none [&_svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        icon: "bg-muted text-foreground flex size-10 shrink-0 items-center justify-center rounded-lg [&_svg:not([class*='size-'])]:size-6",
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
)

function EmptyMedia({
  className,
  variant = 'default',
  ...props
}: React.ComponentProps<'div'> & VariantProps<typeof emptyMediaVariants>) {
  return (
    <div
      data-slot="empty-icon"
      data-variant={variant}
      className={cn(emptyMediaVariants({ variant, className }))}
      {...props}
    />
  )
}

function EmptyTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="empty-title"
      className={cn('text-lg font-medium tracking-tight', className)}
      {...props}
    />
  )
}

function EmptyDescription({ className, ...props }: React.ComponentProps<'p'>) {
  return (
    <div
      data-slot="empty-description"
      className={cn(
        'text-muted-foreground [&>a:hover]:text-primary text-sm/relaxed [&>a]:underline [&>a]:underline-offset-4',
        className,
      )}
      {...props}
    />
  )
}

function EmptyContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="empty-content"
      className={cn(
        'flex w-full max-w-sm min-w-0 flex-col items-center gap-4 text-sm text-balance',
        className,
      )}
      {...props}
    />
  )
}

export {
  Empty,
  EmptyHeader,
  EmptyTitle,
  EmptyDescription,
  EmptyContent,
  EmptyMedia,
}
'use client'

import * as React from 'react'
import * as TooltipPrimitive from '@radix-ui/react-tooltip'

import { cn } from '@/lib/utils'

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance',
          className,
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
import * as React from 'react'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'

const alertVariants = cva(
  'relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current',
  {
    variants: {
      variant: {
        default: 'bg-card text-card-foreground',
        destructive:
          'text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<'div'> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        'col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight',
        className,
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        'text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed',
        className,
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }
'use client'

// Inspired by react-hot-toast library
import * as React from 'react'

import type { ToastActionElement, ToastProps } from '@/components/ui/toast'

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType['ADD_TOAST']
      toast: ToasterToast
    }
  | {
      type: ActionType['UPDATE_TOAST']
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType['DISMISS_TOAST']
      toastId?: ToasterToast['id']
    }
  | {
      type: ActionType['REMOVE_TOAST']
      toastId?: ToasterToast['id']
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      }

    case 'DISMISS_TOAST': {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      }
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, 'id'>

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id })

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  }
}

export { useToast, toast }
'use client'

import * as React from 'react'
import * as SwitchPrimitive from '@radix-ui/react-switch'

import { cn } from '@/lib/utils'

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        'peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={
          'bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0'
        }
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }
'use client'

import * as React from 'react'
import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from 'lucide-react'
import { DayButton, DayPicker, getDefaultClassNames } from 'react-day-picker'

import { cn } from '@/lib/utils'
import { Button, buttonVariants } from '@/components/ui/button'

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = 'label',
  buttonVariant = 'ghost',
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>['variant']
}) {
  const defaultClassNames = getDefaultClassNames()

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        'bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent',
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className,
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString('default', { month: 'short' }),
        ...formatters,
      }}
      classNames={{
        root: cn('w-fit', defaultClassNames.root),
        months: cn(
          'flex gap-4 flex-col md:flex-row relative',
          defaultClassNames.months,
        ),
        month: cn('flex flex-col w-full gap-4', defaultClassNames.month),
        nav: cn(
          'flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between',
          defaultClassNames.nav,
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          'size-(--cell-size) aria-disabled:opacity-50 p-0 select-none',
          defaultClassNames.button_previous,
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          'size-(--cell-size) aria-disabled:opacity-50 p-0 select-none',
          defaultClassNames.button_next,
        ),
        month_caption: cn(
          'flex items-center justify-center h-(--cell-size) w-full px-(--cell-size)',
          defaultClassNames.month_caption,
        ),
        dropdowns: cn(
          'w-full flex items-center text-sm font-medium justify-center h-(--cell-size) gap-1.5',
          defaultClassNames.dropdowns,
        ),
        dropdown_root: cn(
          'relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md',
          defaultClassNames.dropdown_root,
        ),
        dropdown: cn(
          'absolute bg-popover inset-0 opacity-0',
          defaultClassNames.dropdown,
        ),
        caption_label: cn(
          'select-none font-medium',
          captionLayout === 'label'
            ? 'text-sm'
            : 'rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5',
          defaultClassNames.caption_label,
        ),
        table: 'w-full border-collapse',
        weekdays: cn('flex', defaultClassNames.weekdays),
        weekday: cn(
          'text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none',
          defaultClassNames.weekday,
        ),
        week: cn('flex w-full mt-2', defaultClassNames.week),
        week_number_header: cn(
          'select-none w-(--cell-size)',
          defaultClassNames.week_number_header,
        ),
        week_number: cn(
          'text-[0.8rem] select-none text-muted-foreground',
          defaultClassNames.week_number,
        ),
        day: cn(
          'relative w-full h-full p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none',
          defaultClassNames.day,
        ),
        range_start: cn(
          'rounded-l-md bg-accent',
          defaultClassNames.range_start,
        ),
        range_middle: cn('rounded-none', defaultClassNames.range_middle),
        range_end: cn('rounded-r-md bg-accent', defaultClassNames.range_end),
        today: cn(
          'bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none',
          defaultClassNames.today,
        ),
        outside: cn(
          'text-muted-foreground aria-selected:text-muted-foreground',
          defaultClassNames.outside,
        ),
        disabled: cn(
          'text-muted-foreground opacity-50',
          defaultClassNames.disabled,
        ),
        hidden: cn('invisible', defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          )
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === 'left') {
            return (
              <ChevronLeftIcon className={cn('size-4', className)} {...props} />
            )
          }

          if (orientation === 'right') {
            return (
              <ChevronRightIcon
                className={cn('size-4', className)}
                {...props}
              />
            )
          }

          return (
            <ChevronDownIcon className={cn('size-4', className)} {...props} />
          )
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-(--cell-size) items-center justify-center text-center">
                {children}
              </div>
            </td>
          )
        },
        ...components,
      }}
      {...props}
    />
  )
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames()

  const ref = React.useRef<HTMLButtonElement>(null)
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus()
  }, [modifiers.focused])

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        'data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 dark:hover:text-accent-foreground flex aspect-square size-auto w-full min-w-(--cell-size) flex-col gap-1 leading-none font-normal group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] data-[range-end=true]:rounded-md data-[range-end=true]:rounded-r-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-start=true]:rounded-l-md [&>span]:text-xs [&>span]:opacity-70',
        defaultClassNames.day,
        className,
      )}
      {...props}
    />
  )
}

export { Calendar, CalendarDayButton }
import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { ChevronRight, MoreHorizontal } from 'lucide-react'

import { cn } from '@/lib/utils'

function Breadcrumb({ ...props }: React.ComponentProps<'nav'>) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<'ol'>) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        'text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5',
        className,
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn('inline-flex items-center gap-1.5', className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<'a'> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : 'a'

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn('hover:text-foreground transition-colors', className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn('text-foreground font-normal', className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn('[&>svg]:size-3.5', className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn('flex size-9 items-center justify-center', className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
'use client'

import * as React from 'react'
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group'
import { CircleIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn('grid gap-3', className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        'border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }
'use client'

import * as React from 'react'
import { Command as CommandPrimitive } from 'cmdk'
import { SearchIcon } from 'lucide-react'

import { cn } from '@/lib/utils'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        'bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md',
        className,
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = 'Command Palette',
  description = 'Search for a command to run...',
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
  className?: string
  showCloseButton?: boolean
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn('overflow-hidden p-0', className)}
        showCloseButton={showCloseButton}
      >
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          'placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50',
          className,
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        'max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto',
        className,
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        'text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium',
        className,
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn('bg-border -mx-1 h-px', className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        'text-muted-foreground ml-auto text-xs tracking-widest',
        className,
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'
import { Separator } from '@/components/ui/separator'

function ItemGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      role="list"
      data-slot="item-group"
      className={cn('group/item-group flex flex-col', className)}
      {...props}
    />
  )
}

function ItemSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="item-separator"
      orientation="horizontal"
      className={cn('my-0', className)}
      {...props}
    />
  )
}

const itemVariants = cva(
  'group/item flex items-center border border-transparent text-sm rounded-md transition-colors [a&]:hover:bg-accent/50 [a&]:transition-colors duration-100 flex-wrap outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline: 'border-border',
        muted: 'bg-muted/50',
      },
      size: {
        default: 'p-4 gap-4 ',
        sm: 'py-3 px-4 gap-2.5',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
)

function Item({
  className,
  variant = 'default',
  size = 'default',
  asChild = false,
  ...props
}: React.ComponentProps<'div'> &
  VariantProps<typeof itemVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'div'
  return (
    <Comp
      data-slot="item"
      data-variant={variant}
      data-size={size}
      className={cn(itemVariants({ variant, size, className }))}
      {...props}
    />
  )
}

const itemMediaVariants = cva(
  'flex shrink-0 items-center justify-center gap-2 group-has-[[data-slot=item-description]]/item:self-start [&_svg]:pointer-events-none group-has-[[data-slot=item-description]]/item:translate-y-0.5',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        icon: "size-8 border rounded-sm bg-muted [&_svg:not([class*='size-'])]:size-4",
        image:
          'size-10 rounded-sm overflow-hidden [&_img]:size-full [&_img]:object-cover',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
)

function ItemMedia({
  className,
  variant = 'default',
  ...props
}: React.ComponentProps<'div'> & VariantProps<typeof itemMediaVariants>) {
  return (
    <div
      data-slot="item-media"
      data-variant={variant}
      className={cn(itemMediaVariants({ variant, className }))}
      {...props}
    />
  )
}

function ItemContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="item-content"
      className={cn(
        'flex flex-1 flex-col gap-1 [&+[data-slot=item-content]]:flex-none',
        className,
      )}
      {...props}
    />
  )
}

function ItemTitle({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="item-title"
      className={cn(
        'flex w-fit items-center gap-2 text-sm leading-snug font-medium',
        className,
      )}
      {...props}
    />
  )
}

function ItemDescription({ className, ...props }: React.ComponentProps<'p'>) {
  return (
    <p
      data-slot="item-description"
      className={cn(
        'text-muted-foreground line-clamp-2 text-sm leading-normal font-normal text-balance',
        '[&>a:hover]:text-primary [&>a]:underline [&>a]:underline-offset-4',
        className,
      )}
      {...props}
    />
  )
}

function ItemActions({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="item-actions"
      className={cn('flex items-center gap-2', className)}
      {...props}
    />
  )
}

function ItemHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="item-header"
      className={cn(
        'flex basis-full items-center justify-between gap-2',
        className,
      )}
      {...props}
    />
  )
}

function ItemFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="item-footer"
      className={cn(
        'flex basis-full items-center justify-between gap-2',
        className,
      )}
      {...props}
    />
  )
}

export {
  Item,
  ItemMedia,
  ItemContent,
  ItemActions,
  ItemGroup,
  ItemSeparator,
  ItemTitle,
  ItemDescription,
  ItemHeader,
  ItemFooter,
}
'use client'

import * as React from 'react'
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group'
import { type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'
import { toggleVariants } from '@/components/ui/toggle'

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: 'default',
  variant: 'default',
})

function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn(
        'group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs',
        className,
      )}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
}

function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        'min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l',
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
}

export { ToggleGroup, ToggleGroupItem }
'use client'

import * as React from 'react'
import * as AvatarPrimitive from '@radix-ui/react-avatar'

import { cn } from '@/lib/utils'

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        'relative flex size-8 shrink-0 overflow-hidden rounded-full',
        className,
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn('aspect-square size-full', className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        'bg-muted flex size-full items-center justify-center rounded-full',
        className,
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
'use client'

import * as React from 'react'
import * as MenubarPrimitive from '@radix-ui/react-menubar'
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn(
        'bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs',
        className,
      )}
      {...props}
    />
  )
}

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  )
}

function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn(
        'focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none',
        className,
      )}
      {...props}
    />
  )
}

function MenubarContent({
  className,
  align = 'start',
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-md',
          className,
        )}
        {...props}
      />
    </MenubarPortal>
  )
}

function MenubarItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean
  variant?: 'default' | 'destructive'
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}

function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}

function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn(
        'px-2 py-1.5 text-sm font-medium data-[inset]:pl-8',
        className,
      )}
      {...props}
    />
  )
}

function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  )
}

function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn(
        'text-muted-foreground ml-auto text-xs tracking-widest',
        className,
      )}
      {...props}
    />
  )
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn(
        'focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8',
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}

function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg',
        className,
      )}
      {...props}
    />
  )
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
}
import { cn } from '@/lib/utils'

function Kbd({ className, ...props }: React.ComponentProps<'kbd'>) {
  return (
    <kbd
      data-slot="kbd"
      className={cn(
        'bg-muted w-fit text-muted-foreground pointer-events-none inline-flex h-5 min-w-5 items-center justify-center gap-1 rounded-sm px-1 font-sans text-xs font-medium select-none',
        "[&_svg:not([class*='size-'])]:size-3",
        '[[data-slot=tooltip-content]_&]:bg-background/20 [[data-slot=tooltip-content]_&]:text-background dark:[[data-slot=tooltip-content]_&]:bg-background/10',
        className,
      )}
      {...props}
    />
  )
}

function KbdGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <kbd
      data-slot="kbd-group"
      className={cn('inline-flex items-center gap-1', className)}
      {...props}
    />
  )
}

export { Kbd, KbdGroup }
'use client'

import * as React from 'react'
import * as DialogPrimitive from '@radix-ui/react-dialog'
import { XIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className,
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg',
          className,
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-header"
      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        'flex flex-col-reverse gap-2 sm:flex-row sm:justify-end',
        className,
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn('text-lg leading-none font-semibold', className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'

const badgeVariants = cva(
  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',
        destructive:
          'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<'span'> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'span'

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
'use client'

import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, VariantProps } from 'class-variance-authority'
import { PanelLeftIcon } from 'lucide-react'

import { useIsMobile } from '@/hooks/use-mobile'
import { cn } from '@/lib/utils'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Separator } from '@/components/ui/separator'
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet'
import { Skeleton } from '@/components/ui/skeleton'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip'

const SIDEBAR_COOKIE_NAME = 'sidebar_state'
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = '16rem'
const SIDEBAR_WIDTH_MOBILE = '18rem'
const SIDEBAR_WIDTH_ICON = '3rem'
const SIDEBAR_KEYBOARD_SHORTCUT = 'b'

type SidebarContextProps = {
  state: 'expanded' | 'collapsed'
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error('useSidebar must be used within a SidebarProvider.')
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === 'function' ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open],
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener('keydown', handleKeyDown)
    return () => window.removeEventListener('keydown', handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? 'expanded' : 'collapsed'

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar],
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH,
              '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            'group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full',
            className,
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = 'left',
  variant = 'sidebar',
  collapsible = 'offcanvas',
  className,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  side?: 'left' | 'right'
  variant?: 'sidebar' | 'floating' | 'inset'
  collapsible?: 'offcanvas' | 'icon' | 'none'
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === 'none') {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          'bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col',
          className,
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === 'collapsed' ? collapsible : ''}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          'relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear',
          'group-data-[collapsible=offcanvas]:w-0',
          'group-data-[side=right]:rotate-180',
          variant === 'floating' || variant === 'inset'
            ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon)',
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          'fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex',
          side === 'left'
            ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'
            : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',
          // Adjust the padding for floating and inset variants.
          variant === 'floating' || variant === 'inset'
            ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l',
          className,
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn('size-7', className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<'button'>) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        'hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex',
        'in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize',
        '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',
        'hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full',
        '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',
        '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',
        className,
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<'main'>) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        'bg-background relative flex w-full flex-1 flex-col',
        'md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2',
        className,
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn('bg-background h-8 w-full shadow-none', className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn('bg-sidebar-border mx-2 w-auto', className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',
        className,
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn('relative flex w-full min-w-0 flex-col p-2', className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'div'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'div'

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        'text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',
        className,
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'button'

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 md:after:hidden',
        'group-data-[collapsible=icon]:hidden',
        className,
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn('w-full text-sm', className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn('flex w-full min-w-0 flex-col gap-1', className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn('group/menu-item relative', className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',
        outline:
          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',
      },
      size: {
        default: 'h-8 text-sm',
        sm: 'h-7 text-xs',
        lg: 'h-12 text-sm group-data-[collapsible=icon]:p-0!',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = 'default',
  size = 'default',
  tooltip,
  className,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : 'button'
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === 'string') {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== 'collapsed' || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : 'button'

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        // Increases the hit area of the button on mobile.
        'after:absolute after:-inset-2 md:after:hidden',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        showOnHover &&
          'peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0',
        className,
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        'text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none',
        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        className,
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<'div'> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn('flex h-8 items-center gap-2 rounded-md px-2', className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            '--skeleton-width': width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        'border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5',
        'group-data-[collapsible=icon]:hidden',
        className,
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn('group/menu-sub-item relative', className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = 'md',
  isActive = false,
  className,
  ...props
}: React.ComponentProps<'a'> & {
  asChild?: boolean
  size?: 'sm' | 'md'
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : 'a'

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',
        size === 'sm' && 'text-xs',
        size === 'md' && 'text-sm',
        'group-data-[collapsible=icon]:hidden',
        className,
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
'use client'

import * as React from 'react'

import { cn } from '@/lib/utils'

function Table({ className, ...props }: React.ComponentProps<'table'>) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn('w-full caption-bottom text-sm', className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<'thead'>) {
  return (
    <thead
      data-slot="table-header"
      className={cn('[&_tr]:border-b', className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<'tbody'>) {
  return (
    <tbody
      data-slot="table-body"
      className={cn('[&_tr:last-child]:border-0', className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<'tfoot'>) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        'bg-muted/50 border-t font-medium [&>tr]:last:border-b-0',
        className,
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<'tr'>) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        'hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors',
        className,
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<'th'>) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        'text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className,
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<'td'>) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        'p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className,
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<'caption'>) {
  return (
    <caption
      data-slot="table-caption"
      className={cn('text-muted-foreground mt-4 text-sm', className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
'use client'

import * as React from 'react'
import * as SeparatorPrimitive from '@radix-ui/react-separator'

import { cn } from '@/lib/utils'

function Separator({
  className,
  orientation = 'horizontal',
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',
        className,
      )}
      {...props}
    />
  )
}

export { Separator }
import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive:
          'bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost:
          'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9',
        'icon-sm': 'size-8',
        'icon-lg': 'size-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : 'button'

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
'use client'

import * as React from 'react'
import * as TogglePrimitive from '@radix-ui/react-toggle'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/lib/utils'

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline:
          'border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-9 px-2 min-w-9',
        sm: 'h-8 px-1.5 min-w-8',
        lg: 'h-10 px-2.5 min-w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
)

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Toggle, toggleVariants }
'use client'

import * as React from 'react'
import * as ToastPrimitives from '@radix-ui/react-toast'
import { cva, type VariantProps } from 'class-variance-authority'
import { X } from 'lucide-react'

import { cn } from '@/lib/utils'

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className,
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',
      className,
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
'use client'

import * as React from 'react'
import * as CheckboxPrimitive from '@radix-ui/react-checkbox'
import { CheckIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        'peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }
import { Loader2Icon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Spinner({ className, ...props }: React.ComponentProps<'svg'>) {
  return (
    <Loader2Icon
      role="status"
      aria-label="Loading"
      className={cn('size-4 animate-spin', className)}
      {...props}
    />
  )
}

export { Spinner }
'use client'

import * as CollapsiblePrimitive from '@radix-ui/react-collapsible'

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
'use client'

import * as React from 'react'
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu'
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: 'default' | 'destructive'
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        'px-2 py-1.5 text-sm font-medium data-[inset]:pl-8',
        className,
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        'text-muted-foreground ml-auto text-xs tracking-widest',
        className,
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg',
        className,
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
'use client'

import * as React from 'react'
import * as SelectPrimitive from '@radix-ui/react-select'
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = 'default',
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: 'sm' | 'default'
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = 'popper',
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md',
          position === 'popper' &&
            'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
          className,
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            'p-1',
            position === 'popper' &&
              'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1',
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn('text-muted-foreground px-2 py-1.5 text-xs', className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className,
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn('bg-border pointer-events-none -mx-1 my-1 h-px', className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        'flex cursor-default items-center justify-center py-1',
        className,
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        'flex cursor-default items-center justify-center py-1',
        className,
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
import * as React from 'react'

import { cn } from '@/lib/utils'

function Textarea({ className, ...props }: React.ComponentProps<'textarea'>) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        'border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        className,
      )}
      {...props}
    />
  )
}

export { Textarea }
import * as React from 'react'

import { cn } from '@/lib/utils'

function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        'file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        'focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]',
        'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',
        className,
      )}
      {...props}
    />
  )
}

export { Input }
import { cn } from '@/lib/utils'

function Skeleton({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="skeleton"
      className={cn('bg-accent animate-pulse rounded-md', className)}
      {...props}
    />
  )
}

export { Skeleton }
'use client'

import * as React from 'react'
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu'
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react'

import { cn } from '@/lib/utils'

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg',
        className,
      )}
      {...props}
    />
  )
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',
          className,
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}

function ContextMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: 'default' | 'destructive'
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  )
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        'text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8',
        className,
      )}
      {...props}
    />
  )
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  )
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        'text-muted-foreground ml-auto text-xs tracking-widest',
        className,
      )}
      {...props}
    />
  )
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
'use client'

import * as React from 'react'
import * as LabelPrimitive from '@radix-ui/react-label'
import { Slot } from '@radix-ui/react-slot'
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from 'react-hook-form'

import { cn } from '@/lib/utils'
import { Label } from '@/components/ui/label'

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>')
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
)

function FormItem({ className, ...props }: React.ComponentProps<'div'>) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn('grid gap-2', className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn('data-[error=true]:text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<'p'>) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<'p'>) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? '') : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn('text-destructive text-sm', className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
'use client'

import * as React from 'react'
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from 'embla-carousel-react'
import { ArrowLeft, ArrowRight } from 'lucide-react'

import { cn } from '@/lib/utils'
import { Button } from '@/components/ui/button'

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: 'horizontal' | 'vertical'
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error('useCarousel must be used within a <Carousel />')
  }

  return context
}

function Carousel({
  orientation = 'horizontal',
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<'div'> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === 'horizontal' ? 'x' : 'y',
    },
    plugins,
  )
  const [canScrollPrev, setCanScrollPrev] = React.useState(false)
  const [canScrollNext, setCanScrollNext] = React.useState(false)

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return
    setCanScrollPrev(api.canScrollPrev())
    setCanScrollNext(api.canScrollNext())
  }, [])

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev()
  }, [api])

  const scrollNext = React.useCallback(() => {
    api?.scrollNext()
  }, [api])

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === 'ArrowLeft') {
        event.preventDefault()
        scrollPrev()
      } else if (event.key === 'ArrowRight') {
        event.preventDefault()
        scrollNext()
      }
    },
    [scrollPrev, scrollNext],
  )

  React.useEffect(() => {
    if (!api || !setApi) return
    setApi(api)
  }, [api, setApi])

  React.useEffect(() => {
    if (!api) return
    onSelect(api)
    api.on('reInit', onSelect)
    api.on('select', onSelect)

    return () => {
      api?.off('select', onSelect)
    }
  }, [api, onSelect])

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === 'y' ? 'vertical' : 'horizontal'),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn('relative', className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  )
}

function CarouselContent({ className, ...props }: React.ComponentProps<'div'>) {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div
      ref={carouselRef}
      className="overflow-hidden"
      data-slot="carousel-content"
    >
      <div
        className={cn(
          'flex',
          orientation === 'horizontal' ? '-ml-4' : '-mt-4 flex-col',
          className,
        )}
        {...props}
      />
    </div>
  )
}

function CarouselItem({ className, ...props }: React.ComponentProps<'div'>) {
  const { orientation } = useCarousel()

  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        'min-w-0 shrink-0 grow-0 basis-full',
        orientation === 'horizontal' ? 'pl-4' : 'pt-4',
        className,
      )}
      {...props}
    />
  )
}

function CarouselPrevious({
  className,
  variant = 'outline',
  size = 'icon',
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        'absolute size-8 rounded-full',
        orientation === 'horizontal'
          ? 'top-1/2 -left-12 -translate-y-1/2'
          : '-top-12 left-1/2 -translate-x-1/2 rotate-90',
        className,
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
}

function CarouselNext({
  className,
  variant = 'outline',
  size = 'icon',
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        'absolute size-8 rounded-full',
        orientation === 'horizontal'
          ? 'top-1/2 -right-12 -translate-y-1/2'
          : '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
        className,
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight />
      <span className="sr-only">Next slide</span>
    </Button>
  )
}

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
"use client"

import React from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
}

export class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  ErrorBoundaryState
> {
  constructor(props: { children: React.ReactNode }) {
    super(props)
    this.state = { hasError: false, error: null }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("ErrorBoundary caught an error:", error, errorInfo)
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen flex items-center justify-center p-4">
          <Card className="w-full max-w-md">
            <CardHeader>
              <CardTitle>åº”ç”¨é”™è¯¯</CardTitle>
              <CardDescription>
                å‘ç”Ÿäº†ä¸€ä¸ªå®¢æˆ·ç«¯é”™è¯¯ã€‚è¯·å°è¯•åˆ·æ–°é¡µé¢ã€‚
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              {this.state.error && (
                <div className="bg-slate-100 p-3 rounded text-sm font-mono overflow-auto max-h-40">
                  <div className="text-red-600 font-semibold mb-2">
                    {this.state.error.name}: {this.state.error.message}
                  </div>
                  {this.state.error.stack && (
                    <pre className="text-xs text-slate-600 whitespace-pre-wrap">
                      {this.state.error.stack.split('\n').slice(0, 5).join('\n')}
                    </pre>
                  )}
                </div>
              )}
              <div className="flex gap-2">
                <Button
                  onClick={() => {
                    this.setState({ hasError: false, error: null })
                    window.location.reload()
                  }}
                  className="flex-1"
                >
                  åˆ·æ–°é¡µé¢
                </Button>
                <Button
                  variant="outline"
                  onClick={() => {
                    this.setState({ hasError: false, error: null })
                  }}
                >
                  é‡è¯•
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      )
    }

    return this.props.children
  }
}

"use client"

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { useEffect, useState, useMemo, useCallback, useRef } from "react"
import { Alert, AlertDescription } from "@/components/ui/alert"
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog"
import { formatDateString } from "@/lib/utils"
import { useToast } from "@/hooks/use-toast"

interface StatisticsCardsProps {
  currentDate: Date
  chatId?: string
  onBillDataChange?: (data: any) => void // ğŸ”¥ ä¼ é€’è´¦å•æ•°æ®ç»™çˆ¶ç»„ä»¶
}

export function StatisticsCards({ currentDate, chatId, onBillDataChange }: StatisticsCardsProps) {
  const [data, setData] = useState<any | null>(null)
  const [pick, setPick] = useState<number | ''>('')
  const [settings, setSettings] = useState<any>(null)
  const [deleting, setDeleting] = useState(false)
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false)
  const { toast } = useToast()
  // ğŸ”¥ ä½¿ç”¨ useRef ä¿å­˜å›è°ƒï¼Œé¿å…ä¾èµ–å˜åŒ–å¯¼è‡´é‡æ–°æ¸²æŸ“
  const onBillDataChangeRef = useRef(onBillDataChange)
  useEffect(() => {
    onBillDataChangeRef.current = onBillDataChange
  }, [onBillDataChange])
  
  // ğŸ”¥ ä»URLå‚æ•°è¯»å–è´¦å•ç´¢å¼•ï¼ˆç´¯è®¡æ¨¡å¼ï¼‰
  useEffect(() => {
    if (typeof window === 'undefined') return
    const params = new URLSearchParams(window.location.search)
    const billParam = params.get('bill')
    if (billParam) {
      const billIndex = Number(billParam)
      if (!isNaN(billIndex) && billIndex > 0) {
        setPick(billIndex)
      }
    }
  }, [])

  // ğŸ”¥ åŠ è½½ç¾¤ç»„è®¾ç½®ï¼ˆåˆ¤æ–­æ˜¯å¦ç´¯è®¡æ¨¡å¼ï¼‰- ä½¿ç”¨useMemoç¼“å­˜ç»“æœ
  useEffect(() => {
    if (!chatId) return
    let cancelled = false
    const load = async () => {
      try {
        const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/settings`)
        if (res.ok && !cancelled) {
          const json = await res.json()
          setSettings(json.settings)
        }
      } catch (e) {
        if (!cancelled) console.error('åŠ è½½è®¾ç½®å¤±è´¥', e)
      }
    }
    load()
    return () => { cancelled = true }
  }, [chatId])

  // ğŸ”¥ ä½¿ç”¨ useMemo ä¼˜åŒ–æ—¥æœŸå­—ç¬¦ä¸²è®¡ç®—
  const dateStr = useMemo(() => formatDateString(currentDate), [currentDate])

  useEffect(() => {
    const controller = new AbortController()
    const load = async () => {
      try {
        const params = new URLSearchParams()
        params.set('date', dateStr)
        if (pick) params.set('bill', String(pick))
        if (chatId) params.set('chatId', chatId)
        const res = await fetch(`/api/stats/today?${params.toString()}`, { signal: controller.signal })
        if (!res.ok) throw new Error('failed')
        const json = await res.json()
        setData(json)
        // ğŸ”¥ ä¼ é€’è´¦å•æ—¶é—´æ•°æ®ç»™çˆ¶ç»„ä»¶ï¼ˆä»…ä¼ é€’å¿…è¦æ•°æ®ï¼‰
        if (onBillDataChangeRef.current) {
          onBillDataChangeRef.current(json)
        }
        // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šåªåœ¨æ²¡æœ‰é€‰æ‹©æ—¶æ‰è‡ªåŠ¨é€‰æ‹©ï¼Œé¿å…ä¸å¿…è¦çš„çŠ¶æ€æ›´æ–°
        if (!pick) {
          if (json?.selectedBillIndex) {
            setPick(json.selectedBillIndex)
          } else if (json?.billNumber > 0) {
            setPick(json.billNumber)
          } else {
            setPick('')
          }
        }
      } catch (e) {
        if ((e as any).name !== 'AbortError') console.error('åŠ è½½æ•°æ®å¤±è´¥', e)
      }
    }
    load()
    return () => controller.abort()
  }, [dateStr, pick, chatId]) // ğŸ”¥ ç§»é™¤ onBillDataChange ä¾èµ–ï¼Œä½¿ç”¨ useRef æˆ–ç›´æ¥è°ƒç”¨

  // ğŸ”¥ ä½¿ç”¨ useMemo ä¼˜åŒ–è®¡ç®—ç»“æœ
  const isCumulativeMode = useMemo(() => settings?.accountingMode === 'CARRY_OVER', [settings?.accountingMode])
  const hasCarryOver = useMemo(() => Boolean(data?.carryOver && data.carryOver > 0), [data?.carryOver])

  const view = useMemo(() => {
    if (!data) return null as any
    const list = Array.isArray(data.bills) ? data.bills : []
    if (!list.length) return data
    const idx = pick ? (Number(pick) - 1) : (list.length - 1)
    const b = list[idx]
    if (!b) return data
    // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…åˆ›å»ºæ–°å¯¹è±¡ï¼Œç›´æ¥åˆå¹¶
    return { ...data, ...b }
  }, [data, pick])

  // ğŸ”¥ ä½¿ç”¨ useCallback ä¼˜åŒ–äº‹ä»¶å¤„ç†
  const handleBillChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    const v = Number(e.target.value)
    setPick(v)
    if (v > 0) {
      window.dispatchEvent(new CustomEvent('goto-bill', { detail: { type: 'income', index: v } }))
    }
  }, [])

  // ğŸ”¥ åˆ é™¤å½“å‰è´¦å•
  const handleDeleteBill = useCallback(async () => {
    if (!data?.selectedBillId || !pick) {
      toast({ title: 'é”™è¯¯', description: 'è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„è´¦å•', variant: 'destructive' })
      return
    }
    
    setDeleteDialogOpen(true)
  }, [data, pick, toast])
  
  // ğŸ”¥ ç¡®è®¤åˆ é™¤
  const handleConfirmDelete = useCallback(async () => {
    if (!data?.selectedBillId) return
    
    setDeleting(true)
    setDeleteDialogOpen(false)
    try {
      const res = await fetch(`/api/bills/${encodeURIComponent(data.selectedBillId)}`, { method: 'DELETE' })
      if (res.status === 204) {
        toast({ title: 'æˆåŠŸ', description: 'è´¦å•å·²åˆ é™¤' })
        // ğŸ”¥ åˆ·æ–°æ•°æ®
        window.location.reload()
      } else {
        const msg = await res.text().catch(() => '')
        toast({ title: 'é”™è¯¯', description: `åˆ é™¤å¤±è´¥ï¼š${msg || 'Server error'}`, variant: 'destructive' })
      }
    } catch (e) {
      toast({ title: 'é”™è¯¯', description: 'åˆ é™¤å¤±è´¥ï¼šç½‘ç»œé”™è¯¯', variant: 'destructive' })
    } finally {
      setDeleting(false)
    }
  }, [data, toast])

  if (!data || !view) return null
  
  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-lg flex items-center gap-2">
          ä»Šæ—¥è´¦å•ç»Ÿè®¡
          {/* ğŸ”¥ ç´¯è®¡æ¨¡å¼æé†’ */}
          {isCumulativeMode && (
            <span className="text-xs px-2 py-0.5 bg-amber-100 text-amber-700 rounded-full">
              ç´¯è®¡æ¨¡å¼
            </span>
          )}
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-3">
        
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div className="flex justify-between items-center p-3 bg-slate-50 rounded-lg">
            <span className="text-sm text-slate-600">ç¬¬</span>
            <div className="flex items-center gap-2">
              <span className="text-lg font-semibold text-slate-900">{(data.billNumber ?? 0)} ç¬”è´¦å•</span>
              {data.billNumber > 0 && (
                <>
                  <select
                    className="text-xs border border-slate-300 rounded px-2 py-1"
                    value={pick as any}
                    onChange={handleBillChange}
                  >
                    <option value="">é€‰æ‹©ç¬¬å‡ ç¬”</option>
                    {Array.from({ length: data.billNumber }, (_, i) => {
                      const n = i + 1
                      const label = Array.isArray(data.billLabels) && data.billLabels[i] 
                        ? data.billLabels[i] 
                        : `ç¬¬ ${n} ç¬”`
                      return (
                        <option key={n} value={n}>{label}</option>
                      )
                    })}
                  </select>
                  {pick && (
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={handleDeleteBill}
                      disabled={deleting}
                      className="text-xs h-7 px-2"
                    >
                      {deleting ? 'åˆ é™¤ä¸­...' : 'åˆ é™¤å½“å‰è´¦å•'}
                    </Button>
                  )}
                </>
              )}
            </div>
          </div>

          <div className="flex justify-between items-center p-3 bg-slate-50 rounded-lg">
            <span className="text-sm text-slate-600">æ€»å…¥æ¬¾é‡‘é¢</span>
            <span className="text-lg font-semibold text-green-600">{(view.totalIncome ?? 0).toLocaleString()}</span>
          </div>

          <div className="flex justify-between items-center p-3 bg-slate-50 rounded-lg">
            <span className="text-sm text-slate-600">æ±‡ç‡</span>
            <span className="text-lg font-semibold text-slate-900">{view.exchangeRate ?? 0}</span>
          </div>

          <div className="flex justify-between items-center p-3 bg-slate-50 rounded-lg">
            <span className="text-sm text-slate-600">è´¹ç‡</span>
            <span className="text-lg font-semibold text-slate-900">{view.feeRate ?? 0}%</span>
          </div>
        </div>

        <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 pt-2">
          <div className="p-3 bg-blue-50 rounded-lg">
            <div className="text-xs text-slate-600 mb-1">åº”ä¸‹å‘</div>
            <div className="font-semibold text-slate-900">{(view.shouldDispatch ?? 0).toLocaleString()}</div>
            <div className="text-sm text-blue-600">{(view.shouldDispatchUSDT ?? 0).toFixed(2)} USDT</div>
          </div>

          <div className="p-3 bg-green-50 rounded-lg">
            <div className="text-xs text-slate-600 mb-1">å·²ä¸‹å‘</div>
            <div className="font-semibold text-slate-900">{(view.dispatched ?? 0).toLocaleString()}</div>
            <div className="text-sm text-green-600">{(view.dispatchedUSDT ?? 0).toFixed(2)} USDT</div>
          </div>

          <div className="p-3 bg-orange-50 rounded-lg">
            <div className="text-xs text-slate-600 mb-1">æœªä¸‹å‘</div>
            <div className="font-semibold text-slate-900">{(view.notDispatched ?? 0).toLocaleString()}</div>
            <div className="text-sm text-orange-600">{(view.notDispatchedUSDT ?? 0).toFixed(2)} USDT</div>
          </div>
        </div>
        
      </CardContent>
      
      {/* ğŸ”¥ åˆ é™¤ç¡®è®¤å¯¹è¯æ¡† */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>ç¡®è®¤åˆ é™¤</AlertDialogTitle>
            <AlertDialogDescription>
              ç¡®å®šè¦åˆ é™¤å½“å‰è´¦å•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setDeleteDialogOpen(false)}>
              å–æ¶ˆ
            </AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDelete} disabled={deleting}>
              {deleting ? 'åˆ é™¤ä¸­...' : 'ç¡®è®¤åˆ é™¤'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </Card>
  )
}
"use client"

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { useEffect, useState, useMemo } from "react"
import { formatDateString } from "@/lib/utils"

interface CategoryStatsProps {
  currentDate: Date
  chatId?: string
}

export function CategoryStats({ currentDate, chatId }: CategoryStatsProps) {
  const [data, setData] = useState<any | null>(null)

  // ğŸ”¥ ä½¿ç”¨ useMemo ä¼˜åŒ–æ—¥æœŸå­—ç¬¦ä¸²è®¡ç®—
  const dateStr = useMemo(() => formatDateString(currentDate), [currentDate])

  useEffect(() => {
    const controller = new AbortController()
    const load = async () => {
      try {
        const params = new URLSearchParams()
        params.set('date', dateStr)
        if (chatId) params.set('chatId', chatId)
        const res = await fetch(`/api/stats/today?${params.toString()}`, { signal: controller.signal })
        if (!res.ok) throw new Error('failed')
        const json = await res.json()
        setData(json)
      } catch (e) {
        if ((e as any).name !== 'AbortError') console.error(e)
      }
    }
    load()
    return () => controller.abort()
  }, [dateStr, chatId])

  if (!data) return null

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
      <Card>
        <CardHeader>
          <CardTitle className="text-base">å…¥æ¬¾å›å¤äººåˆ†ç±»</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            {Object.entries(data.incomeByReplier).map(([name, amount]) => (
              <div key={name} className="flex justify-between items-center p-2 bg-slate-50 rounded">
                <span className="text-sm text-slate-600">{name}</span>
                <span className="text-sm font-semibold text-slate-900">{(amount as number).toLocaleString()}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle className="text-base">å…¥æ¬¾æ“ä½œäººåˆ†ç±»</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            {Object.entries(data.incomeByOperator).map(([name, amount]) => (
              <div key={name} className="flex justify-between items-center p-2 bg-slate-50 rounded">
                <span className="text-sm text-slate-600">{name}</span>
                <span className="text-sm font-semibold text-slate-900">{(amount as number).toLocaleString()}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle className="text-base">å…¥æ¬¾æ±‡ç‡åˆ†ç±»</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            {Object.entries(data.incomeByRate).map(([rate, amount]) => (
              <div key={rate} className="flex justify-between items-center p-2 bg-slate-50 rounded">
                <span className="text-sm text-slate-600">æ±‡ç‡ {rate}</span>
                <span className="text-sm font-semibold text-slate-900">{(amount as number).toLocaleString()}</span>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle className="text-base">ä¸‹å‘æ“ä½œäººåˆ†ç±»</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            {Object.entries(data.dispatchByOperator || {}).length > 0 ? (
              Object.entries(data.dispatchByOperator).map(([name, amount]) => (
                <div key={name} className="flex justify-between items-center p-2 bg-slate-50 rounded">
                  <span className="text-sm text-slate-600">{name}</span>
                  <span className="text-sm font-semibold text-slate-900">{(amount as number).toLocaleString()}</span>
                </div>
              ))
            ) : (
              <div className="text-sm text-slate-500 text-center py-4">æš‚æ— æ•°æ®</div>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
"use client"

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Button } from "@/components/ui/button"
import { useEffect, useState, useMemo, useCallback } from "react"
import { formatDateString } from "@/lib/utils"

interface TransactionTablesProps {
  currentDate: Date
  chatId?: string
}

export function TransactionTables({ currentDate, chatId }: TransactionTablesProps) {
  const [data, setData] = useState<any | null>(null)
  const [pick, setPick] = useState<number | ''>('')
  const [incomePaged, setIncomePaged] = useState(true) // ğŸ”¥ å…¥æ¬¾è®°å½•æ˜¯å¦åˆ†é¡µ
  const [dispatchPaged, setDispatchPaged] = useState(true) // ğŸ”¥ ä¸‹å‘è®°å½•æ˜¯å¦åˆ†é¡µ
  const [incomePage, setIncomePage] = useState(1) // ğŸ”¥ å…¥æ¬¾è®°å½•å½“å‰é¡µ
  const [dispatchPage, setDispatchPage] = useState(1) // ğŸ”¥ ä¸‹å‘è®°å½•å½“å‰é¡µ
  const PAGE_SIZE = 10 // ğŸ”¥ æ¯é¡µ10æ¡è®°å½•
  // ğŸ”¥ åˆ é™¤æ— ç”¨çš„ incomeRefsï¼Œä¸å†éœ€è¦é«˜äº®åŠŸèƒ½

  // ğŸ”¥ ä½¿ç”¨ useMemo ä¼˜åŒ–æ—¥æœŸå­—ç¬¦ä¸²å’Œæ˜¯å¦ä»Šå¤©çš„åˆ¤æ–­
  const dateStr = useMemo(() => formatDateString(currentDate), [currentDate])
  const isTodayDate = useMemo(() => {
    const today = new Date()
    return dateStr === formatDateString(today)
  }, [dateStr])

  // ğŸ”¥ ä½¿ç”¨ useCallback ä¼˜åŒ–äº‹ä»¶å¤„ç†
  const handleBillEvent = useCallback((ev: Event) => {
    const detail = (ev as CustomEvent).detail as { type?: string; index?: number }
    if (detail?.index && detail.index > 0) {
      setPick(detail.index)
    }
  }, [])

  // ğŸ”¥ ä¿®å¤ï¼šç›‘å¬è´¦å•é€‰æ‹©äº‹ä»¶ï¼Œç¡®ä¿ä¸ StatisticsCards ç»„ä»¶åŒæ­¥
  useEffect(() => {
    window.addEventListener('goto-bill', handleBillEvent as any)
    return () => window.removeEventListener('goto-bill', handleBillEvent as any)
  }, [handleBillEvent])
  
  // ğŸ”¥ ä¿®å¤ï¼šå½“æ—¥æœŸå˜åŒ–æ—¶ï¼Œé‡ç½® pick çŠ¶æ€ï¼Œé¿å…ä½¿ç”¨æ—§çš„è´¦å•ç´¢å¼•
  useEffect(() => {
    setPick('')
  }, [currentDate, chatId])

  useEffect(() => {
    const controller = new AbortController()
    const load = async () => {
      try {
        const params = new URLSearchParams()
        params.set('date', dateStr)
        if (pick) params.set('bill', String(pick))
        if (chatId) params.set('chatId', chatId)
        const res = await fetch(`/api/stats/today?${params.toString()}`, { signal: controller.signal })
        if (!res.ok) throw new Error('failed')
        const json = await res.json()
        setData(json)
        // ğŸ”¥ ä¿®å¤ï¼šåªåœ¨æ²¡æœ‰ä¸»åŠ¨é€‰æ‹©è´¦å•æ—¶æ‰è®¾ç½®é»˜è®¤å€¼
        if (!pick && json?.selectedBillIndex) {
          setPick(json.selectedBillIndex)
        }
      } catch (e) {
        if ((e as any).name !== 'AbortError') console.error(e)
      }
    }
    load()
    
    // ğŸ”¥ ä¼˜åŒ–ï¼šæ·»åŠ è½®è¯¢æœºåˆ¶ï¼Œæ¯5ç§’è‡ªåŠ¨åˆ·æ–°æ•°æ®ï¼ˆä»…å½“æ—¥æœŸæ˜¯ä»Šå¤©æ—¶ï¼‰
    let intervalId: NodeJS.Timeout | null = null
    if (isTodayDate) {
      intervalId = setInterval(() => {
        if (!controller.signal.aborted) {
          load().catch((e) => {
            if ((e as any).name !== 'AbortError') console.error(e)
          })
        }
      }, 5000) // æ¯5ç§’åˆ·æ–°ä¸€æ¬¡
    }
    
    return () => {
      controller.abort()
      if (intervalId) clearInterval(intervalId)
    }
  }, [dateStr, pick, chatId, isTodayDate])

  // ğŸ”¥ åˆ é™¤é«˜äº®é—ªçƒçš„æ— ç”¨é€»è¾‘

  if (!data) return null

  // ğŸ”¥ è®¡ç®—åˆ†é¡µæ•°æ®
  const incomeRecords = data.incomeRecords || []
  const dispatchRecords = data.dispatchRecords || []
  const incomeTotalPages = Math.ceil(incomeRecords.length / PAGE_SIZE)
  const dispatchTotalPages = Math.ceil(dispatchRecords.length / PAGE_SIZE)
  const incomeDisplayRecords = incomePaged 
    ? incomeRecords.slice((incomePage - 1) * PAGE_SIZE, incomePage * PAGE_SIZE)
    : incomeRecords
  const dispatchDisplayRecords = dispatchPaged
    ? dispatchRecords.slice((dispatchPage - 1) * PAGE_SIZE, dispatchPage * PAGE_SIZE)
    : dispatchRecords

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle className="text-lg">å…¥æ¬¾è®°å½•</CardTitle>
            <Button
              variant="outline"
              size="sm"
              onClick={() => {
                setIncomePaged(!incomePaged)
                setIncomePage(1)
              }}
              className="text-xs h-7"
            >
              {incomePaged ? 'å–æ¶ˆåˆ†é¡µ' : 'å¯ç”¨åˆ†é¡µ'}
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          <div className="overflow-x-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>æ—¶é—´</TableHead>
                  <TableHead>é‡‘é¢</TableHead>
                  <TableHead>å¤‡æ³¨</TableHead>
                  <TableHead>å›å¤äºº</TableHead>
                  <TableHead>æ“ä½œäºº</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {incomeDisplayRecords.length > 0 ? (
                  incomeDisplayRecords.map((record: any, index: number) => (
                    <TableRow key={index}>
                      <TableCell className="text-xs">{record.time}</TableCell>
                      <TableCell className="text-xs font-medium">{record.amount}</TableCell>
                      <TableCell className="text-xs text-slate-500">{record.remark || '-'}</TableCell>
                      <TableCell className="text-xs">{record.replier}</TableCell>
                      <TableCell className="text-xs">{record.operator}</TableCell>
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={5} className="text-center text-slate-500">
                      æš‚æ— æ•°æ®
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
            {incomePaged && incomeTotalPages > 1 && (
              <div className="flex justify-between items-center mt-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setIncomePage(p => Math.max(1, p - 1))}
                  disabled={incomePage === 1}
                  className="text-xs h-7"
                >
                  ä¸Šä¸€é¡µ
                </Button>
                <span className="text-xs text-slate-600">
                  ç¬¬ {incomePage} / {incomeTotalPages} é¡µï¼ˆå…± {incomeRecords.length} æ¡ï¼‰
                </span>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setIncomePage(p => Math.min(incomeTotalPages, p + 1))}
                  disabled={incomePage === incomeTotalPages}
                  className="text-xs h-7"
                >
                  ä¸‹ä¸€é¡µ
                </Button>
              </div>
            )}
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <CardTitle className="text-lg">ä¸‹å‘è®°å½•</CardTitle>
            <Button
              variant="outline"
              size="sm"
              onClick={() => {
                setDispatchPaged(!dispatchPaged)
                setDispatchPage(1)
              }}
              className="text-xs h-7"
            >
              {dispatchPaged ? 'å–æ¶ˆåˆ†é¡µ' : 'å¯ç”¨åˆ†é¡µ'}
            </Button>
          </div>
        </CardHeader>
        <CardContent>
          <div className="overflow-x-auto">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>æ—¶é—´</TableHead>
                  <TableHead>é‡‘é¢</TableHead>
                  <TableHead>å¤‡æ³¨</TableHead>
                  <TableHead>å›å¤äºº</TableHead>
                  <TableHead>æ“ä½œäºº</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {dispatchDisplayRecords.length > 0 ? (
                  dispatchDisplayRecords.map((record: any, index: number) => (
                    <TableRow key={index}>
                      <TableCell className="text-xs">{record.time}</TableCell>
                      <TableCell className="text-xs font-medium">{record.amount}</TableCell>
                      <TableCell className="text-xs text-slate-500">{record.remark || '-'}</TableCell>
                      <TableCell className="text-xs">{record.replier}</TableCell>
                      <TableCell className="text-xs">{record.operator}</TableCell>
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={5} className="text-center text-slate-500">
                      æš‚æ— æ•°æ®
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
            {dispatchPaged && dispatchTotalPages > 1 && (
              <div className="flex justify-between items-center mt-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setDispatchPage(p => Math.max(1, p - 1))}
                  disabled={dispatchPage === 1}
                  className="text-xs h-7"
                >
                  ä¸Šä¸€é¡µ
                </Button>
                <span className="text-xs text-slate-600">
                  ç¬¬ {dispatchPage} / {dispatchTotalPages} é¡µï¼ˆå…± {dispatchRecords.length} æ¡ï¼‰
                </span>
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setDispatchPage(p => Math.min(dispatchTotalPages, p + 1))}
                  disabled={dispatchPage === dispatchTotalPages}
                  className="text-xs h-7"
                >
                  ä¸‹ä¸€é¡µ
                </Button>
              </div>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}
"use client"

import type React from "react"

import { useState } from "react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Label } from "@/components/ui/label"

export function LoginForm() {
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [error, setError] = useState("")
  const [loading, setLoading] = useState(false)
  const router = useRouter()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError("")
    setLoading(true)
    try {
      const res = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      })
      if (!res.ok) {
        setError('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯')
        return
      }
      // Cookie-based session: simply redirect; optionally verify
      try {
        const me = await fetch('/api/auth/me', { cache: 'no-store' })
        if (!me.ok) {
          setError('ç™»å½•å¤±è´¥')
          return
        }
      } catch {}
      router.push('/dashboard')
    } catch {
      setError('ç½‘ç»œé”™è¯¯ï¼Œè¯·ç¨åé‡è¯•')
    } finally {
      setLoading(false)
    }
  }

  return (
    <Card className="w-full max-w-md mx-4">
      <CardHeader className="space-y-1">
        <CardTitle className="text-2xl font-bold text-center">è®°è´¦æœºå™¨äºº</CardTitle>
        <CardDescription className="text-center">è¯·ç™»å½•åå°ç®¡ç†ç³»ç»Ÿ</CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="username">ç”¨æˆ·å</Label>
            <Input
              id="username"
              type="text"
              placeholder="è¯·è¾“å…¥ç”¨æˆ·å"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="password">å¯†ç </Label>
            <Input
              id="password"
              type="password"
              placeholder="è¯·è¾“å…¥å¯†ç "
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          {error && <div className="text-sm text-red-500 text-center">{error}</div>}
          <Button type="submit" className="w-full" disabled={loading}>
            {loading ? "ç™»å½•ä¸­..." : "ç™»å½•"}
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}
"use client"

import type React from "react"
import { useState, useEffect, useMemo } from "react"

import { Button } from "@/components/ui/button"
import { Card } from "@/components/ui/card"
import { ChevronLeft, ChevronRight, Download, LogOut, Calendar } from "lucide-react"
import { exportToExcel } from "@/lib/export-excel"
import { useRouter } from "next/navigation"
import { formatDateString } from "@/lib/utils"

interface DashboardHeaderProps {
  currentDate: Date
  onPreviousDay: () => void
  onNextDay: () => void
  onViewSummary: () => void
  onLogout: () => void
  onDateChange: (date: Date) => void
  chatId?: string
  chatTitle?: string
  compact?: boolean // when true, hide date/export controls
  hideLogout?: boolean
  hideGroupButton?: boolean
  showBackHome?: boolean
  isAdmin?: boolean
  // ğŸ”¥ ç´¯è®¡æ¨¡å¼æ•°æ®
  billStartTime?: string
  billEndTime?: string
}

export function DashboardHeader({
  currentDate,
  onPreviousDay,
  onNextDay,
  onViewSummary,
  onLogout,
  onDateChange,
  chatId,
  chatTitle,
  compact,
  hideLogout,
  hideGroupButton,
  showBackHome,
  isAdmin,
  billStartTime,
  billEndTime,
}: DashboardHeaderProps) {
  const router = useRouter()
  const [dateRange, setDateRange] = useState<{ start: Date; end: Date } | null>(null)
  const [isCumulativeMode, setIsCumulativeMode] = useState(false)

  // ï¿½ï¿½ ä½¿ç”¨ useMemo ä¼˜åŒ–æ—¥æœŸå­—ç¬¦ä¸²è®¡ç®—
  const dateStr = useMemo(() => formatDateString(currentDate), [currentDate])

  // ğŸ”¥ åŠ è½½ç¾¤ç»„è®¾ç½®ï¼ˆåˆ¤æ–­æ˜¯å¦ç´¯è®¡æ¨¡å¼ï¼‰
  useEffect(() => {
    if (!chatId) return
    let cancelled = false
    const load = async () => {
      try {
        const res = await fetch(`/api/chats/${encodeURIComponent(chatId)}/settings`)
        if (res.ok && !cancelled) {
          const json = await res.json()
          setIsCumulativeMode(json.settings?.accountingMode === 'CARRY_OVER')
        }
      } catch (e) {
        if (!cancelled) console.error('åŠ è½½è®¾ç½®å¤±è´¥', e)
      }
    }
    load()
    return () => { cancelled = true }
  }, [chatId])

  // ğŸ”¥ ä»ç»Ÿè®¡APIè·å–å®é™…çš„æ—¥æœŸèŒƒå›´ï¼ˆè€ƒè™‘æ—¥åˆ‡æ—¶é—´ï¼‰- ä»…éç´¯è®¡æ¨¡å¼éœ€è¦
  useEffect(() => {
    if (!chatId || isCumulativeMode) return

    let cancelled = false
    const fetchDateRange = async () => {
      try {
        const params = new URLSearchParams()
        params.set('date', dateStr)
        params.set('chatId', chatId)
        const res = await fetch(`/api/stats/today?${params.toString()}`)
        if (res.ok && !cancelled) {
          const json = await res.json()
          if (json.dateRangeStart && json.dateRangeEnd) {
            setDateRange({
              start: new Date(json.dateRangeStart),
              end: new Date(json.dateRangeEnd)
            })
          }
        }
      } catch (e) {
        if (!cancelled) console.error('è·å–æ—¥æœŸèŒƒå›´å¤±è´¥', e)
      }
    }

    fetchDateRange()
    return () => { cancelled = true }
  }, [dateStr, chatId, isCumulativeMode])

  const formatDateTime = (date: Date) => {
    return date.toLocaleString("zh-CN", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false,
    })
  }

  // ğŸ”¥ ä½¿ç”¨ä»APIè·å–çš„æ—¥æœŸèŒƒå›´ï¼Œæˆ–ä½¿ç”¨é»˜è®¤å€¼
  const startDate = dateRange?.start || (() => {
    const d = new Date(currentDate)
    d.setHours(0, 0, 0, 0)
    return d
  })()

  const endDate = dateRange?.end || (() => {
    const d = new Date(currentDate)
    d.setDate(d.getDate() + 1)
    d.setHours(0, 0, 0, 0)
    return d
  })()

  const handleExport = () => {
    // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šå¦‚æœæä¾›äº†billIndexï¼Œåˆ™ä¼ é€’billå‚æ•°
    const params = new URLSearchParams(window.location.search)
    const billParam = params.get('bill')
    const billIndex = billParam ? Number(billParam) : undefined
    exportToExcel(currentDate, chatId, billIndex)
  }

  const handleDateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newDate = new Date(e.target.value)
    if (!isNaN(newDate.getTime())) {
      onDateChange(newDate)
    }
  }

  const formatDateForInput = (date: Date) => {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, "0")
    const day = String(date.getDate()).padStart(2, "0")
    return `${year}-${month}-${day}`
  }

  return (
    <Card className="p-6">
      <div className="flex flex-col gap-4">
        <div className="flex items-center justify-between flex-wrap gap-4">
          <div>
            <h1 className="text-2xl font-bold text-slate-900">è®°è´¦æœºå™¨äººåå°</h1>
            {chatTitle && (
              <div className="text-sm text-slate-600 mt-1">ç¾¤ç»„ï¼š{chatTitle}</div>
            )}
          </div>
          <div className="flex gap-2">
            {showBackHome && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => router.push('/dashboard')}
                title="è¿”å›ä¸»é¡µ"
              >è¿”å›ä¸»é¡µ</Button>
            )}
            {isAdmin && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => router.push('/admin/logs')}
                title="ç³»ç»Ÿæ—¥å¿—"
              >ç³»ç»Ÿæ—¥å¿—</Button>
            )}
            {!compact && (
              <Button variant="outline" size="sm" onClick={handleExport}>
                <Download className="w-4 h-4 mr-2" />
                ä¸‹è½½ Excel
              </Button>
            )}
            {isAdmin && compact && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => router.push('/security')}
                title="ä¿®æ”¹å¯†ç "
              >
                ğŸ” ä¿®æ”¹å¯†ç 
              </Button>
            )}
            {!hideLogout && (
              <Button variant="outline" size="sm" onClick={onLogout}>
                <LogOut className="w-4 h-4 mr-2" />
                é€€å‡ºç™»å½•
              </Button>
            )}
          </div>
        </div>

        {!compact && (
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
            {/* ğŸ”¥ æ•°æ®èŒƒå›´æ”¾åœ¨æœ€å·¦è¾¹ */}
            <div className="text-sm text-slate-600 bg-slate-50 px-3 py-2 rounded-md">
              {isCumulativeMode && billStartTime && billEndTime ? (
                // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šæ˜¾ç¤ºè´¦å•çš„å¼€å§‹æ—¶é—´åˆ°ç»“æŸæ—¶é—´
                <>æ•°æ®èŒƒå›´: {formatDateTime(new Date(billStartTime))} â€” {formatDateTime(new Date(billEndTime))}</>
              ) : dateRange ? (
                // ğŸ”¥ éç´¯è®¡æ¨¡å¼ï¼šæ˜¾ç¤ºæ—¥æœŸèŒƒå›´
                <>æ•°æ®èŒƒå›´: {formatDateTime(dateRange.start)} â€” {formatDateTime(dateRange.end)}</>
              ) : (
                <>æ•°æ®èŒƒå›´: åŠ è½½ä¸­...</>
              )}
            </div>

            {/* ğŸ”¥ éç´¯è®¡æ¨¡å¼ï¼šä¸Šä¸€å¤©/ä¸‹ä¸€å¤©å¯¼èˆª */}
            {!isCumulativeMode && (
              <div className="flex items-center gap-2 flex-wrap">
                <Button variant="outline" size="sm" onClick={onPreviousDay}>
                  <ChevronLeft className="w-4 h-4 mr-1" />
                  ä¸Šä¸€å¤©
                </Button>

                <div className="relative">
                  <input
                    type="date"
                    value={formatDateForInput(currentDate)}
                    onChange={handleDateChange}
                    max={formatDateForInput(new Date())} // ğŸ”¥ é™åˆ¶ï¼šä¸èƒ½é€‰æ‹©æœªæ¥æ—¥æœŸ
                    className="text-sm font-medium text-slate-700 px-3 py-2 bg-slate-100 rounded-md border border-slate-200 hover:bg-slate-200 transition-colors cursor-pointer"
                  />
                </div>

                <Button variant="outline" size="sm" onClick={onNextDay}>
                  ä¸‹ä¸€å¤©
                  <ChevronRight className="w-4 h-4 ml-1" />
                </Button>
              </div>
            )}

            <div className="flex gap-2">
              {!isCumulativeMode && (
                <Button variant="default" size="sm" onClick={onViewSummary}>
                  æŸ¥çœ‹æœ€è¿‘30å¤©æ±‡æ€»
                </Button>
              )}
              {!hideGroupButton && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => {
                    if (chatId) {
                      router.push(`/chats?chatId=${encodeURIComponent(chatId)}`)
                    } else {
                      router.push("/chats")
                    }
                  }}
                >
                  ç¾¤ç»„ç®¡ç†
                </Button>
              )}
            </div>
          </div>
        )}
      </div>
    </Card>
  )
}
import * as React from 'react'

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener('change', onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener('change', onChange)
  }, [])

  return !!isMobile
}
'use client'

// Inspired by react-hot-toast library
import * as React from 'react'

import type { ToastActionElement, ToastProps } from '@/components/ui/toast'

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 5000 // ğŸ”¥ ä¼˜åŒ–ï¼š5ç§’åè‡ªåŠ¨å…³é—­ï¼Œè€Œä¸æ˜¯1000ç§’

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType['ADD_TOAST']
      toast: ToasterToast
    }
  | {
      type: ActionType['UPDATE_TOAST']
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType['DISMISS_TOAST']
      toastId?: ToasterToast['id']
    }
  | {
      type: ActionType['REMOVE_TOAST']
      toastId?: ToasterToast['id']
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      }

    case 'DISMISS_TOAST': {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      }
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, 'id'>

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id })

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  }
}

export { useToast, toast }
/**
 * OKX C2C API å®¢æˆ·ç«¯
 * ä»…æ”¯æŒè·å–C2CæŒ‚å•æ•°æ®
 */
/**
 * è·å–OKX C2CæŒ‚å•æ•°æ®
 * @param paymentMethod - æ”¯ä»˜æ–¹å¼ ('all', 'alipay', 'wxPay', 'bank')
 * @returns è¿”å›å¤„ç†è¿‡çš„å–å®¶åˆ—è¡¨ï¼ˆæŒ‰ä»·æ ¼ä»ä½åˆ°é«˜æ’åºï¼‰
 */
export async function getOKXC2CSellers(paymentMethod = 'all') {
    const BASE_URL = 'https://www.okx.com/v3/c2c/tradingOrders/books';
    // æ„å»ºè¯·æ±‚å‚æ•°ï¼ˆæ ¹æ®ç”¨æˆ·æä¾›çš„çœŸå®APIæ ¼å¼ï¼‰
    // æ³¨æ„ï¼šAPIå‚æ•°éœ€è¦ä½¿ç”¨å°å†™çš„ alipayï¼Œä½†è¿”å›æ•°æ®ä¸­æ”¯ä»˜æ–¹å¼æ˜¯ aliPay
    const params = new URLSearchParams({
        quoteCurrency: 'CNY',
        baseCurrency: 'USDT',
        paymentMethod: paymentMethod,
        showTrade: 'false',
        receivingAds: 'false',
        isAbleFilter: 'false',
        showFollow: 'false',
        showAlreadyTraded: 'false',
        side: 'sell',
        userType: 'all',
        t: Date.now().toString(), // ä½¿ç”¨å½“å‰æ—¶é—´æˆ³é˜²æ­¢ç¼“å­˜
    });
    if (process.env.DEBUG_BOT === 'true') {
        console.log('[OKX C2C API] è¯·æ±‚URL:', `${BASE_URL}?${params.toString()}`);
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ç§’è¶…æ—¶
    try {
        const response = await fetch(`${BASE_URL}?${params.toString()}`, {
            method: 'GET',
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Accept': 'application/json',
            },
            signal: controller.signal,
        });
        clearTimeout(timeoutId);
        if (!response.ok) {
            throw new Error(`OKX C2C API HTTP ${response.status}`);
        }
        const data = await response.json();
        // æ•°æ®æ ¡éªŒï¼šcode å¯èƒ½æ˜¯æ•°å­— 0 æˆ–å­—ç¬¦ä¸² '0'
        if (data && (data.code === 0 || data.code === '0') && Array.isArray(data.data?.sell)) {
            // æå–ã€å¤„ç†å’Œæ’åºæ•°æ®
            const sellers = data.data.sell.map((seller) => ({
                nickName: seller.nickName || 'æœªçŸ¥å•†å®¶',
                price: parseFloat(seller.price || '0'),
                paymentMethods: Array.isArray(seller.paymentMethods) ? seller.paymentMethods : [],
                availableAmount: parseFloat(seller.availableAmount || '0'),
                quoteMinAmountPerOrder: parseFloat(seller.quoteMinAmountPerOrder || '0'),
                quoteMaxAmountPerOrder: parseFloat(seller.quoteMaxAmountPerOrder || '0'),
            }));
            // æŒ‰ä»·æ ¼ä»ä½åˆ°é«˜æ’åº
            sellers.sort((a, b) => a.price - b.price);
            return sellers;
        }
        else {
            console.error('[OKX C2C API] è¿”å›æ•°æ®æ ¼å¼ä¸æ­£ç¡®:', {
                code: data?.code,
                msg: data?.msg || data?.error_message || 'æœªçŸ¥é”™è¯¯',
                hasData: !!data?.data,
                hasSell: !!data?.data?.sell,
                sellIsArray: Array.isArray(data?.data?.sell)
            });
            return [];
        }
    }
    catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
            throw new Error('OKX C2C API è¯·æ±‚è¶…æ—¶');
        }
        console.error('[OKX C2C API] è¯·æ±‚å¤±è´¥:', error);
        throw error;
    }
}
// Enhanced Excel export: prefer .xlsx (SheetJS) with multiple sheets; fallback to CSV
async function fetchJSON(url) {
    const res = await fetch(url);
    if (!res.ok)
        throw new Error(`HTTP ${res.status}`);
    return res.json();
}
function ymd(d) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${y}-${m}-${day}`;
}
export async function exportToExcel(date, chatId, billIndex) {
    const day = ymd(date);
    const from = `${day}`;
    const toDate = new Date(date);
    toDate.setDate(toDate.getDate() + 1);
    const to = ymd(toDate);
    // Load real data
    // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šå¦‚æœæä¾›äº†billIndexï¼Œåˆ™ä½¿ç”¨billå‚æ•°
    const summaryUrl = `/api/stats/today?date=${encodeURIComponent(day)}${chatId ? `&chatId=${encodeURIComponent(chatId)}` : ''}${billIndex ? `&bill=${billIndex}` : ''}`;
    const txIncomeUrl = `/api/transactions?type=income&from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}${chatId ? `&chatId=${encodeURIComponent(chatId)}` : ''}&size=1000`;
    const txDispatchUrl = `/api/transactions?type=dispatch&from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}${chatId ? `&chatId=${encodeURIComponent(chatId)}` : ''}&size=1000`;
    let summary = null;
    let incomes = [];
    let dispatches = [];
    try {
        const [s, inc, dis] = await Promise.all([
            fetchJSON(summaryUrl),
            fetchJSON(txIncomeUrl),
            fetchJSON(txDispatchUrl),
        ]);
        summary = s;
        incomes = inc.items || [];
        dispatches = dis.items || [];
    }
    catch (e) {
        // If API fails, continue with empty datasets (will still export CSV)
        console.error('åŠ è½½å¯¼å‡ºæ•°æ®å¤±è´¥ï¼š', e);
    }
    // Try to export .xlsx first
    try {
        const XLSX = await import('xlsx');
        const wb = XLSX.utils.book_new();
        // Summary sheet
        const summaryRows = [
            ['è´¦å•ç»Ÿè®¡'],
            ['æ—¥æœŸ', day],
            ['ç¾¤ç»„', chatId || 'å…¨éƒ¨'],
        ];
        if (summary) {
            summaryRows.push(['æ€»å…¥æ¬¾é‡‘é¢ (RMB)', summary.totalIncome ?? 0], ['æ€»å…¥æ¬¾ (USDT)', summary.totalIncomeUSDT ?? 0], ['æ€»ä¸‹å‘é‡‘é¢ (RMB)', summary.totalDispatch ?? 0], ['æ€»ä¸‹å‘ (USDT)', summary.totalDispatchUSDT ?? 0], ['å¹³å‡æ±‡ç‡', summary.averageRate ?? 0], ['å¹³å‡è´¹ç‡(%)', summary.averageFee ?? 0], ['æœªä¸‹å‘ (RMB)', summary.notDispatched ?? 0], ['æœªä¸‹å‘ (USDT)', summary.notDispatchedUSDT ?? 0]);
        }
        const wsSummary = XLSX.utils.aoa_to_sheet(summaryRows);
        wsSummary['!cols'] = [{ wch: 18 }, { wch: 20 }];
        // Force ç¾¤ç»„ å•å…ƒæ ¼ä¸ºæ–‡æœ¬ï¼ˆB3ï¼‰
        if (chatId) {
            const addr = 'B3';
            if (!wsSummary[addr])
                wsSummary[addr] = { t: 's', v: chatId };
            else
                wsSummary[addr] = { t: 's', v: chatId };
        }
        XLSX.utils.book_append_sheet(wb, wsSummary, 'æ‘˜è¦');
        // Incomes sheet
        const incomeRows = [
            ['æ—¶é—´', 'é‡‘é¢(RMB)', 'USDT', 'æ±‡ç‡', 'å›å¤äºº', 'æ“ä½œäºº'],
            ...incomes.map((r) => [
                new Date(r.createdAt).toLocaleString('zh-CN'),
                r.amount,
                r.usdt ?? '',
                r.rate ?? '',
                r.replier || '',
                r.operator || '',
            ]),
        ];
        const wsIncome = XLSX.utils.aoa_to_sheet(incomeRows);
        wsIncome['!cols'] = [{ wch: 20 }, { wch: 14 }, { wch: 10 }, { wch: 10 }, { wch: 16 }, { wch: 16 }];
        wsIncome['!autofilter'] = { ref: `A1:F${incomeRows.length}` };
        XLSX.utils.book_append_sheet(wb, wsIncome, 'å…¥æ¬¾');
        // Dispatches sheet
        const dispatchRows = [
            ['æ—¶é—´', 'é‡‘é¢(RMB)', 'USDT', 'æ±‡ç‡', 'å›å¤äºº', 'æ“ä½œäºº'],
            ...dispatches.map((r) => [
                new Date(r.createdAt).toLocaleString('zh-CN'),
                r.amount,
                r.usdt ?? '',
                r.rate ?? '',
                r.replier || '',
                r.operator || '',
            ]),
        ];
        const wsDispatch = XLSX.utils.aoa_to_sheet(dispatchRows);
        wsDispatch['!cols'] = [{ wch: 20 }, { wch: 14 }, { wch: 10 }, { wch: 10 }, { wch: 16 }, { wch: 16 }];
        wsDispatch['!autofilter'] = { ref: `A1:F${dispatchRows.length}` };
        XLSX.utils.book_append_sheet(wb, wsDispatch, 'ä¸‹å‘');
        // Category stats (by operator / replier)
        const byOperator = new Map();
        incomes.forEach((r) => {
            const k = r.operator || 'æœªå¡«';
            byOperator.set(k, (byOperator.get(k) || 0) + (r.amount || 0));
        });
        const byReplier = new Map();
        incomes.forEach((r) => {
            const k = r.replier || 'æœªå¡«';
            byReplier.set(k, (byReplier.get(k) || 0) + (r.amount || 0));
        });
        const catRows = [
            ['å…¥æ¬¾æ“ä½œäººåˆ†ç±»', 'é‡‘é¢(RMB)'],
            ...[...byOperator.entries()].map(([k, v]) => [k, v]),
            [],
            ['å…¥æ¬¾å›å¤äººåˆ†ç±»', 'é‡‘é¢(RMB)'],
            ...[...byReplier.entries()].map(([k, v]) => [k, v]),
        ];
        const wsCat = XLSX.utils.aoa_to_sheet(catRows);
        wsCat['!cols'] = [{ wch: 20 }, { wch: 16 }];
        XLSX.utils.book_append_sheet(wb, wsCat, 'åˆ†ç±»');
        const fileName = `è´¦å•_${day}${chatId ? `_${chatId}` : ''}.xlsx`;
        XLSX.writeFile(wb, fileName);
        return;
    }
    catch (e) {
        // Fallback to CSV when xlsx is not available
        console.warn('xlsx ä¸å¯ç”¨ï¼Œå›é€€åˆ° CSV å¯¼å‡º', e);
    }
    // Fallback CSV (single file)
    let csvContent = "\uFEFF";
    csvContent += `è´¦å•ç»Ÿè®¡\n`;
    csvContent += `æ—¥æœŸ,${day}\n`;
    if (chatId) {
        // Keep as text in Excel by using formula-style text wrapper
        csvContent += `ç¾¤ç»„,="${chatId}"\n`;
    }
    else {
        csvContent += `ç¾¤ç»„,å…¨éƒ¨\n`;
    }
    if (summary) {
        csvContent += `æ€»å…¥æ¬¾é‡‘é¢ (RMB),${summary.totalIncome ?? 0}\n`;
        csvContent += `æ€»å…¥æ¬¾ (USDT),${summary.totalIncomeUSDT ?? 0}\n`;
        csvContent += `æ€»ä¸‹å‘é‡‘é¢ (RMB),${summary.totalDispatch ?? 0}\n`;
        csvContent += `æ€»ä¸‹å‘ (USDT),${summary.totalDispatchUSDT ?? 0}\n`;
        csvContent += `å¹³å‡æ±‡ç‡,${summary.averageRate ?? 0}\n`;
        csvContent += `å¹³å‡è´¹ç‡(%) ,${summary.averageFee ?? 0}\n`;
        csvContent += `æœªä¸‹å‘ (RMB),${summary.notDispatched ?? 0}\n`;
        csvContent += `æœªä¸‹å‘ (USDT),${summary.notDispatchedUSDT ?? 0}\n`;
    }
    csvContent += "\nå…¥æ¬¾è®°å½•\n";
    csvContent += "æ—¶é—´,é‡‘é¢(RMB),USDT,æ±‡ç‡,å›å¤äºº,æ“ä½œäºº\n";
    incomes.forEach((r) => {
        csvContent += `${new Date(r.createdAt).toLocaleString('zh-CN')},${r.amount},${r.usdt ?? ''},${r.rate ?? ''},${r.replier || ''},${r.operator || ''}\n`;
    });
    csvContent += "\nä¸‹å‘è®°å½•\n";
    csvContent += "æ—¶é—´,é‡‘é¢(RMB),USDT,æ±‡ç‡,å›å¤äºº,æ“ä½œäºº\n";
    dispatches.forEach((r) => {
        csvContent += `${new Date(r.createdAt).toLocaleString('zh-CN')},${r.amount},${r.usdt ?? ''},${r.rate ?? ''},${r.replier || ''},${r.operator || ''}\n`;
    });
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `è´¦å•_${day}${chatId ? `_${chatId}` : ''}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
import { PrismaClient } from '@prisma/client';
import fs from 'node:fs';
import path from 'node:path';
const DEBUG_DB = process.env.DEBUG_DB === 'true';
// ğŸ”¥ ç¡®ä¿æ•°æ®åº“æ–‡ä»¶åœ¨ Prisma åˆå§‹åŒ–ä¹‹å‰å­˜åœ¨
function ensureDatabase() {
    try {
        const dbUrl = process.env.DATABASE_URL || 'file:./prisma/data/app.db';
        if (dbUrl.startsWith('file:')) {
            let dbPath = dbUrl.slice(5); // ç§»é™¤ 'file:' å‰ç¼€
            // å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œè½¬ä¸ºç»å¯¹è·¯å¾„
            if (!dbPath.startsWith('/')) {
                dbPath = path.resolve(process.cwd(), dbPath);
            }
            const dir = path.dirname(dbPath);
            // ç¡®ä¿ç›®å½•å­˜åœ¨
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
                if (DEBUG_DB)
                    console.log('[lib/db] âœ… åˆ›å»ºæ•°æ®åº“ç›®å½•:', dir);
            }
            // ç¡®ä¿æ•°æ®åº“æ–‡ä»¶å­˜åœ¨
            if (!fs.existsSync(dbPath)) {
                fs.closeSync(fs.openSync(dbPath, 'a'));
                if (DEBUG_DB)
                    console.log('[lib/db] âœ… åˆ›å»ºæ•°æ®åº“æ–‡ä»¶:', dbPath);
            }
            if (DEBUG_DB)
                console.log('[lib/db] âœ… æ•°æ®åº“è·¯å¾„:', dbPath);
        }
    }
    catch (error) {
        console.error('[lib/db] âŒ æ•°æ®åº“åˆå§‹åŒ–é”™è¯¯:', error);
    }
}
// æ‰§è¡Œæ•°æ®åº“åˆå§‹åŒ–
ensureDatabase();
// ğŸ”¥ åˆ›å»º Prisma Client å®ä¾‹
let prismaInstance;
// ğŸ”¥ ç»Ÿä¸€æ—¥å¿—é…ç½®ï¼šåªåœ¨ DEBUG_PRISMA=true æ—¶è¾“å‡ºæŸ¥è¯¢æ—¥å¿—
// è¯´æ˜ï¼šPrisma v6 çš„ LogLevel ç±»å‹ä½ç½®è¾ƒæ·±ï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨ any ç®€åŒ–ç±»å‹
const prismaLogConfig = process.env.DEBUG_PRISMA === 'true'
    ? ['query', 'error', 'warn']
    : ['error']; // ä»…è¾“å‡ºé”™è¯¯æ—¥å¿—
if (process.env.NODE_ENV === 'production') {
    // ç”Ÿäº§ç¯å¢ƒï¼šæ¯æ¬¡éƒ½åˆ›å»ºæ–°å®ä¾‹
    prismaInstance = new PrismaClient({
        log: prismaLogConfig,
    });
    if (DEBUG_DB)
        console.log('[lib/db] âœ… Prisma Client å·²åˆå§‹åŒ– (ç”Ÿäº§ç¯å¢ƒ)');
}
else {
    // å¼€å‘ç¯å¢ƒï¼šä½¿ç”¨å…¨å±€å•ä¾‹
    if (!global.prisma) {
        global.prisma = new PrismaClient({
            log: prismaLogConfig, // ğŸ”¥ é»˜è®¤ä¸è¾“å‡ºæŸ¥è¯¢æ—¥å¿—
        });
        if (DEBUG_DB)
            console.log('[lib/db] âœ… Prisma Client å·²åˆå§‹åŒ– (å¼€å‘ç¯å¢ƒ)');
    }
    prismaInstance = global.prisma;
}
// ğŸ”¥ å¯¼å‡º prisma å®ä¾‹
export const prisma = prismaInstance;
// ğŸ”¥ éªŒè¯å¯¼å‡ºæˆåŠŸ
if (!prisma) {
    console.error('[lib/db] âŒ ä¸¥é‡é”™è¯¯: prisma å®ä¾‹ä¸º undefined!');
    throw new Error('Prisma Client åˆå§‹åŒ–å¤±è´¥');
}
// ğŸ”¥ æ·»åŠ è¿æ¥æµ‹è¯•ï¼ˆä»…åœ¨é¦–æ¬¡å¯¼å…¥æ—¶æ‰§è¡Œï¼‰
if (typeof window === 'undefined') {
    prisma.$connect()
        .then(() => {
        if (DEBUG_DB)
            console.log('[lib/db] âœ… Prisma Client å·²è¿æ¥åˆ°æ•°æ®åº“');
    })
        .catch((error) => {
        console.error('[lib/db] âŒ Prisma Client è¿æ¥å¤±è´¥:', error);
    });
}
import { clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';
export function cn(...inputs) {
    return twMerge(clsx(inputs));
}
/**
 * æ ¼å¼åŒ–æ—¥æœŸä¸º YYYY-MM-DD å­—ç¬¦ä¸²ï¼ˆæœ¬åœ°æ—¶é—´ï¼Œé¿å…æ—¶åŒºé—®é¢˜ï¼‰
 */
export function formatDateString(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
}
// åŠŸèƒ½å¼€å…³çš„é»˜è®¤é…ç½®ï¼ˆç»Ÿä¸€ç®¡ç†ï¼Œé¿å…é‡å¤ï¼‰
// âš ï¸ æ³¨æ„ï¼šè¿™é‡Œåªå®šä¹‰åŠŸèƒ½åç§°ï¼Œåˆ›å»ºæ—¶ä¼šå…¨éƒ¨è®¾ä¸º enabled: true
// ğŸ”¥ ç®€åŒ–æƒé™ç³»ç»Ÿï¼šåªä¿ç•™åŸºç¡€è®°è´¦åŠŸèƒ½å¼€å…³ï¼Œå…¶ä»–åŠŸèƒ½ç›´æ¥å¯ç”¨
export const DEFAULT_FEATURES = [
  'accounting_basic',      // åŸºç¡€è®°è´¦ï¼ˆå”¯ä¸€éœ€è¦æƒé™æ§åˆ¶çš„åŠŸèƒ½ï¼‰
]

/**
 * ä¸ºç¾¤ç»„åˆ›å»ºé»˜è®¤åŠŸèƒ½å¼€å…³ï¼ˆå…¨éƒ¨å¯ç”¨ï¼‰
 * @param {string} chatId - ç¾¤ç»„ID
 * @param {any} prisma - Prisma å®¢æˆ·ç«¯
 * @param {boolean} [force=false] - æ˜¯å¦å¼ºåˆ¶æ›´æ–°ï¼ˆå³ä½¿å·²æœ‰åŠŸèƒ½å¼€å…³ï¼‰
 * @returns {Promise<boolean>} - æ˜¯å¦åˆ›å»º/æ›´æ–°æˆåŠŸ
 */
export async function ensureDefaultFeatures(chatId, prisma, force = false) {
  try {
    const existingFlags = await prisma.chatFeatureFlag.findMany({
      where: { chatId },
      select: { feature: true, enabled: true, id: true }
    })

    if (existingFlags.length === 0 || force) {
      if (force && existingFlags.length > 0) {
        await prisma.chatFeatureFlag.deleteMany({ where: { chatId } })
        console.log('[ensureDefaultFeatures] ğŸ—‘ï¸  åˆ é™¤æ—§åŠŸèƒ½å¼€å…³', { chatId, count: existingFlags.length })
        await new Promise(resolve => setTimeout(resolve, 100))
      }
      const features = DEFAULT_FEATURES.map(feature => ({ chatId, feature, enabled: true }))
      for (const feature of features) {
        await prisma.chatFeatureFlag.upsert({
          where: { chatId_feature: { chatId: feature.chatId, feature: feature.feature } },
          update: { enabled: true },
          create: { chatId: feature.chatId, feature: feature.feature, enabled: true }
        })
      }
      const verifyFlags = await prisma.chatFeatureFlag.findMany({ where: { chatId }, select: { feature: true, enabled: true } })
      const allEnabled = verifyFlags.length === DEFAULT_FEATURES.length && verifyFlags.every((f) => f.enabled === true)
      if (!allEnabled) {
        await prisma.chatFeatureFlag.updateMany({ where: { chatId }, data: { enabled: true } })
        console.log('[ensureDefaultFeatures] âš ï¸  éªŒè¯å¤±è´¥ï¼Œå¼ºåˆ¶å¯ç”¨æ‰€æœ‰åŠŸèƒ½', { chatId })
      }
      console.log('[ensureDefaultFeatures] âœ…', { chatId, count: verifyFlags.length, expected: DEFAULT_FEATURES.length, allEnabled, force })
      return true
    }

    const existingFeatures = new Set(existingFlags.map((f) => f.feature))
    const missingFeatures = DEFAULT_FEATURES.filter((f) => !existingFeatures.has(f))
    if (missingFeatures.length > 0) {
      for (const feature of missingFeatures) {
        await prisma.chatFeatureFlag.upsert({
          where: { chatId_feature: { chatId, feature } },
          update: { enabled: true },
          create: { chatId, feature, enabled: true }
        })
      }
      console.log('[ensureDefaultFeatures] â• è¡¥å……ç¼ºå¤±åŠŸèƒ½', { chatId, added: missingFeatures.length, features: missingFeatures })
      return true
    }

    console.log('[ensureDefaultFeatures] â­ï¸  å·²å­˜åœ¨ä¸”å®Œæ•´', { chatId, count: existingFlags.length })
    return false
  } catch (e) {
    console.error('[ensureDefaultFeatures] âŒ', { chatId, error: e.message })
    return false
  }
}
// æ•°æ®åº“æ“ä½œæ¨¡å—
import { prisma } from '../lib/db.js'
import { getGlobalDailyCutoffHour, startOfDay, endOfDay } from './utils.js'

/**
 * ç¡®ä¿æ•°æ®åº“ä¸­çš„èŠå¤©è®°å½•å­˜åœ¨ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
 */
export async function ensureDbChat(ctx, chat = null) {
  const chatId = String(ctx.chat?.id)
  let title = ctx.chat?.title || null

  if (!title && ctx.chat?.type === 'private') {
    const u = ctx.chat
    title = u.username ? `@${u.username}` : [u.first_name, u.last_name].filter(Boolean).join(' ') || null
  }

  if (!chatId) return null

  // å¹¶è¡Œæ‰§è¡Œ upsert æ“ä½œ
  await Promise.all([
    prisma.chat.upsert({
      where: { id: chatId },
      update: { title },
      create: { id: chatId, title, status: 'PENDING', allowed: false },
    }),
    prisma.setting.upsert({
      where: { chatId },
      update: {},
      create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
    })
  ])

  // å¦‚æœæœ‰ chat å¯¹è±¡ï¼ŒåŒæ­¥è®¾ç½®åˆ°å†…å­˜
  if (chat) {
    await syncSettingsToMemory(ctx, chat, chatId)
  }

  return chatId
}

/**
 * æ£€æŸ¥å¹¶å¤„ç†è·¨æ—¥æƒ…å†µï¼ˆå¦‚æœæ˜¯æ¯æ—¥æ¸…é›¶æ¨¡å¼ï¼Œæ¸…ç©ºå†…å­˜æ•°æ®ï¼‰
 * @param {object} chat - å†…å­˜ä¸­çš„èŠå¤©å¯¹è±¡
 * @param {string} chatId - èŠå¤©ID
 * @returns {Promise<boolean>} - å¦‚æœè·¨æ—¥è¿”å›true
 */
export async function checkAndClearIfNewDay(chat, chatId) {
  try {
    if (!chat || !chatId) return false

    const settings = await prisma.setting.findUnique({
      where: { chatId },
      select: { accountingMode: true, dailyCutoffHour: true }
    })

    const accountingMode = settings?.accountingMode || 'DAILY_RESET'

    // åªæœ‰æ¯æ—¥æ¸…é›¶æ¨¡å¼æ‰éœ€è¦æ¸…ç©ºå†…å­˜æ•°æ®
    if (accountingMode !== 'DAILY_RESET') return false

    // ğŸ”¥ ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ç¾¤ç»„çº§åˆ«çš„æ—¥åˆ‡æ—¶é—´ï¼Œä¸ getOrCreateTodayBill ä¿æŒä¸€è‡´
    const cutoffHour = settings?.dailyCutoffHour != null && settings.dailyCutoffHour >= 0 && settings.dailyCutoffHour <= 23
      ? settings.dailyCutoffHour
      : await getGlobalDailyCutoffHour()

    const now = new Date()

    // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ä¸ getOrCreateTodayBill ç›¸åŒçš„æ—¥åˆ‡é€»è¾‘è®¡ç®—å½“å‰è´¦å•å‘¨æœŸçš„å¼€å§‹æ—¶é—´
    const todayCutoff = new Date()
    todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
    todayCutoff.setHours(cutoffHour, 0, 0, 0)

    let currentBillStart
    if (now >= todayCutoff) {
      // å½“å‰æ—¶é—´ >= ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œä½¿ç”¨ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´
      currentBillStart = new Date(todayCutoff)
    } else {
      // å½“å‰æ—¶é—´ < ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œä½¿ç”¨æ˜¨å¤©çš„æ—¥åˆ‡æ—¶é—´
      currentBillStart = new Date(todayCutoff)
      currentBillStart.setDate(currentBillStart.getDate() - 1)
    }

    // æ£€æŸ¥æœ€ååŒæ­¥çš„æ—¥æœŸï¼ˆå¦‚æœæœ‰ï¼‰
    const lastBillDate = chat._lastBillDate
    if (!lastBillDate) {
      // é¦–æ¬¡ä½¿ç”¨ï¼Œè®°å½•å½“å‰è´¦å•å‘¨æœŸçš„å¼€å§‹æ—¶é—´
      chat._lastBillDate = currentBillStart.getTime()
      return false
    }

    // æ£€æŸ¥æ˜¯å¦è·¨æ—¥ï¼ˆè¿›å…¥æ–°çš„è´¦å•å‘¨æœŸï¼‰
    const lastDate = new Date(lastBillDate)
    const isNewDay = currentBillStart.getTime() > lastDate.getTime()

    if (isNewDay) {
      // è·¨æ—¥äº†ï¼Œæ¸…ç©ºå†…å­˜ä¸­çš„å½“å‰è´¦å•æ•°æ®
      chat.current.incomes = []
      chat.current.dispatches = []
      chat._billLastSync = 0 // æ¸…é™¤åŒæ­¥æ ‡è®°ï¼Œå¼ºåˆ¶é‡æ–°åŒæ­¥
      chat._lastBillDate = currentBillStart.getTime()
      console.log(`[æ—¥åˆ‡æ£€æŸ¥] æ£€æµ‹åˆ°è·¨æ—¥ï¼Œå·²æ¸…ç©ºå†…å­˜æ•°æ®`, { chatId, lastDate: lastDate.toISOString(), currentBillStart: currentBillStart.toISOString() })
      return true
    }

    return false
  } catch (e) {
    console.error('[checkAndClearIfNewDay] æ£€æŸ¥è·¨æ—¥å¤±è´¥', e)
    return false
  }
}

/**
 * è·å–ç¾¤ç»„çš„æ—¥åˆ‡æ—¶é—´ï¼ˆä¼˜å…ˆä½¿ç”¨ç¾¤ç»„çº§åˆ«ï¼Œå¦åˆ™ä½¿ç”¨å…¨å±€é…ç½®ï¼‰
 */
export async function getChatDailyCutoffHour(chatId) {
  try {
    const setting = await prisma.setting.findUnique({
      where: { chatId },
      select: { dailyCutoffHour: true }
    })
    // ğŸ”¥ ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ç¾¤ç»„çº§åˆ«çš„æ—¥åˆ‡æ—¶é—´ï¼Œå¦‚æœä¸ºnullæˆ–undefinedï¼Œåˆ™ä½¿ç”¨å…¨å±€é…ç½®
    if (setting?.dailyCutoffHour != null && setting.dailyCutoffHour >= 0 && setting.dailyCutoffHour <= 23) {
      return setting.dailyCutoffHour
    }
  } catch (e) {
    console.error('[getChatDailyCutoffHour] æŸ¥è¯¢å¤±è´¥', e)
  }
  // å¦‚æœæ²¡æœ‰ç¾¤ç»„çº§åˆ«é…ç½®ï¼Œä½¿ç”¨å…¨å±€é…ç½®
  return await getGlobalDailyCutoffHour()
}

/**
 * è·å–æˆ–åˆ›å»ºå½“å¤©çš„OPENè´¦å•
 * ğŸ”¥ ä¿®å¤æ—¥åˆ‡é€»è¾‘ï¼šæ ¹æ®å½“å‰æ—¶é—´åˆ¤æ–­åº”è¯¥å½’å…¥å“ªä¸ªè´¦å•å‘¨æœŸ
 * ğŸ”¥ ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ç¾¤ç»„çº§åˆ«çš„æ—¥åˆ‡æ—¶é—´ï¼Œç¡®ä¿ä¸å‰ç«¯ä¸€è‡´
 * 
 * æ—¥åˆ‡é€»è¾‘è¯´æ˜ï¼š
 * - å¦‚æœæ—¥åˆ‡æ—¶é—´æ˜¯å‡Œæ™¨2ç‚¹
 * - é‚£ä¹ˆ3å·çš„è´¦å•èŒƒå›´æ˜¯ï¼š2025/11/03 02:00:00 â€” 2025/11/04 02:00:00
 * - å¦‚æœå½“å‰æ—¶é—´æ˜¯3å·ä¸Šåˆ10ç‚¹ï¼ˆ>= 3å·02:00ï¼‰ï¼Œå½’å…¥3å·çš„è´¦å•
 * - å¦‚æœå½“å‰æ—¶é—´æ˜¯3å·å‡Œæ™¨1ç‚¹ï¼ˆ< 3å·02:00ï¼‰ï¼Œå½’å…¥2å·çš„è´¦å•ï¼ˆ2025/11/02 02:00:00 â€” 2025/11/03 02:00:00ï¼‰
 */
export async function getOrCreateTodayBill(chatId) {
  // ğŸ”¥ å…ˆæ£€æŸ¥è®°è´¦æ¨¡å¼
  const settings = await prisma.setting.findUnique({
    where: { chatId },
    select: { accountingMode: true }
  })
  const accountingMode = settings?.accountingMode || 'DAILY_RESET'
  const isCumulativeMode = accountingMode === 'CARRY_OVER'
  const isSingleBillMode = accountingMode === 'SINGLE_BILL_PER_DAY'

  const now = new Date()

  // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šæŸ¥æ‰¾æœ€æ–°çš„ OPEN è´¦å•ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºæ–°è´¦å•ï¼ˆopenedAt ä¸ºå½“å‰æ—¶é—´ï¼‰
  if (isCumulativeMode) {
    let bill = await prisma.bill.findFirst({
      where: { chatId, status: 'OPEN' },
      orderBy: { openedAt: 'desc' }
    })

    if (!bill) {
      // ğŸ”¥ åˆ›å»ºæ–°è´¦å•ï¼ŒopenedAt ä¸ºå½“å‰æ—¶é—´
      bill = await prisma.bill.create({
        data: {
          chatId,
          status: 'OPEN',
          openedAt: now, // ğŸ”¥ ä½¿ç”¨å½“å‰æ—¶é—´ä½œä¸ºå¼€å§‹æ—¶é—´
          savedAt: now
        }
      })
    }

    // ğŸ”¥ ç´¯è®¡æ¨¡å¼ä¸éœ€è¦è¿”å› gte å’Œ ltï¼Œè¿”å›ç©ºå¯¹è±¡
    return { bill, gte: null, lt: null }
  }

  // ğŸ”¥ å…¶ä»–æ¨¡å¼ï¼šæŒ‰æ—¥åˆ‡é€»è¾‘æŸ¥æ‰¾æˆ–åˆ›å»ºè´¦å•ï¼ˆæ¯å¤©åªæœ‰ä¸€ç¬”è´¦å•ï¼‰
  const cutoffHour = await getChatDailyCutoffHour(chatId)

  // ğŸ”¥ è®¡ç®—ä»Šå¤©çš„æ—¥åˆ‡å¼€å§‹æ—¶é—´
  const todayCutoff = new Date()
  todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
  todayCutoff.setHours(cutoffHour, 0, 0, 0)

  // ğŸ”¥ åˆ¤æ–­å½“å‰æ—¶é—´æ˜¯å¦å·²ç»è¿‡äº†ä»Šå¤©çš„æ—¥åˆ‡ç‚¹
  let gte
  let lt

  if (now >= todayCutoff) {
    // å½“å‰æ—¶é—´ >= ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œå½’å…¥ä»Šå¤©çš„è´¦å•ï¼ˆä»Šå¤©02:00 - æ˜å¤©02:00ï¼‰
    gte = new Date(todayCutoff)
    lt = new Date(todayCutoff)
    lt.setDate(lt.getDate() + 1)
  } else {
    // å½“å‰æ—¶é—´ < ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œå½’å…¥æ˜¨å¤©çš„è´¦å•ï¼ˆæ˜¨å¤©02:00 - ä»Šå¤©02:00ï¼‰
    gte = new Date(todayCutoff)
    gte.setDate(gte.getDate() - 1)
    lt = new Date(todayCutoff)
  }

  // ğŸ”¥ å•ç¬”è®¢å•æ¨¡å¼ï¼šå¦‚æœå½“å¤©å·²æœ‰OPENè´¦å•ï¼Œç›´æ¥è¿”å›ï¼›å¦åˆ™åˆ›å»ºæ–°çš„
  // ğŸ”¥ å…¶ä»–æ¨¡å¼ï¼šæŸ¥æ‰¾æˆ–åˆ›å»ºå½“å¤©çš„OPENè´¦å•
  let bill = await prisma.bill.findFirst({
    where: { chatId, status: 'OPEN', openedAt: { gte, lt } },
    orderBy: { openedAt: 'asc' }
  })

  if (!bill) {
    bill = await prisma.bill.create({
      data: {
        chatId,
        status: 'OPEN',
        openedAt: new Date(gte),
        savedAt: new Date()
      }
    })
  }

  return { bill, gte, lt }
}

/**
 * æ›´æ–°è®¾ç½®
 */
export async function updateSettings(chatId, data) {
  return prisma.setting.update({ where: { chatId }, data })
}

/**
 * åŒæ­¥è®¾ç½®å’Œæ“ä½œäººåˆ°å†…å­˜
 * ğŸ”¥ ä¿®å¤ï¼šç¡®ä¿å®æ—¶æ±‡ç‡ä»æ•°æ®åº“åŒæ­¥åˆ°å†…å­˜
 * ğŸ”¥ æ–°å¢ï¼šå¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰æ±‡ç‡ï¼Œè‡ªåŠ¨è·å–å®æ—¶æ±‡ç‡å¹¶ä¿å­˜
 */
export async function syncSettingsToMemory(ctx, chat, chatId) {
  try {
    const [settings, needOperators, currencyCfg] = await Promise.all([
      prisma.setting.findUnique({
        where: { chatId },
        select: {
          feePercent: true,
          fixedRate: true,
          realtimeRate: true,
          headerText: true,
          everyoneAllowed: true,
          accountingEnabled: true // ğŸ”¥ åŒæ­¥è®°è´¦å¼€å…³çŠ¶æ€
        }
      }),
      chat ? (async () => {
        const lastSyncTime = chat._operatorsLastSync || 0
        const now = Date.now()
        return (now - lastSyncTime > 5 * 60 * 1000 || chat.operators.size === 0)
      })() : Promise.resolve(false),
      prisma.globalConfig.findUnique({ where: { key: `currency:${chatId}` } }).catch(() => null)
    ])

    if (settings && chat) {
      // è´§å¸ä»£ç ï¼ˆé»˜è®¤ cnyï¼‰
      const code = (currencyCfg?.value || 'cny').toString().trim().toLowerCase() || 'cny'
      chat.currencyCode = code
      if (typeof settings.feePercent === 'number') chat.feePercent = settings.feePercent
      // ğŸ”¥ ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨æ•°æ®åº“ä¸­çš„æ±‡ç‡ï¼Œç¡®ä¿é‡å¯åèƒ½æ¢å¤
      if (settings.fixedRate != null) {
        chat.fixedRate = settings.fixedRate
        chat.realtimeRate = null // è®¾ç½®å›ºå®šæ±‡ç‡æ—¶æ¸…ç©ºå®æ—¶æ±‡ç‡
      } else if (settings.realtimeRate != null) {
        chat.realtimeRate = settings.realtimeRate
        chat.fixedRate = null // ä½¿ç”¨å®æ—¶æ±‡ç‡æ—¶æ¸…ç©ºå›ºå®šæ±‡ç‡
      } else {
        // ğŸ”¥ æ–°å¢ï¼šå¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰æ±‡ç‡ï¼ˆæ—¢æ²¡æœ‰fixedRateä¹Ÿæ²¡æœ‰realtimeRateï¼‰ï¼Œè‡ªåŠ¨è·å–å®æ—¶æ±‡ç‡å¹¶ä¿å­˜
        try {
          const { fetchUsdtToFiatRate } = await import('./helpers.js')
          const rate = await fetchUsdtToFiatRate(code)
          if (rate) {
            chat.realtimeRate = rate
            chat.fixedRate = null
            // ä¿å­˜åˆ°æ•°æ®åº“
            await prisma.setting.update({
              where: { chatId },
              data: { realtimeRate: rate, fixedRate: null }
            })
            if (process.env.DEBUG_BOT === 'true') {
              console.log(`[syncSettingsToMemory] è‡ªåŠ¨è·å–å¹¶ä¿å­˜å®æ—¶æ±‡ç‡: ${rate} (chatId: ${chatId})`)
            }
          }
        } catch (e) {
          console.error('[syncSettingsToMemory] è‡ªåŠ¨è·å–å®æ—¶æ±‡ç‡å¤±è´¥:', e)
        }
      }
      if (settings.headerText != null) chat.headerText = settings.headerText
      if (typeof settings.everyoneAllowed === 'boolean') chat.everyoneAllowed = settings.everyoneAllowed
    }

    if (chat && needOperators) {
      const operators = await prisma.operator.findMany({ where: { chatId }, select: { username: true } })
      chat.operators.clear()
      for (const op of operators) {
        chat.operators.add(op.username)
      }
      chat._operatorsLastSync = Date.now()
    }
  } catch (e) {
    console.error('åŒæ­¥è®¾ç½®åˆ°å†…å­˜å¤±è´¥', e)
  }
}


/**
 * åˆ é™¤æœ€åä¸€æ¡å…¥æ¬¾è®°å½•
 */
export async function deleteLastIncome(chatId) {
  const { bill } = await getOrCreateTodayBill(chatId)
  if (!bill) return false

  const lastItem = await prisma.billItem.findFirst({
    where: { billId: bill.id, type: 'INCOME' },
    orderBy: { createdAt: 'desc' }
  })

  if (!lastItem) return false

  await prisma.billItem.delete({ where: { id: lastItem.id } })
  return { amount: Number(lastItem.amount), rate: lastItem.rate ? Number(lastItem.rate) : undefined }
}

/**
 * é€šè¿‡ messageId åˆ é™¤æŒ‡å®šçš„å…¥æ¬¾è®°å½•
 */
export async function deleteIncomeByMessageId(chatId, messageId) {
  const { bill } = await getOrCreateTodayBill(chatId)
  if (!bill) return false

  const item = await prisma.billItem.findFirst({
    where: { 
      billId: bill.id, 
      type: 'INCOME',
      messageId: messageId
    }
  })

  if (!item) return false

  await prisma.billItem.delete({ where: { id: item.id } })
  return { amount: Number(item.amount), rate: item.rate ? Number(item.rate) : undefined }
}

/**
 * åˆ é™¤æœ€åä¸€æ¡ä¸‹å‘è®°å½•
 */
export async function deleteLastDispatch(chatId) {
  const { bill } = await getOrCreateTodayBill(chatId)
  if (!bill) return false

  const lastItem = await prisma.billItem.findFirst({
    where: { billId: bill.id, type: 'DISPATCH' },
    orderBy: { createdAt: 'desc' }
  })

  if (!lastItem) return false

  await prisma.billItem.delete({ where: { id: lastItem.id } })
  return { amount: Number(lastItem.amount), usdt: lastItem.usdt ? Number(lastItem.usdt) : 0 }
}

/**
 * é€šè¿‡ messageId åˆ é™¤æŒ‡å®šçš„ä¸‹å‘è®°å½•
 */
export async function deleteDispatchByMessageId(chatId, messageId) {
  const { bill } = await getOrCreateTodayBill(chatId)
  if (!bill) return false

  const item = await prisma.billItem.findFirst({
    where: { 
      billId: bill.id, 
      type: 'DISPATCH',
      messageId: messageId
    }
  })

  if (!item) return false

  await prisma.billItem.delete({ where: { id: item.id } })
  return { amount: Number(item.amount), usdt: item.usdt ? Number(item.usdt) : 0 }
}

/**
 * ğŸ”¥ è‡ªåŠ¨æ—¥åˆ‡æ£€æŸ¥ï¼šæ£€æŸ¥å¹¶å…³é—­æ˜¨å¤©çš„è´¦å•ï¼Œç¡®ä¿æ•°æ®æ­£ç¡®ä¿å­˜
 * è¿™ä¸ªå‡½æ•°ä¼šæ£€æŸ¥æ‰€æœ‰æœ‰OPENè´¦å•çš„ç¾¤ç»„ï¼Œå¦‚æœæ£€æµ‹åˆ°è·¨æ—¥ï¼Œåˆ™å…³é—­æ˜¨å¤©çš„è´¦å•
 * @param {function} getChat - è·å–èŠå¤©å¯¹è±¡çš„å‡½æ•° (botId, chatId) => chat
 * @returns {Promise<number>} - å¤„ç†çš„ç¾¤ç»„æ•°é‡
 */
export async function performAutoDailyCutoff(getChat) {
  try {
    const now = new Date()

    // æŸ¥æ‰¾æ‰€æœ‰è¿˜æœ‰OPENè´¦å•çš„ç¾¤ç»„ï¼ˆä½¿ç”¨groupByè·å–å”¯ä¸€çš„chatIdï¼‰
    const openBillsGrouped = await prisma.bill.groupBy({
      by: ['chatId'],
      where: {
        status: 'OPEN'
      },
      _count: {
        id: true
      }
    })

    // è½¬æ¢ä¸ºç®€å•æ•°ç»„æ ¼å¼
    const openBills = openBillsGrouped.map(g => ({ chatId: g.chatId }))

    if (openBills.length === 0) {
      return 0
    }

    // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡æŸ¥è¯¢æ‰€æœ‰ç¾¤ç»„çš„è®¾ç½®ï¼Œé¿å…N+1æŸ¥è¯¢é—®é¢˜
    const chatIds = openBills.map(b => b.chatId)
    const allSettings = await prisma.setting.findMany({
      where: { chatId: { in: chatIds } },
      select: { chatId: true, accountingMode: true, dailyCutoffHour: true }
    })
    const settingsMap = new Map(allSettings.map(s => [s.chatId, s]))

    let processedCount = 0

    for (const bill of openBills) {
      try {
        const chatId = bill.chatId

        // ğŸ”¥ ä»ç¼“å­˜ä¸­è·å–è®¾ç½®ï¼Œé¿å…é‡å¤æŸ¥è¯¢
        const settings = settingsMap.get(chatId)
        const accountingMode = settings?.accountingMode || 'DAILY_RESET'

        // ğŸ”¥ æ‰€æœ‰æ¨¡å¼ï¼šä¸å†è‡ªåŠ¨å…³é—­è´¦å•ï¼Œå¿…é¡»æ‰‹åŠ¨å…³é—­
        // åªæœ‰ SINGLE_BILL_PER_DAY æ¨¡å¼åœ¨æ—¥åˆ‡æ—¶è‡ªåŠ¨å…³é—­ï¼ˆè¿™æ˜¯è¯¥æ¨¡å¼çš„ç‰¹æ€§ï¼‰
        if (accountingMode === 'SINGLE_BILL_PER_DAY') {
          // ğŸ”¥ ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ç¾¤ç»„çº§åˆ«çš„æ—¥åˆ‡æ—¶é—´
          const cutoffHour = settings?.dailyCutoffHour != null && settings.dailyCutoffHour >= 0 && settings.dailyCutoffHour <= 23
            ? settings.dailyCutoffHour
            : await getGlobalDailyCutoffHour()

          // ğŸ”¥ ä¿®å¤ï¼šè®¡ç®—ä»Šå¤©æ—¥åˆ‡çš„å¼€å§‹æ—¶é—´ï¼ˆä¸ä½¿ç”¨startOfDayï¼Œå› ä¸ºå®ƒä¼šæ ¹æ®å½“å‰æ—¶é—´åˆ¤æ–­ï¼‰
          // æˆ‘ä»¬éœ€è¦çš„æ˜¯"ä»Šå¤©çš„æ—¥åˆ‡å¼€å§‹æ—¶é—´"ï¼Œæ— è®ºå½“å‰æ—¶é—´æ˜¯ä»€ä¹ˆ
          const todayCutoff = new Date()
          todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
          todayCutoff.setHours(cutoffHour, 0, 0, 0)
          const todayStart = new Date(todayCutoff)

          // æŸ¥æ‰¾æ‰€æœ‰æ˜¨å¤©çš„OPENè´¦å•å¹¶å…³é—­å®ƒä»¬ï¼ˆopenedAt < ä»Šå¤©02:00çš„è´¦å•ï¼‰
          const billsToClose = await prisma.bill.findMany({
            where: {
              chatId,
              status: 'OPEN',
              openedAt: { lt: todayStart }
            }
          })

          // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šæ‰¹é‡æ›´æ–°è´¦å•çŠ¶æ€ï¼Œè€Œä¸æ˜¯é€ä¸ªæ›´æ–°
          // ğŸ”¥ æ³¨æ„ï¼šè‡ªåŠ¨å…³é—­æ—¶ä¸è®¾ç½® closedAtï¼Œåªæœ‰æ‰‹åŠ¨å…³é—­æ—¶æ‰è®¾ç½® closedAt
          if (billsToClose.length > 0) {
            const billIds = billsToClose.map(b => b.id)
            await prisma.bill.updateMany({
              where: { id: { in: billIds } },
              data: {
                status: 'CLOSED',
                savedAt: new Date()
                // ğŸ”¥ ä¸è®¾ç½® closedAtï¼Œå› ä¸ºè¿™æ˜¯è‡ªåŠ¨å…³é—­ï¼Œä¸æ˜¯æ‰‹åŠ¨å…³é—­
              }
            })
          }

          // å¦‚æœæœ‰å†…å­˜ä¸­çš„èŠå¤©å¯¹è±¡ï¼Œæ¸…ç©ºå…¶å†…å­˜æ•°æ®
          // æ³¨æ„ï¼šè¿™é‡Œæ— æ³•ç›´æ¥è®¿é—®stateï¼Œéœ€è¦é€šè¿‡å›è°ƒå‡½æ•°
          if (getChat && typeof getChat === 'function') {
            try {
              // getChat å‡½æ•°çš„ç­¾åæ˜¯ (botId, chatId) => chat
              // è¿™é‡Œéœ€è¦ä¼ å…¥botIdï¼Œä½†æˆ‘ä»¬åœ¨å®šæ—¶ä»»åŠ¡ä¸­æ— æ³•ç›´æ¥è·å–ï¼Œæ‰€ä»¥å…ˆå°è¯•ç”¨ BOT_TOKEN
              const botId = process.env.BOT_TOKEN
              if (botId) {
                const chat = getChat(botId, chatId)
                if (chat) {
                  // ğŸ”¥ æ¸…ç©ºå†…å­˜ä¸­çš„å½“å‰è´¦å•æ•°æ®
                  chat.current.incomes = []
                  chat.current.dispatches = []
                  chat._billLastSync = 0
                  // ğŸ”¥ æ›´æ–°æœ€åè´¦å•æ—¥æœŸä¸ºä»Šå¤©æ—¥åˆ‡çš„å¼€å§‹æ—¶é—´
                  chat._lastBillDate = todayStart.getTime()
                  console.log(`[è‡ªåŠ¨æ—¥åˆ‡] å·²æ¸…ç©ºç¾¤ç»„ ${chatId} çš„å†…å­˜æ•°æ®`, { todayStart: todayStart.toISOString() })
                }
              }
            } catch (e) {
              // å¦‚æœè·å–å¤±è´¥ï¼Œå¿½ç•¥ï¼ˆå¯èƒ½æ˜¯ç¾¤ç»„ä¸åœ¨å†…å­˜ä¸­ï¼‰
            }
          }

          processedCount++
          console.log(`[è‡ªåŠ¨æ—¥åˆ‡] å·²å…³é—­ç¾¤ç»„ ${chatId} çš„æ˜¨æ—¥è´¦å•ï¼Œå…± ${billsToClose.length} ä¸ªè´¦å•`)
        } else {
          // ğŸ”¥ ç´¯è®¡æ¨¡å¼å’Œæ¯æ—¥æ¸…é›¶æ¨¡å¼ï¼šä¸è‡ªåŠ¨å…³é—­ï¼Œå¿…é¡»æ‰‹åŠ¨å…³é—­
          // è·³è¿‡ï¼Œä¸å¤„ç†
          continue
        }
      } catch (e) {
        console.error(`[è‡ªåŠ¨æ—¥åˆ‡] å¤„ç†ç¾¤ç»„ ${bill.chatId} å¤±è´¥:`, e)
      }
    }

    if (processedCount > 0) {
      console.log(`[è‡ªåŠ¨æ—¥åˆ‡] å®Œæˆï¼Œå…±å¤„ç† ${processedCount} ä¸ªç¾¤ç»„çš„æ—¥åˆ‡`)
    }

    return processedCount
  } catch (e) {
    console.error('[è‡ªåŠ¨æ—¥åˆ‡] æ‰§è¡Œå¤±è´¥:', e)
    return 0
  }
}


/**
 * è¯»å–/å†™å…¥ç¾¤ç»„è´§å¸ä»£ç ï¼ˆä½¿ç”¨ GlobalConfigï¼‰
 */
export async function getChatCurrencyCode(chatId) {
  try {
    const row = await prisma.globalConfig.findUnique({ where: { key: `currency:${chatId}` }, select: { value: true } })
    const code = (row?.value || 'cny').toString().trim().toLowerCase() || 'cny'
    return code
  } catch {
    return 'cny'
  }
}

export async function setChatCurrencyCode(chatId, code) {
  const val = (code || 'cny').toString().trim().toLowerCase() || 'cny'
  await prisma.globalConfig.upsert({
    where: { key: `currency:${chatId}` },
    create: { key: `currency:${chatId}`, value: val, description: `Currency code for chat ${chatId}`, updatedBy: 'system' },
    update: { value: val, description: `Currency code for chat ${chatId}`, updatedBy: 'system', updatedAt: new Date() },
  })
}
import winston from 'winston'
import 'winston-daily-rotate-file'
import path from 'path'
import fs from 'fs'
const LOG_TO_FILE = process.env.LOG_TO_FILE === 'true'
const LOG_STDOUT = process.env.LOG_STDOUT !== 'false'
const LOG_DIR = process.env.LOG_DIR || 'logs'
const DEFAULT_LEVEL = process.env.LOG_LEVEL || (process.env.DEBUG_BOT === 'true' ? 'debug' : 'warn')

let loggerInstance = null

const initLogger = ({ dir = LOG_DIR, level = DEFAULT_LEVEL, stdout = LOG_STDOUT } = {}) => {
    if (loggerInstance) return loggerInstance

    // Ensure log directory exists
    if (LOG_TO_FILE) {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true })
        }
    }

    const transports = []

    // Console transport
    if (stdout) {
        transports.push(
            new winston.transports.Console({
                format: winston.format.combine(
                    winston.format.colorize(),
                    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
                    winston.format.printf(({ timestamp, level, message, ...meta }) => {
                        const metaStr = Object.keys(meta).length ? JSON.stringify(meta) : ''
                        return `[${timestamp}] ${level}: ${message} ${metaStr}`
                    })
                ),
            })
        )
    }

    // File transport with rotation
    if (LOG_TO_FILE) {
        transports.push(
            new winston.transports.DailyRotateFile({
                filename: path.join(dir, 'application-%DATE%.log'),
                datePattern: 'YYYY-MM-DD',
                zippedArchive: true,
                maxSize: '20m',
                maxFiles: '14d',
                level: level,
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                ),
            })
        )
    }

    // Error file transport
    if (LOG_TO_FILE) {
        transports.push(
            new winston.transports.DailyRotateFile({
                filename: path.join(dir, 'error-%DATE%.log'),
                datePattern: 'YYYY-MM-DD',
                zippedArchive: true,
                maxSize: '20m',
                maxFiles: '30d',
                level: 'error',
                format: winston.format.combine(
                    winston.format.timestamp(),
                    winston.format.json()
                ),
            })
        )
    }

    loggerInstance = winston.createLogger({
        level: level,
        transports: transports,
    })

    return loggerInstance
}

const hijackConsole = () => {
    if (!loggerInstance) return
    if (process.env.HIJACK_CONSOLE !== 'true') return

    const originalLog = console.log
    const originalError = console.error
    const originalWarn = console.warn
    const originalDebug = console.debug

    console.log = (...args) => {
        loggerInstance.info(args.map(arg => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join(' '))
    }

    console.error = (...args) => {
        loggerInstance.error(args.map(arg => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join(' '))
    }

    console.warn = (...args) => {
        loggerInstance.warn(args.map(arg => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join(' '))
    }

    console.debug = (...args) => {
        loggerInstance.debug(args.map(arg => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join(' '))
    }
}

// Proxy methods to the underlying winston instance
const proxyLogger = {
    initLogger,
    hijackConsole,
    info: (...args) => loggerInstance?.info(...args),
    warn: (...args) => loggerInstance?.warn(...args),
    error: (...args) => loggerInstance?.error(...args),
    debug: (...args) => loggerInstance?.debug(...args),
    log: (...args) => loggerInstance?.info(...args),
}

export default proxyLogger
// æ ¼å¼åŒ–å‡½æ•°æ¨¡å—
import { prisma } from '../lib/db.js'
import { summarize } from './state.js'
import { formatMoney, getGlobalDailyCutoffHour, startOfDay, endOfDay } from './utils.js'
import { checkAndClearIfNewDay, getOrCreateTodayBill } from './database.js'

/**
 * æ ¼å¼åŒ–è´¦å•æ‘˜è¦
 */
export async function formatSummary(ctx, chat, options = {}) {
  const chatId = String(ctx?.chat?.id || '')

  // ğŸ”¥ é¦–å…ˆæ£€æŸ¥æ˜¯å¦è·¨æ—¥ï¼Œå¦‚æœæ˜¯æ¯æ—¥æ¸…é›¶æ¨¡å¼åˆ™æ¸…ç©ºå†…å­˜æ•°æ®
  await checkAndClearIfNewDay(chat, chatId)

  let accountingMode = 'DAILY_RESET'
  let settings = null // ğŸ”¥ åˆå§‹åŒ– settings å˜é‡

  const lastSyncTime = chat._billLastSync || 0
  const now = Date.now()
  const needsSync = !chat._billLastSync ||
    (chat.current.incomes.length === 0 && chat.current.dispatches.length === 0) ||
    (now - lastSyncTime > 30 * 60 * 1000)

  try {
    const [settingsResult, billData] = await Promise.all([
      prisma.setting.findUnique({
        where: { chatId },
        select: {
          accountingMode: true,
          feePercent: true,
          fixedRate: true,
          realtimeRate: true
        }
      }),
      needsSync ? (async () => {
        try {
          // ğŸ”¥ ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ç¾¤ç»„çº§åˆ«çš„æ—¥åˆ‡æ—¶é—´ï¼Œä¸ getOrCreateTodayBill ä¿æŒä¸€è‡´
          const setting = await prisma.setting.findUnique({
            where: { chatId },
            select: { dailyCutoffHour: true }
          })
          const cutoffHour = setting?.dailyCutoffHour != null && setting.dailyCutoffHour >= 0 && setting.dailyCutoffHour <= 23
            ? setting.dailyCutoffHour
            : await getGlobalDailyCutoffHour()

          // ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ä¸ getOrCreateTodayBill ç›¸åŒçš„æ—¥åˆ‡é€»è¾‘
          const now = new Date()

          // è®¡ç®—ä»Šå¤©çš„æ—¥åˆ‡å¼€å§‹æ—¶é—´
          const todayCutoff = new Date()
          todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
          todayCutoff.setHours(cutoffHour, 0, 0, 0)

          // åˆ¤æ–­å½“å‰æ—¶é—´æ˜¯å¦å·²ç»è¿‡äº†ä»Šå¤©çš„æ—¥åˆ‡ç‚¹
          let gte
          let lt

          if (now >= todayCutoff) {
            // å½“å‰æ—¶é—´ >= ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼ŒæŸ¥è¯¢ä»Šå¤©çš„è´¦å•
            gte = new Date(todayCutoff)
            lt = new Date(todayCutoff)
            lt.setDate(lt.getDate() + 1)
          } else {
            // å½“å‰æ—¶é—´ < ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼ŒæŸ¥è¯¢æ˜¨å¤©çš„è´¦å•
            gte = new Date(todayCutoff)
            gte.setDate(gte.getDate() - 1)
            lt = new Date(todayCutoff)
          }

          return await prisma.bill.findFirst({
            where: { chatId, status: 'OPEN', openedAt: { gte, lt } },
            include: {
              items: {
                select: {
                  type: true,
                  amount: true,
                  rate: true,
                  usdt: true,
                  replier: true,
                  operator: true,
                  remark: true, // ğŸ”¥ æ·»åŠ å¤‡æ³¨å­—æ®µ
                  displayName: true, // ğŸ”¥ æ·»åŠ ç”¨æˆ·æ˜µç§°å­—æ®µ
                  userId: true, // ğŸ”¥ æ·»åŠ ç”¨æˆ·IDå­—æ®µ
                  messageId: true, // ğŸ”¥ æ·»åŠ æ¶ˆæ¯IDå­—æ®µ
                  createdAt: true
                }
              }
            },
            orderBy: { openedAt: 'asc' }
          })
        } catch (e) {
          return null
        }
      })() : Promise.resolve(null)
    ])

    settings = settingsResult // ğŸ”¥ èµ‹å€¼ç»™å¤–éƒ¨å˜é‡
    accountingMode = settings?.accountingMode || 'DAILY_RESET'

    // ğŸ”¥ ç´¯è®¡æ¨¡å¼ä¸å†éœ€è¦å†å²æœªä¸‹å‘è®¡ç®—

    if (needsSync && billData?.items) {
      // ğŸ”¥ ä»æ•°æ®åº“åŒæ­¥æ—¶ï¼Œå°è¯•ä» chat.userIdByUsername è·å–ç”¨æˆ·ä¿¡æ¯
      const dbIncomes = billData.items.filter(i => i.type === 'INCOME').map(i => {
        const replier = i.replier || ''
        const operator = i.operator || ''
        const who = operator || replier || ''
        
        // ğŸ”¥ ä¼˜å…ˆä½¿ç”¨æ•°æ®åº“ä¸­çš„ displayName å’Œ userId
        let userId = i.userId ? Number(i.userId) : null
        let displayName = i.displayName || null
        
        // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰ displayNameï¼Œå°è¯•ä» chat.userIdByUsername è·å–
        if (!displayName) {
          displayName = who.replace(/^@/, '') || 'ç”¨æˆ·'
          if (who) {
            const whoWithAt = who.startsWith('@') ? who : `@${who}`
            if (!userId) {
              userId = chat.userIdByUsername.get(whoWithAt) || chat.userIdByUsername.get(who)
            }
            // å¦‚æœæ²¡æœ‰ userIdï¼Œå°è¯•ä» who ä¸­æå–ï¼ˆå¦‚æœæ˜¯ @user_123456 æ ¼å¼ï¼‰
            if (!userId && who.startsWith('@user_')) {
              const extractedId = who.replace('@user_', '')
              if (/^\d+$/.test(extractedId)) {
                userId = Number(extractedId)
              }
            }
          }
        }
        
        return {
        amount: Number(i.amount),
        rate: i.rate ? Number(i.rate) : undefined,
        createdAt: new Date(i.createdAt),
          replier: replier,
          operator: operator,
          displayName: displayName,
          userId: userId,
          messageId: i.messageId || null, // ğŸ”¥ ä¿å­˜æ¶ˆæ¯ID
        }
      })

      const dbDispatches = billData.items.filter(i => i.type === 'DISPATCH').map(i => {
        const replier = i.replier || ''
        const operator = i.operator || ''
        const who = operator || replier || ''
        
        // ğŸ”¥ ä¼˜å…ˆä½¿ç”¨æ•°æ®åº“ä¸­çš„ displayName å’Œ userId
        let userId = i.userId ? Number(i.userId) : null
        let displayName = i.displayName || null
        
        // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰ displayNameï¼Œå°è¯•ä» chat.userIdByUsername è·å–
        if (!displayName) {
          displayName = who.replace(/^@/, '') || 'ç”¨æˆ·'
          if (who) {
            const whoWithAt = who.startsWith('@') ? who : `@${who}`
            if (!userId) {
              userId = chat.userIdByUsername.get(whoWithAt) || chat.userIdByUsername.get(who)
            }
            // å¦‚æœæ²¡æœ‰ userIdï¼Œå°è¯•ä» who ä¸­æå–ï¼ˆå¦‚æœæ˜¯ @user_123456 æ ¼å¼ï¼‰
            if (!userId && who.startsWith('@user_')) {
              const extractedId = who.replace('@user_', '')
              if (/^\d+$/.test(extractedId)) {
                userId = Number(extractedId)
              }
            }
          }
        }
        
        return {
        amount: Number(i.amount),
        usdt: Number(i.usdt),
        createdAt: new Date(i.createdAt),
          replier: replier,
          operator: operator,
          displayName: displayName,
          userId: userId,
        }
      })

      // ğŸ”¥ ä¿®å¤ï¼šå§‹ç»ˆä½¿ç”¨æ•°æ®åº“æ•°æ®ä½œä¸ºæƒå¨æ¥æºï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
      // ğŸ”¥ ä¼˜åŒ–ï¼šå³ä½¿è®°å½•æ•°è¶…è¿‡å†…å­˜é™åˆ¶ï¼ˆ100æ¡ï¼‰ï¼Œä¹Ÿå®Œæ•´åŒæ­¥åˆ°å†…å­˜ï¼ˆç”¨äºè®¡ç®—ï¼‰
      // ä½†æ˜¾ç¤ºæ—¶ä¼šæ ¹æ®displayModeé™åˆ¶æ˜¾ç¤ºæ•°é‡
        chat.current.incomes = dbIncomes
        chat.current.dispatches = dbDispatches
      chat._billLastSync = now
      // ğŸ”¥ è®°å½•å½“å‰è´¦å•çš„æ—¥æœŸï¼Œç”¨äºè·¨æ—¥æ£€æµ‹ï¼ˆä¸ getOrCreateTodayBill ä¿æŒä¸€è‡´ï¼‰
      // ğŸ”¥ ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ç¾¤ç»„çº§åˆ«çš„æ—¥åˆ‡æ—¶é—´
      const setting = await prisma.setting.findUnique({
        where: { chatId },
        select: { dailyCutoffHour: true }
      }).catch(() => null)
      const cutoffHour = setting?.dailyCutoffHour != null && setting.dailyCutoffHour >= 0 && setting.dailyCutoffHour <= 23
        ? setting.dailyCutoffHour
        : await getGlobalDailyCutoffHour()

      const nowDate = new Date()
      const todayCutoff = new Date()
      todayCutoff.setFullYear(nowDate.getFullYear(), nowDate.getMonth(), nowDate.getDate())
      todayCutoff.setHours(cutoffHour, 0, 0, 0)
      // åˆ¤æ–­å½“å‰æ—¶é—´åº”è¯¥å½’å…¥å“ªä¸ªè´¦å•å‘¨æœŸ
      const currentBillStart = nowDate >= todayCutoff ? new Date(todayCutoff) : (() => {
        const yesterday = new Date(todayCutoff)
        yesterday.setDate(yesterday.getDate() - 1)
        return yesterday
      })()
      chat._lastBillDate = currentBillStart.getTime()
    } else if (needsSync) {
      chat._billLastSync = now
    }
  } catch (e) {
    console.error('è·å–è®¾ç½®æˆ–åŒæ­¥æ•°æ®å¤±è´¥', e)
  }

  const currentFixedRate = settings?.fixedRate ?? chat.fixedRate ?? null
  const currentRealtimeRate = settings?.realtimeRate ?? chat.realtimeRate ?? null
  const isFixedRate = currentFixedRate != null
  const rateLabel = isFixedRate ? 'å›ºå®šæ±‡ç‡' : 'å®æ—¶æ±‡ç‡'

  // ğŸ”¥ ä¿®å¤ï¼šä»æ•°æ®åº“è¯»å–æ‰€æœ‰è®°å½•è¿›è¡Œè®¡ç®—ï¼Œç¡®ä¿å‡ åƒå‡ ä¸‡æ¡è®°å½•æ—¶ä¹Ÿèƒ½æ­£ç¡®è®¡ç®—
  // å†…å­˜ä¸­å¯èƒ½åªä¿ç•™éƒ¨åˆ†è®°å½•ï¼ˆMAX_INCOMES=100ï¼‰ï¼Œä½†è®¡ç®—æ—¶å¿…é¡»ä½¿ç”¨æ‰€æœ‰è®°å½•
  let allIncomes = chat.current.incomes
  let allDispatches = chat.current.dispatches
  let incCount = chat.current.incomes.length
  let disCount = chat.current.dispatches.length

  try {
    // å¦‚æœå†…å­˜ä¸­çš„è®°å½•æ•°è¾¾åˆ°é™åˆ¶ï¼ˆ100æ¡ï¼‰ï¼Œè¯´æ˜æ•°æ®åº“ä¸­å¯èƒ½æœ‰æ›´å¤šè®°å½•
    // éœ€è¦ä»æ•°æ®åº“é‡æ–°è¯»å–æ‰€æœ‰è®°å½•è¿›è¡Œè®¡ç®—
    if (incCount >= 100 || disCount >= 100 || needsSync) {
      const { bill } = await getOrCreateTodayBill(chatId)
      if (bill) {
        const allItems = await prisma.billItem.findMany({
          where: { billId: bill.id },
          select: {
            type: true,
            amount: true,
            rate: true,
            usdt: true,
            feeRate: true,
            replier: true,
            operator: true,
            displayName: true,
            userId: true,
            messageId: true,
            createdAt: true,
          },
          orderBy: { createdAt: 'asc' }
        })

        allIncomes = allItems
          .filter(i => i.type === 'INCOME')
          .map(i => ({
            amount: Number(i.amount || 0),
            rate: i.rate != null ? Number(i.rate) : undefined,
            feeRate: i.feeRate != null ? Number(i.feeRate) : undefined,
            createdAt: new Date(i.createdAt),
            replier: i.replier || '',
            operator: i.operator || '',
            displayName: i.displayName || null,
            userId: i.userId ? Number(i.userId) : null,
            messageId: i.messageId || null,
          }))

        allDispatches = allItems
          .filter(i => i.type === 'DISPATCH')
          .map(i => ({
            amount: Number(i.amount || 0),
            usdt: Number(i.usdt || 0),
            createdAt: new Date(i.createdAt),
            replier: i.replier || '',
            operator: i.operator || '',
            displayName: i.displayName || null,
            userId: i.userId ? Number(i.userId) : null,
            messageId: i.messageId || null,
          }))

        incCount = allIncomes.length
        disCount = allDispatches.length
      }
    }
  } catch (e) {
    console.error('[formatSummary] ä»æ•°æ®åº“è¯»å–æ‰€æœ‰è®°å½•å¤±è´¥ï¼Œä½¿ç”¨å†…å­˜æ•°æ®', e)
  }

  // ğŸ”¥ ä½¿ç”¨æ‰€æœ‰è®°å½•åˆ›å»ºä¸´æ—¶chatå¯¹è±¡è¿›è¡Œè®¡ç®—
  const tempChat = {
    ...chat,
    current: {
      incomes: allIncomes,
      dispatches: allDispatches,
    }
  }
  const s = summarize(tempChat)
  const rateVal = s.effectiveRate || 0

  let showIncomes = allIncomes
  let showDispatches = allDispatches
  if (chat.displayMode === 1) {
    showIncomes = showIncomes.slice(-3)
    showDispatches = showDispatches.slice(-3)
  } else if (chat.displayMode === 2) {
    showIncomes = showIncomes.slice(-5)
    showDispatches = showDispatches.slice(-5)
  } else if (chat.displayMode === 3) {
    showIncomes = []
    showDispatches = []
  } else if (chat.displayMode === 4) {
    showIncomes = showIncomes.slice(-10)
    showDispatches = showDispatches.slice(-10)
  } else if (chat.displayMode === 5) {
    showIncomes = showIncomes.slice(-20)
    showDispatches = showDispatches.slice(-20)
  }

  const incPart = incCount > 0 && showIncomes.length > 0
    ? showIncomes.map((i) => {
      const t = i.createdAt.toTimeString().slice(0, 8)
      const rate = i.rate ?? rateVal
      const usdt = rate ? Number((Math.abs(i.amount) / rate).toFixed(1)) : 0
      const amount = Math.abs(i.amount)
      const who = i.displayName || i.replier || i.operator || ''
      const remark = i.remark // ğŸ”¥ è·å–å¤‡æ³¨

      // é‡‘é¢å¯ç‚¹å‡»è·³è½¬åˆ°åŸå§‹æ¶ˆæ¯ï¼ˆä»…å¯¹è¶…çº§ç¾¤ç”Ÿæ•ˆï¼šchatId å½¢å¦‚ -100xxxxï¼‰
      let amountText = formatMoney(amount)
      try {
        const chatIdNum = String(chatId || '')
        if (i.messageId && chatIdNum.startsWith('-100')) {
          const internalId = chatIdNum.slice(4) // å»æ‰ -100 å‰ç¼€
          const msgUrl = `https://t.me/c/${internalId}/${i.messageId}`
          amountText = `[${amountText}](${msgUrl})`
        }
      } catch {}

      let line = `${t} ${amountText}`
      if (rate) {
        line += ` / ${rate}=${usdt}U`
      }
      // ğŸ”¥ æ˜¾ç¤ºè´¹ç‡ï¼ˆå¦‚æœæœ‰ï¼‰
      if (i.feeRate) {
        line += ` *${(i.feeRate * 100).toFixed(0)}%`
      }
      // ğŸ”¥ æ˜¾ç¤ºå¤‡æ³¨ï¼ˆå¦‚æœæœ‰ï¼‰
      if (remark) {
        line += ` [${remark}]`
      }

      // åŒä¸€è¡Œæ˜¾ç¤ºç”¨æˆ·åç§°ï¼ˆå»æ‰ @ï¼‰ï¼Œåç§°å¯ç‚¹å‡»æ‰“å¼€ç”¨æˆ·è¯¦æƒ…
      if (who) {
        const displayName = String(who || '').replace(/^@/, '') || 'ç”¨æˆ·'
        const userId = i.userId
        let userLine = displayName
        if (userId) {
          userLine = `[${displayName}](tg://user?id=${userId})`
        }
        line += ` ${userLine}`
      }

      return line
    }).join('\n')
    : (incCount > 0 && chat.displayMode === 3 ? 'ï¼ˆè¯¦æƒ…çœç•¥ï¼Œæ˜¾ç¤ºæ¨¡å¼3ï¼‰' : ' æš‚æ— å…¥æ¬¾')

  const disPart = disCount > 0 && showDispatches.length > 0
    ? showDispatches.map((d) => {
      const t = d.createdAt.toTimeString().slice(0, 8)
      const amount = Math.abs(d.amount)
      const usdt = Math.abs(d.usdt)
      const who = d.displayName || d.replier || d.operator || ''
      
      let line = `${t} ${formatMoney(amount)} (${formatMoney(usdt)}U)`
      
      // åŒä¸€è¡Œæ˜¾ç¤ºç”¨æˆ·åç§°ï¼ˆå»æ‰ @ï¼‰ï¼Œåç§°å¯ç‚¹å‡»æ‰“å¼€ç”¨æˆ·è¯¦æƒ…
      if (who) {
        const displayName = String(who || '').replace(/^@/, '') || 'ç”¨æˆ·'
        const userId = d.userId
        let userLine = displayName
        if (userId) {
          userLine = `[${displayName}](tg://user?id=${userId})`
        }
        line += ` ${userLine}`
      }
      
      return line
    }).join('\n')
    : (disCount > 0 && chat.displayMode === 3 ? 'ï¼ˆè¯¦æƒ…çœç•¥ï¼Œæ˜¾ç¤ºæ¨¡å¼3ï¼‰' : ' æš‚æ— ä¸‹å‘')

  const header = chat.headerText ? `${chat.headerText}\n` : ''
  const modeTag = accountingMode === 'CARRY_OVER' ? 'ã€ç´¯è®¡æ¨¡å¼ã€‘' : ''


  return [
    header + `${modeTag}${options.title || 'è´¦å•çŠ¶æ€'}`,
    `å·²å…¥æ¬¾ï¼ˆ${incCount}ç¬”ï¼‰ï¼š`,
    incPart,
    `\nå·²ä¸‹å‘ï¼ˆ${disCount}ç¬”ï¼‰ï¼š`,
    disPart,
    `\næ€»å…¥æ¬¾é‡‘é¢ï¼š${formatMoney(s.totalIncome)}${(s.totalIncomeUSDT && s.totalIncomeUSDT !== 0) ? ` | ${formatMoney(s.totalIncomeUSDT)}U` : ''}`, // ğŸ”¥ æ˜¾ç¤ºæ€»å…¥æ¬¾çš„Uï¼ˆé€ç¬”æ±‡ç‡èšåˆï¼‰
    `è´¹ç‡ï¼š${s.feePercent}%`,
    `${rateLabel}ï¼š${rateVal || 'æœªè®¾ç½®'}`,
    ...(chat.rmbMode
      ? [
        `åº”ä¸‹å‘ï¼š${formatMoney(s.shouldDispatch)}`,
        `å·²ä¸‹å‘ï¼š${formatMoney(s.dispatched)}`,
        `æœªä¸‹å‘ï¼š${formatMoney(s.notDispatched)}`,
      ]
      : [
        `åº”ä¸‹å‘ï¼š${formatMoney(s.shouldDispatch)} | ${formatMoney(s.shouldDispatchUSDT)}U`,
        `å·²ä¸‹å‘ï¼š${formatMoney(s.dispatched)} | ${formatMoney(s.dispatchedUSDT)}U`,
        `æœªä¸‹å‘ï¼š${formatMoney(s.notDispatched)} | ${formatMoney(s.notDispatchedUSDT)}U`,
      ]
    ),
  ].join('\n')
}

import { prisma } from '../lib/db.js'
import { getChat } from './state.js'

let CURRENT_BOT_ID = null
let BOT_ID_INITIALIZING = false

/**
 * Resolve current Bot record by token to support multi-bot state separation
 * ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨æ›´å¯é çš„ç¼“å­˜ï¼Œé¿å…é‡å¤æŸ¥è¯¢
 */
export async function ensureCurrentBotId(bot) {
    // ğŸ”¥ å¦‚æœå·²æœ‰ç¼“å­˜ï¼Œç›´æ¥è¿”å›
    if (CURRENT_BOT_ID) return CURRENT_BOT_ID

    // ğŸ”¥ å¦‚æœæ­£åœ¨åˆå§‹åŒ–ï¼Œç­‰å¾…å®Œæˆ
    if (BOT_ID_INITIALIZING) {
        let waitCount = 0
        while (BOT_ID_INITIALIZING && waitCount < 50) {
            await new Promise(resolve => setTimeout(resolve, 100))
            waitCount++
            if (CURRENT_BOT_ID) return CURRENT_BOT_ID
        }
    }

    // ğŸ”¥ å¼€å§‹åˆå§‹åŒ–
    BOT_ID_INITIALIZING = true
    try {
        // Try find bot by token; if missing, create a minimal record
        let row = await prisma.bot.findFirst({
            where: { token: process.env.BOT_TOKEN },
            select: { id: true } // ğŸ”¥ åªé€‰æ‹©éœ€è¦çš„å­—æ®µ
        }).catch(() => null)

        if (!row) {
            // try to get bot username for friendly name
            let name = 'EnvBot'
            try {
                // ğŸ”¥ æ·»åŠ 30ç§’è¶…æ—¶å¤„ç†
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('TIMEOUT')), 30000)
                })

                const me = await Promise.race([
                    bot.telegram.getMe(),
                    timeoutPromise
                ])

                name = me?.username ? `@${me.username}` : (me?.first_name || 'EnvBot')
            } catch (e) {
                // ğŸ”¥ å¦‚æœè¶…æ—¶ï¼Œè®°å½•é”™è¯¯ä½†ä¸é˜»æ­¢å¯åŠ¨
                if (e.message === 'TIMEOUT') {
                    console.error('âš ï¸ é“¾æ¥Telegram APIè¶…æ—¶ï¼ˆ30ç§’ï¼‰ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨ç½‘ç»œè¿æ¥')
                } else {
                    console.error('[ensureCurrentBotId] è·å–æœºå™¨äººä¿¡æ¯å¤±è´¥:', e.message)
                }
            }
            row = await prisma.bot.create({
                data: { name, token: process.env.BOT_TOKEN, enabled: true },
                select: { id: true } // ğŸ”¥ åªé€‰æ‹©éœ€è¦çš„å­—æ®µ
            })
        }
        CURRENT_BOT_ID = row.id
        return CURRENT_BOT_ID
    } finally {
        BOT_ID_INITIALIZING = false
    }
}

/**
 * ğŸ”¥ ç®€åŒ–ï¼šä½¿ç”¨æ¨¡å—ä¸­çš„å‡½æ•°
 */
export function ensureChat(ctx) {
    const chatId = ctx.chat?.id
    if (chatId == null) return null
    if (!CURRENT_BOT_ID) return null
    return getChat(CURRENT_BOT_ID, chatId)
}
import { prisma } from '../lib/db.js'
import { ensureChat, ensureCurrentBotId } from './bot-identity.js'
import { ensureDbChat } from './database.js'
import logger from './logger.js'

// ç®€æ˜“å‘Šè­¦èŠ‚æµï¼šæ¯ä¸ªç¾¤ 60s å†…åªæé†’ä¸€æ¬¡
const LAST_WARN_AT = new Map() // chatId -> ts
function shouldWarnNow(chatId) {
    const now = Date.now()
    const prev = LAST_WARN_AT.get(chatId) || 0
    if (now - prev < 60_000) return false
    LAST_WARN_AT.set(chatId, now)
    return true
}

export function registerCoreMiddleware(bot) {
    bot.use(async (ctx, next) => {
        // ğŸ”¥ å¦‚æœæ˜¯å›è°ƒæŸ¥è¯¢ï¼ˆcallback_queryï¼‰ï¼Œç›´æ¥æ”¾è¡Œï¼Œè®© action å¤„ç†
        if (ctx.update.callback_query) {
            return next()
        }

        if (!ctx.chat) return next()
        // å¿½ç•¥é¢‘é“ç±»æ›´æ–°ï¼Œæœºå™¨äººåªæœåŠ¡ç¾¤/è¶…ç¾¤
        if (ctx.chat.type === 'channel') {
            return
        }
        const text = ctx.message?.text || ''

        // è®°å½•è¯´è¯è€…çš„ userId æ˜ å°„ï¼Œè‹¥å…¶ @username åœ¨æ“ä½œå‘˜åˆ—è¡¨ä¸­ï¼Œåˆ™æ”¶é›†å…¶ userId
        const chatState = ensureChat(ctx)
        try {
            if (chatState && ctx.from?.id) {
                const uname = ctx.from?.username ? `@${ctx.from.username}` : null
                if (uname) {
                    if (chatState.userIdByUsername.size > 5000) {
                        const it = chatState.userIdByUsername.keys()
                        const first = it.next().value
                        if (first) chatState.userIdByUsername.delete(first)
                    }
                    chatState.userIdByUsername.set(uname, ctx.from.id)
                }
                if (uname && chatState.operators.has(uname)) chatState.operatorIds.add(ctx.from.id)
            }
        } catch { }

        // ğŸ”¥ ç§èŠï¼šå…è®¸ä½¿ç”¨éƒ¨åˆ†å‘½ä»¤ï¼Œä½†å¤§éƒ¨åˆ†åŠŸèƒ½éœ€è¦é€šè¿‡å†…è”èœå•
        if (ctx.chat.type === 'private') {
            // å…è®¸çš„å‘½ä»¤ï¼š/start, /myid, /æˆ‘, /help, ä½¿ç”¨è¯´æ˜
            const allowedInPrivate = /^(?:\/start|\/myid|\/æˆ‘|\/help|ä½¿ç”¨è¯´æ˜)$/i.test(text)
            if (!allowedInPrivate && !text.includes('æˆ‘çš„è´¦å•')) {
                // å¯¹äºå…¶ä»–å‘½ä»¤ï¼Œä¸å›å¤ï¼ˆé¿å…é¢‘ç¹æç¤ºï¼‰ï¼Œè®©ç”¨æˆ·ä½¿ç”¨å†…è”èœå•
                return
            }
            // å¯¹äºå…è®¸çš„å‘½ä»¤ï¼Œç»§ç»­å¤„ç†ï¼ˆä¸åœ¨è¿™é‡Œ returnï¼‰
        }

        const botId = await ensureCurrentBotId(bot)
        const chatId = await ensureDbChat(ctx, chatState)
        const dbChat = await prisma.chat.findUnique({ where: { id: chatId }, select: { botId: true, allowed: true, bot: { select: { id: true, token: true } } } })

        const currentToken = (process.env.BOT_TOKEN || '').trim()
        const boundToken = (dbChat?.bot?.token || '').trim()

        // ğŸ”¥ è°ƒè¯•æ—¥å¿—
        logger.debug('[bind-check]', {
            chatId,
            botId,
            dbBotId: dbChat?.botId || null,
            allowed: !!dbChat?.allowed,
            currentToken4: currentToken ? `${currentToken.slice(0, 4)}...` : '',
            boundToken4: boundToken ? `${boundToken.slice(0, 4)}...` : '',
        })

        const notBound = !dbChat?.botId || dbChat?.botId !== botId

        // ä»…å¯¹æ–‡æœ¬æ¶ˆæ¯ç»™å‡ºæé†’ï¼Œä¸”åŠ é¢‘ç‡é™åˆ¶ï¼Œé¿å… 429
        if (notBound) {
            if (!text) return // éæ–‡æœ¬ï¼ˆå¦‚è½¬å‘/å›¾ç‰‡ç­‰ï¼‰ä¸æé†’
            if (!shouldWarnNow(chatId)) return
            const msg = 'æœ¬ç¾¤å°šæœªåœ¨åå°ç»‘å®šå½“å‰æœºå™¨äººï¼Œè¯·è”ç³»ç®¡ç†å‘˜åˆ°åå°ç»‘å®šåå†ä½¿ç”¨ã€‚'
            try { await ctx.reply(msg) } catch { }
            return
        }
        if (!dbChat?.allowed) {
            if (!text) return
            if (!shouldWarnNow(chatId)) return
            const msg = 'æœ¬ç¾¤å°šæœªè¢«åå°å…è®¸ä½¿ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜åœ¨åå°å°†æœ¬ç¾¤è®¾ç½®ä¸ºå…è®¸åå†ä½¿ç”¨ã€‚'
            try { await ctx.reply(msg) } catch { }
            return
        }
        return next()
    })
}
// Minimal Telegraf bot with Chinese commands and local proxy support
import 'dotenv/config'
// é»˜è®¤ä½¿ç”¨ä¸­å›½æ—¶åŒºï¼ˆå¦‚æœªç”±ç¯å¢ƒå˜é‡æŒ‡å®šï¼‰
if (!process.env.TZ) {
  process.env.TZ = 'Asia/Shanghai'
}
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import dotenv from 'dotenv'


import { Telegraf, Markup } from 'telegraf'
import { HttpsProxyAgent } from 'https-proxy-agent'
import { getChat, safeCalculate, cleanupInactiveChats } from './state.js'
import { prisma } from '../lib/db.js'
import { ensureDefaultFeatures } from './constants.js'
import { 
  getGlobalDailyCutoffHour, 
  formatMoney, 
  formatDuration
} from './utils.js'
// æ–°æ¨¡å—å¯¼å…¥
import { ensureDbChat, updateSettings, syncSettingsToMemory, getOrCreateTodayBill, checkAndClearIfNewDay, performAutoDailyCutoff, deleteLastIncome, deleteLastDispatch, deleteIncomeByMessageId, deleteDispatchByMessageId } from './database.js'
import { createPermissionMiddleware, isAccountingCommand, clearFeatureCache } from './middleware.js'
import { buildInlineKb, fetchRealtimeRateUSDTtoCNY, getUsername, isAdmin, hasPermissionWithWhitelist } from './helpers.js'
import { formatSummary } from './formatting.js'
import { registerAllHandlers } from './handlers/index.js'
import logger from './logger.js'

logger.initLogger({ dir: 'logs', level: process.env.DEBUG_BOT === 'true' ? 'debug' : 'info', stdout: true })
logger.hijackConsole()

// ğŸ”¥ å®‰å…¨å¢å¼ºï¼šç”Ÿäº§ç¯å¢ƒéšè—æ•æ„Ÿä¿¡æ¯
if (process.env.NODE_ENV === 'production') {
  // ç”Ÿäº§ç¯å¢ƒï¼šç¦ç”¨è¯¦ç»†æ—¥å¿—è¾“å‡ºï¼Œé˜²æ­¢Tokenæ³„éœ²
  console.log = () => {}
  console.debug = () => {}
  console.info = () => {} // åªä¿ç•™errorå’Œwarn
}

// ğŸ”¥ åŠ è½½ç¯å¢ƒå˜é‡ï¼ˆå¦‚æœæœªè®¾ç½®ï¼‰
if (!process.env.BOT_TOKEN) {
  // fallback: try load config/env next to repo root
  const __filename = fileURLToPath(import.meta.url)
  const __dirname = path.dirname(__filename)
  const configEnvPath = path.resolve(__dirname, '../config/env')
  if (fs.existsSync(configEnvPath)) {
    dotenv.config({ path: configEnvPath })
  }
}

if (!process.env.BOT_TOKEN) {
  console.error('BOT_TOKEN æœªè®¾ç½®ï¼Œè¯·åœ¨æ ¹ç›®å½• .env æˆ– config/env ä¸­æä¾› BOT_TOKEN')
  process.exit(1)
}

// ğŸ”¥ éªŒè¯ token æ ¼å¼
const BOT_TOKEN = process.env.BOT_TOKEN.trim()
if (!BOT_TOKEN) {
  console.error('âŒ BOT_TOKEN ä¸ºç©ºï¼Œè¯·æ£€æŸ¥ç¯å¢ƒå˜é‡é…ç½®')
  process.exit(1)
}

// Telegram bot token æ ¼å¼ï¼šæ•°å­—:å­—æ¯æ•°å­—ç»„åˆï¼ˆä¾‹å¦‚ï¼š123456789:ABCdefGHIjklMNOpqrsTUVwxyzï¼‰
const tokenPattern = /^\d+:[A-Za-z0-9_-]+$/
if (!tokenPattern.test(BOT_TOKEN)) {
  console.error('âŒ BOT_TOKEN æ ¼å¼æ— æ•ˆï¼')
  console.error('   æ­£ç¡®æ ¼å¼ï¼šæ•°å­—:å­—æ¯æ•°å­—ç»„åˆï¼ˆä¾‹å¦‚ï¼š123456789:ABCdefGHIjklMNOpqrsTUVwxyzï¼‰')
  console.error('   å½“å‰ token é•¿åº¦ï¼š', BOT_TOKEN.length)
  console.error('   å½“å‰ token å‰ç¼€ï¼š', BOT_TOKEN.substring(0, 20) + '...')
  process.exit(1)
}

const BACKEND_URL = process.env.BACKEND_URL
// Only use proxy when PROXY_URL is explicitly provided
const PROXY_URL = process.env.PROXY_URL || ''
const agent = PROXY_URL ? new HttpsProxyAgent(PROXY_URL) : undefined

const bot = new Telegraf(BOT_TOKEN, {
  telegram: agent ? { agent } : undefined,
})

// ğŸ”¥ åœ°å€éªŒè¯åŠŸèƒ½ï¼šæ¯ä¸ªç¾¤åªç¡®è®¤ä¸€ä¸ªåœ°å€

// å…œåº•ï¼šæ”¶åˆ°ä»»ä½•æ¶ˆæ¯æ—¶ï¼Œç¡®ä¿ chat è®°å½•å·² upsert å¹¶ç»‘å®šåˆ°å½“å‰æœºå™¨äºº
bot.on('message', async (ctx, next) => {
  try {
    const chat = ctx.chat
    if (!chat) return await next()
    if (chat.type === 'channel') return
    const chatId = String(chat.id)
    const title = chat.title || ''
    const from = ctx.from?.username ? `@${ctx.from.username}` : ctx.from?.id
    const text = ctx.message?.text || ctx.message?.caption || '[éæ–‡æœ¬æ¶ˆæ¯]'
    // ğŸ”¥ è°ƒè¯•æ—¥å¿—ï¼šä»…åœ¨ DEBUG_BOT=true æ—¶è¾“å‡º
    if (process.env.DEBUG_BOT === 'true') {
      console.log('[message][recv]', { chatId, title, from, text })
    }
    
    
    // ğŸ”¥ æ£€æŸ¥ç¾¤ç»„æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨æˆ–æœªç»‘å®šï¼Œå°è¯•è¡¥å……ç™½åå•æ£€æµ‹
    const existingChat = await prisma.chat.findUnique({ 
      where: { id: chatId },
      select: { id: true, allowed: true, botId: true }
    })
    
    const botId = await ensureCurrentBotId()
    
    // å¦‚æœç¾¤ç»„ä¸å­˜åœ¨ï¼Œæˆ–è€…æœªæˆæƒä¸”æœªç»‘å®šæœºå™¨äººï¼Œå°è¯•æ£€æµ‹ç™½åå•
    if (!existingChat || (!existingChat.allowed && !existingChat.botId)) {
      // ğŸ”¥ å¤‡ç”¨ç™½åå•æ£€æµ‹ï¼šä»æ¶ˆæ¯å‘é€è€…æ£€æŸ¥
      // è·å–ç¾¤æˆå‘˜åˆ—è¡¨ï¼Œæ‰¾å‡ºå¯èƒ½çš„é‚€è¯·äºº
      try {
        const userId = String(ctx.from?.id || '')
        const username = ctx.from?.username ? `@${ctx.from.username}` : null
        
        // æ£€æŸ¥å½“å‰æ¶ˆæ¯å‘é€è€…æ˜¯å¦åœ¨ç™½åå•ä¸­
        if (userId) {
          const whitelistedUser = await prisma.whitelistedUser.findUnique({
            where: { userId }
          })
          
          if (whitelistedUser) {
            // æ‰¾åˆ°ç™½åå•ç”¨æˆ·ï¼Œè‡ªåŠ¨æˆæƒè¯¥ç¾¤ç»„
            console.log('[message][whitelist-detected]', { chatId, userId, username })
            
            // ğŸ”¥ å¦‚æœç”¨æˆ·åä¸åŒï¼Œæ›´æ–°ç™½åå•è®°å½•ä¸­çš„ç”¨æˆ·å
            if (username && username !== whitelistedUser.username) {
              await prisma.whitelistedUser.update({
                where: { userId },
                data: { username }
              }).catch((e) => {
                if (process.env.DEBUG_BOT === 'true') {
                  console.error('[message][username-update-error]', e)
                }
              })
              if (process.env.DEBUG_BOT === 'true') {
                console.log('[message][username-updated]', { userId, oldUsername: whitelistedUser.username, newUsername: username })
              }
            }
            
            // âš ï¸ ä¸åœ¨è¿™é‡Œåˆ›å»ºé‚€è¯·è®°å½•ï¼Œé¿å…ä¸ my_chat_member äº‹ä»¶é‡å¤
            // é‚€è¯·è®°å½•åªåœ¨ my_chat_member äº‹ä»¶ä¸­åˆ›å»º
            
            // è‡ªåŠ¨æˆæƒï¼šå…ˆç¡®ä¿ Chat å­˜åœ¨ï¼Œå†åˆ›å»º Settingï¼Œé¿å…å¤–é”®é”™è¯¯
            // ğŸ”¥ ä¿®å¤ï¼šå…ˆåˆ›å»º Chatï¼Œç¡®ä¿æˆåŠŸåå†åˆ›å»º Setting
            const chatResult = await prisma.chat.upsert({
                where: { id: chatId },
                create: { 
                  id: chatId, 
                  title, 
                  botId,
                  status: 'APPROVED', 
                  allowed: true 
                },
                update: { 
                  title,
                  botId,
                  status: 'APPROVED',
                  allowed: true
                },
            }).catch((e) => {
              console.error('[message][chat-upsert-error]', e)
              return null
            })
            
            // åªæœ‰ Chat åˆ›å»ºæˆåŠŸåæ‰åˆ›å»º Setting
            if (chatResult) {
              await prisma.setting.upsert({
                where: { chatId },
                create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
                update: {},
              }).catch((e) => {
                console.error('[message][setting-upsert-error]', e)
              })
            }
            // ä»…å¯¹ç¾¤èŠåˆ›å»ºé»˜è®¤åŠŸèƒ½å¼€å…³ï¼ˆchatId ä»¥ '-' å¼€å¤´ï¼‰ï¼Œé¿å…ç§èŠå¤–é”®å†²çª
            if (String(chatId).startsWith('-')) {
              await ensureDefaultFeatures(chatId, prisma)
            }
            
            console.log('[message][auto-authorized]', { chatId, userId })
          } else {
          // éç™½åå•ç”¨æˆ·ï¼šå…ˆåˆ›å»º Chatï¼Œå†åˆ›å»º Setting
          const chatResult = await prisma.chat.upsert({
                where: { id: chatId },
                create: { id: chatId, title, botId, status: 'PENDING', allowed: false },
                update: { title, botId },
          }).catch((e) => {
            console.error('[message][chat-upsert-error]', e)
            return null
          })
          
          if (chatResult) {
            await prisma.setting.upsert({
                where: { chatId },
                create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
                update: {},
            }).catch((e) => {
              console.error('[message][setting-upsert-error]', e)
              })
          }
          }
        } else {
          // å…ˆåˆ›å»º Chatï¼Œå†åˆ›å»º Setting
          const chatResult = await prisma.chat.upsert({
              where: { id: chatId },
              create: { id: chatId, title, status: 'PENDING', allowed: false },
              update: { title },
          }).catch((e) => {
            console.error('[message][chat-upsert-error]', e)
            return null
          })
          
          if (chatResult) {
            await prisma.setting.upsert({
              where: { chatId },
              create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
              update: {},
            }).catch((e) => {
              console.error('[message][setting-upsert-error]', e)
            })
          }
        }
      } catch (e) {
        console.error('[message][whitelist-check-error]', e)
        // å…ˆåˆ›å»º Chatï¼Œå†åˆ›å»º Setting
        const chatResult = await prisma.chat.upsert({
            where: { id: chatId },
            create: { id: chatId, title, status: 'PENDING', allowed: false },
            update: { title },
        }).catch((e2) => {
          console.error('[message][chat-upsert-error]', e2)
          return null
        })
        
        if (chatResult) {
          await prisma.setting.upsert({
            where: { chatId },
            create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
            update: {},
          }).catch((e2) => {
            console.error('[message][setting-upsert-error]', e2)
          })
        }
      }
    } else {
      // ç¾¤ç»„å·²å­˜åœ¨ï¼Œä»…æ›´æ–°æ ‡é¢˜
      await prisma.chat.update({
        where: { id: chatId },
        data: { title }
      }).catch((e) => {
        if (process.env.DEBUG_BOT === 'true') {
          console.error('[message][title-update-error]', { chatId, error: e.message })
        }
      })
    }
    
    // ğŸ”¥ è°ƒè¯•æ—¥å¿—ï¼šä»…åœ¨ DEBUG_BOT=true æ—¶è¾“å‡º
    if (process.env.DEBUG_BOT === 'true') {
      console.log('[message][upsert-ok]', { chatId })
    }
  } catch {}
  finally {
    try { await next() } catch {}
  }
})

// Resolve current Bot record by token to support multi-bot state separation
// ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨æ›´å¯é çš„ç¼“å­˜ï¼Œé¿å…é‡å¤æŸ¥è¯¢
let CURRENT_BOT_ID = null
let BOT_ID_INITIALIZING = false // é˜²æ­¢å¹¶å‘åˆå§‹åŒ–
async function ensureCurrentBotId() {
  // ğŸ”¥ å¦‚æœå·²æœ‰ç¼“å­˜ï¼Œç›´æ¥è¿”å›
  if (CURRENT_BOT_ID) return CURRENT_BOT_ID
  
  // ğŸ”¥ å¦‚æœæ­£åœ¨åˆå§‹åŒ–ï¼Œç­‰å¾…å®Œæˆ
  if (BOT_ID_INITIALIZING) {
    let waitCount = 0
    while (BOT_ID_INITIALIZING && waitCount < 50) {
      await new Promise(resolve => setTimeout(resolve, 100))
      waitCount++
      if (CURRENT_BOT_ID) return CURRENT_BOT_ID
    }
  }
  
  // ğŸ”¥ å¼€å§‹åˆå§‹åŒ–
  BOT_ID_INITIALIZING = true
  try {
    // Try find bot by token; if missing, create a minimal record
    let row = await prisma.bot.findFirst({ 
      where: { token: BOT_TOKEN },
      select: { id: true } // ğŸ”¥ åªé€‰æ‹©éœ€è¦çš„å­—æ®µ
    }).catch(() => null)
    
    if (!row) {
      // try to get bot username for friendly name
      let name = 'EnvBot'
      try {
        // ğŸ”¥ æ·»åŠ 30ç§’è¶…æ—¶å¤„ç†
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('TIMEOUT')), 30000)
        })
        
        const me = await Promise.race([
          bot.telegram.getMe(),
          timeoutPromise
        ])
        
        name = me?.username ? `@${me.username}` : (me?.first_name || 'EnvBot')
      } catch (e) {
        // ğŸ”¥ ç‰¹åˆ«å¤„ç† 401 Unauthorized é”™è¯¯
        if (e.response?.error_code === 401 || e.message?.includes('401') || e.message?.includes('Unauthorized')) {
          console.error('âŒ Telegram Bot Token æ— æ•ˆæˆ–å·²è¿‡æœŸï¼')
          console.error('   é”™è¯¯ä¿¡æ¯ï¼š401 Unauthorized')
          console.error('   å¯èƒ½åŸå› ï¼š')
          console.error('   1. Bot token å·²è¿‡æœŸæˆ–è¢«æ’¤é”€')
          console.error('   2. Bot token æ ¼å¼é”™è¯¯ï¼ˆå¯èƒ½æœ‰å¤šä½™ç©ºæ ¼æˆ–æ¢è¡Œç¬¦ï¼‰')
          console.error('   3. Bot å·²è¢«ç¦ç”¨æˆ–åˆ é™¤')
          console.error('   è¯·æ£€æŸ¥ï¼š')
          console.error('   - æ•°æ®åº“ä¸­çš„ token æ˜¯å¦æ­£ç¡®')
          console.error('   - ç¯å¢ƒå˜é‡ BOT_TOKEN æ˜¯å¦æ­£ç¡®è®¾ç½®')
          console.error('   - æ˜¯å¦åœ¨ @BotFather å¤„é‡æ–°ç”Ÿæˆäº† token')
          console.error('   å½“å‰ token å‰ç¼€ï¼š', BOT_TOKEN.substring(0, 20) + '...')
          throw new Error('Bot token æ— æ•ˆï¼Œæ— æ³•å¯åŠ¨æœºå™¨äºº')
        }
        // ğŸ”¥ å¦‚æœè¶…æ—¶ï¼Œè®°å½•é”™è¯¯ä½†ä¸é˜»æ­¢å¯åŠ¨
        if (e.message === 'TIMEOUT') {
          console.error('âš ï¸ é“¾æ¥Telegram APIè¶…æ—¶ï¼ˆ30ç§’ï¼‰ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨ç½‘ç»œè¿æ¥')
        } else {
          console.error('[ensureCurrentBotId] è·å–æœºå™¨äººä¿¡æ¯å¤±è´¥:', e.message)
        }
      }
      row = await prisma.bot.create({ 
        data: { name, token: BOT_TOKEN, enabled: true },
        select: { id: true } // ğŸ”¥ åªé€‰æ‹©éœ€è¦çš„å­—æ®µ
      })
    }
    CURRENT_BOT_ID = row.id
    return CURRENT_BOT_ID
  } finally {
    BOT_ID_INITIALIZING = false
  }
}

// ğŸ”¥ ç®€åŒ–ï¼šä½¿ç”¨æ¨¡å—ä¸­çš„å‡½æ•°
function ensureChat(ctx) {
  const chatId = ctx.chat?.id
  if (chatId == null) return null
  if (!CURRENT_BOT_ID) return null
  return getChat(CURRENT_BOT_ID, chatId)
}

// ğŸ”¥ å·²åˆ é™¤æœªä½¿ç”¨çš„ ensureDbChatWithSync å‡½æ•°ï¼Œä¼˜åŒ–æ€§èƒ½

// ğŸ”¥ æ‰€æœ‰é‡å¤å‡½æ•°å·²ç§»è‡³å¯¹åº”æ¨¡å—ï¼š
// - getOrCreateTodayBill, deleteLastIncome, deleteLastDispatch -> database.js
// - startOfDay, endOfDay, formatMoney, formatDuration -> utils.js
// - isAdmin, hasOperatorPermission -> helpers.js
// - isFeatureEnabled, ensureFeature -> middleware.js
// - isPublicUrl -> utils.js
// - fetchCoinGeckoRateUSDTtoCNY, fetchExchangeRateHostUSDToCNY, fetchRealtimeRateUSDTtoCNY -> helpers.js
// - buildInlineKb -> helpers.js
// - formatSummary -> formatting.js

// Helpers to extract @username from text
function extractMention(text) {
  const m = text?.match(/@([A-Za-z0-9_]{5,})/) // Telegram username rules (len>=5)
  return m ? `@${m[1]}` : null
}

// ğŸ”¥ æ ¸å¿ƒå‘½ä»¤ï¼ˆbot.startï¼‰å·²ç§»è‡³ handlers/core.jsï¼Œåªä¿ç•™ /start å‘½ä»¤

// /help åˆ«åï¼ˆä¸"ä½¿ç”¨è¯´æ˜"ä¸€è‡´ï¼‰
// å®¡æ‰¹ä¸­é—´ä»¶ï¼šç¾¤ç»„éœ€åå°å®¡æ‰¹é€šè¿‡ï¼ˆChat.status === 'APPROVED'ï¼‰åæ‰å…è®¸æ™®é€šæŒ‡ä»¤
// ç®€æ˜“å‘Šè­¦èŠ‚æµï¼šæ¯ä¸ªç¾¤ 60s å†…åªæé†’ä¸€æ¬¡
const LAST_WARN_AT = new Map() // chatId -> ts
function shouldWarnNow(chatId) {
  const now = Date.now()
  const prev = LAST_WARN_AT.get(chatId) || 0
  if (now - prev < 60_000) return false
  LAST_WARN_AT.set(chatId, now)
  return true
}

bot.use(async (ctx, next) => {
  // ğŸ”¥ å¦‚æœæ˜¯å›è°ƒæŸ¥è¯¢ï¼ˆcallback_queryï¼‰ï¼Œç›´æ¥æ”¾è¡Œï¼Œè®© action å¤„ç†
  if (ctx.update.callback_query) {
    return next()
  }
  
  if (!ctx.chat) return next()
  // å¿½ç•¥é¢‘é“ç±»æ›´æ–°ï¼Œæœºå™¨äººåªæœåŠ¡ç¾¤/è¶…ç¾¤
  if (ctx.chat.type === 'channel') {
    return
  }
  const text = ctx.message?.text || ''
  // è®°å½•è¯´è¯è€…çš„ userId æ˜ å°„ï¼Œè‹¥å…¶ @username åœ¨æ“ä½œå‘˜åˆ—è¡¨ä¸­ï¼Œåˆ™æ”¶é›†å…¶ userId
  const chatState = ensureChat(ctx)
  try {
    if (chatState && ctx.from?.id) {
      const uname = ctx.from?.username ? `@${ctx.from.username}` : null
      if (uname) {
        if (chatState.userIdByUsername.size > 5000) {
          const it = chatState.userIdByUsername.keys()
          const first = it.next().value
          if (first) chatState.userIdByUsername.delete(first)
        }
        chatState.userIdByUsername.set(uname, ctx.from.id)
      }
      if (uname && chatState.operators.has(uname)) chatState.operatorIds.add(ctx.from.id)
    }
  } catch {}
  // ğŸ”¥ ç§èŠï¼šå…è®¸ä½¿ç”¨éƒ¨åˆ†å‘½ä»¤ï¼Œä½†å¤§éƒ¨åˆ†åŠŸèƒ½éœ€è¦é€šè¿‡å†…è”èœå•
  if (ctx.chat.type === 'private') {
    // å…è®¸çš„å‘½ä»¤ï¼š/start, /myid, /æˆ‘, /help, ä½¿ç”¨è¯´æ˜
    const allowedInPrivate = /^(?:\/start|\/myid|\/æˆ‘|\/help|ä½¿ç”¨è¯´æ˜)$/i.test(text)
    if (!allowedInPrivate && !text.includes('æˆ‘çš„è´¦å•')) {
      // å¯¹äºå…¶ä»–å‘½ä»¤ï¼Œä¸å›å¤ï¼ˆé¿å…é¢‘ç¹æç¤ºï¼‰ï¼Œè®©ç”¨æˆ·ä½¿ç”¨å†…è”èœå•
      return
    }
    // ç§èŠä¸èµ°ç»‘å®š/å…è®¸æ ¡éªŒï¼Œç›´æ¥ç»§ç»­å¤„ç†
    return next()
  }
  const botId = await ensureCurrentBotId()
  const chatId = await ensureDbChat(ctx, chatState)
  const dbChat = await prisma.chat.findUnique({ where: { id: chatId }, select: { botId: true, allowed: true, bot: { select: { id: true, token: true } } } })
  const bypass = /^(?:\/start|\/myid|æ˜¾ç¤ºè´¦å•|\+0|ä½¿ç”¨è¯´æ˜)$/i.test(text)
  const currentToken = BOT_TOKEN
  const boundToken = (dbChat?.bot?.token || '').trim()
  // ğŸ”¥ è°ƒè¯•æ—¥å¿—ï¼šä»…åœ¨ DEBUG_BOT=true æ—¶è¾“å‡º
  if (process.env.DEBUG_BOT === 'true') {
    try {
      const mask = (s) => (s ? `${s.slice(0,4)}...${s.slice(-4)}` : '')
      console.log('[bind-check]', {
        chatId,
        botId,
        dbBotId: dbChat?.botId || null,
        allowed: !!dbChat?.allowed,
        currentToken4: mask(currentToken),
        boundToken4: mask(boundToken),
      })
    } catch {}
  }
  const notBound = !dbChat?.botId || (boundToken ? boundToken !== currentToken : (dbChat?.botId !== botId))
  // ä»…å¯¹æ–‡æœ¬æ¶ˆæ¯ç»™å‡ºæé†’ï¼Œä¸”åŠ é¢‘ç‡é™åˆ¶ï¼Œé¿å… 429
  if (notBound) {
    if (!text) return // éæ–‡æœ¬ï¼ˆå¦‚è½¬å‘/å›¾ç‰‡ç­‰ï¼‰ä¸æé†’
    if (!shouldWarnNow(chatId)) return
    const msg = 'æœ¬ç¾¤å°šæœªåœ¨åå°ç»‘å®šå½“å‰æœºå™¨äººï¼Œè¯·è”ç³»ç®¡ç†å‘˜åˆ°åå°ç»‘å®šåå†ä½¿ç”¨ã€‚'
    try { await ctx.reply(msg) } catch {}
    return
  }
  if (!dbChat?.allowed) {
    if (!text) return
    if (!shouldWarnNow(chatId)) return
    const msg = 'æœ¬ç¾¤å°šæœªè¢«åå°å…è®¸ä½¿ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜åœ¨åå°å°†æœ¬ç¾¤è®¾ç½®ä¸ºå…è®¸åå†ä½¿ç”¨ã€‚'
    try { await ctx.reply(msg) } catch {}
    return
  }
  return next()
})

// ===== è‡ªå®šä¹‰æŒ‡ä»¤è§¦å‘ï¼ˆæŒ‰ bot ç»´åº¦ï¼‰ =====
const CUSTOM_CMDS_CACHE = {
  map: null, // Record<string, { text?: string; imageUrl?: string }>
  ts: 0,
}

async function loadCustomCommandsForBot(botId) {
  // 5åˆ†é’Ÿç¼“å­˜
  const now = Date.now()
  if (CUSTOM_CMDS_CACHE.map && now - CUSTOM_CMDS_CACHE.ts < 5 * 60 * 1000) return CUSTOM_CMDS_CACHE.map
  try {
    const key = `customcmds:bot:${botId}`
    const row = await prisma.globalConfig.findUnique({ where: { key } })
    let map = {}
    if (row?.value) {
      try { map = JSON.parse(String(row.value) || '{}') } catch {}
    }
    CUSTOM_CMDS_CACHE.map = map
    CUSTOM_CMDS_CACHE.ts = now
    return map
  } catch {
    return {}
  }
}

bot.on('text', async (ctx, next) => {
  try {
    const text = (ctx.message?.text || '').trim()
    if (!text) return next()
    const botId = await ensureCurrentBotId()
    const map = await loadCustomCommandsForBot(botId)
    if (!map || typeof map !== 'object') return next()
    const key = text.toLowerCase()
    const item = map[key]
    if (!item) return next()

    const chatId = String(ctx.chat?.id || '')
    // ç®€æ´æ—¥å¿—ï¼ˆå‘½ä¸­ï¼‰
    console.log('[customcmd][hit]', { chatId, name: key })

    if (item.imageUrl && item.text) {
      await ctx.replyWithPhoto(item.imageUrl, { caption: item.text })
      return
    } else if (item.imageUrl) {
      await ctx.replyWithPhoto(item.imageUrl)
      return
    } else if (item.text) {
      await ctx.reply(item.text)
      return
    }
    return next()
  } catch (e) {
    console.error('[customcmd][error]', e?.message || e)
    return next()
  }
})

// ğŸ”¥ æ³¨å†Œæˆå‘˜å˜åŠ¨å¤„ç†å™¨ï¼ˆç»Ÿä¸€ç®¡ç†æœºå™¨äººè¿›å‡ºç¾¤ï¼‰
import { registerMemberHandlers } from './handlers/member-handler.js'
registerMemberHandlers(bot)

// ğŸ”¥ æ³¨å†Œæ‰€æœ‰å‘½ä»¤å¤„ç†å™¨ï¼ˆæ¨¡å—åŒ–ï¼‰
registerAllHandlers(bot, ensureChat)

// ğŸ”¥ ä½¿ç”¨æ¨¡å—åŒ–çš„æƒé™æ£€æŸ¥ä¸­é—´ä»¶ï¼ˆå‡å°‘ä»£ç ï¼Œæå‡æ€§èƒ½ï¼‰
bot.use(createPermissionMiddleware())

// è®¾ç½®ç¾¤å…¨ä½“ç¦è¨€/è§£é™¤ç¦è¨€ï¼ˆä¸å½±å“ç®¡ç†å‘˜ï¼‰ã€‚ç¦è¨€æ—¶ä¸ºæ“ä½œå‘˜åå•å•ç‹¬æ”¾è¡Œå‘è¨€ã€‚
// âš ï¸ æ³¨æ„ï¼šæ­¤åŠŸèƒ½éœ€è¦æœºå™¨äººæ‹¥æœ‰ç®¡ç†å‘˜æƒé™ï¼ˆé™åˆ¶æˆå‘˜æƒé™ï¼‰
async function setChatMute(ctx, enable) {
  const chatId = ctx.chat.id
  if (enable) {
    // å…¨ä½“ç¦è¨€ï¼ˆé»˜è®¤æƒé™å…¨éƒ¨å…³é—­ï¼‰
    await ctx.telegram.setChatPermissions(chatId, {
      can_send_messages: false,
      can_send_media_messages: false,
      can_send_polls: false,
      can_send_other_messages: false,
      can_add_web_page_previews: false,
      can_change_info: false,
      can_invite_users: false,
      can_pin_messages: false,
    })
    // æ”¾è¡Œæ“ä½œå‘˜ï¼ˆéç®¡ç†å‘˜ï¼‰
    const chat = ensureChat(ctx)
    if (chat && chat.operatorIds.size > 0) {
      for (const uid of chat.operatorIds) {
        try {
          await ctx.telegram.restrictChatMember(chatId, uid, {
            can_send_messages: true,
            can_send_media_messages: true,
            can_send_polls: true,
            can_send_other_messages: true,
            can_add_web_page_previews: true,
          })
        } catch {}
      }
    }
  } else {
    // æ¢å¤é»˜è®¤å…è®¸å‘è¨€
    await ctx.telegram.setChatPermissions(chatId, {
      can_send_messages: true,
      can_send_media_messages: true,
      can_send_polls: true,
      can_send_other_messages: true,
      can_add_web_page_previews: true,
      can_invite_users: true,
    })
  }
}

// å…¨å±€é”™è¯¯æ•è·ï¼šè¢«ç¾¤è¸¢å‡ºç­‰é”™è¯¯æ—¶é¿å…è¿›ç¨‹é€€å‡º
bot.catch(async (err, ctx) => {
  try {
    const code = err?.response?.error_code
    const desc = err?.response?.description || ''
    const chatId = String(ctx?.chat?.id || '')
    if (code === 403 && /kicked/i.test(desc)) {
      // è¢«ç§»é™¤ç¾¤ï¼šåˆ é™¤è¯¥ç¾¤è®°å½•
      if (chatId) {
        await prisma.operator.deleteMany({ where: { chatId } }).catch(() => {})
        await prisma.setting.deleteMany({ where: { chatId } }).catch(() => {})
        await prisma.chat.delete({ where: { id: chatId } }).catch(() => {})
      }
      return
    }
    // 429 ç­‰é”™è¯¯ä»…è®°å½•
    if (code === 429) return
  } catch {}
})

// ç›‘å¬æœºå™¨äººåœ¨ç¾¤å†…çš„æˆå‘˜çŠ¶æ€å˜åŒ–ï¼šå¦‚è¢«è¸¢/ç¦»å¼€åˆ™åˆ é™¤è®°å½•

// --- å®šæ—¶ä»»åŠ¡ ---

// æ±‡ç‡æ›´æ–°
async function updateAllRealtimeRates() {
  try {
    const { getOKXC2CSellers } = await import('../lib/okx-api.js')
    const sellers = await getOKXC2CSellers('all')
    if (!sellers || sellers.length === 0) return
    const okxRate = sellers[0].price

    // æ›´æ–°æ•°æ®åº“ä¸­æ‰€æœ‰ä½¿ç”¨å®æ—¶æ±‡ç‡çš„ç¾¤ç»„
    await prisma.setting.updateMany({
      where: { fixedRate: null },
        data: { realtimeRate: okxRate } 
      })

    if (process.env.DEBUG_BOT === 'true') {
        logger.debug(`[å®šæ—¶ä»»åŠ¡] æ±‡ç‡æ›´æ–°: ${okxRate}`)
    }
  } catch (e) {
    logger.error('[å®šæ—¶ä»»åŠ¡] æ±‡ç‡æ›´æ–°å¤±è´¥', e)
  }
}

// è‡ªåŠ¨æ—¥åˆ‡
  const autoDailyCutoffTask = async () => {
    try {
    // ä¼ å…¥è·å–èŠå¤©çŠ¶æ€çš„å›è°ƒ
      await performAutoDailyCutoff((botId, chatId) => {
        return getChat(botId || BOT_TOKEN, chatId)
      })
    } catch (e) {
    logger.error('[å®šæ—¶ä»»åŠ¡] è‡ªåŠ¨æ—¥åˆ‡æ£€æŸ¥å¤±è´¥', e)
    }
  }
  
// å¯åŠ¨æœºå™¨äººï¼Œæ˜ç¡®æŒ‡å®šå…è®¸çš„æ›´æ–°ç±»å‹ä»¥ç¡®ä¿æ¥æ”¶chat_memberäº‹ä»¶
bot.launch({
  allowedUpdates: [
    'message',
    'edited_message',
    'channel_post',
    'edited_channel_post',
    'inline_query',
    'chosen_inline_result',
    'callback_query',
    'shipping_query',
    'pre_checkout_query',
    'poll',
    'poll_answer',
    'my_chat_member',
    'chat_member',
    'chat_join_request'
  ]
}).then(async () => {
  console.info('âœ… Telegram æœºå™¨äººå·²å¯åŠ¨')
  await ensureCurrentBotId(bot) // åˆå§‹åŒ–æœºå™¨äººID

  // ç«‹å³æ‰§è¡Œä¸€æ¬¡ä»»åŠ¡
  updateAllRealtimeRates()
  autoDailyCutoffTask()

  // å¯åŠ¨å®šæ—¶å™¨
  setInterval(updateAllRealtimeRates, 10 * 60 * 1000) // 10åˆ†é’Ÿæ›´æ–°æ±‡ç‡
  setInterval(autoDailyCutoffTask, 10 * 60 * 1000) // 10åˆ†é’Ÿæ£€æŸ¥æ—¥åˆ‡
  setInterval(cleanupInactiveChats, 30 * 60 * 1000) // 30åˆ†é’Ÿæ¸…ç†å†…å­˜

  // è®¾ç½®æŒ‡ä»¤èœå• (ä»…ç§èŠ)
  const commands = [{ command: 'start', description: 'å¼€å§‹ä½¿ç”¨' }]
    await bot.telegram.setMyCommands(commands, { scope: { type: 'all_private_chats' } })
  await bot.telegram.setMyCommands([], { scope: { type: 'all_group_chats' } }) // ç¾¤èŠæ¸…é™¤èœå•

}).catch((err) => {
  console.error('âŒ æœºå™¨äººå¯åŠ¨å¤±è´¥', err)
  process.exit(1)
})

// ä¼˜é›…é€€å‡º
const cleanup = () => bot.stop('SIGTERM')
process.once('SIGTERM', cleanup)
process.once('SIGINT', cleanup)

export const commandsRegistry = [
  // åŸºç¡€è®°è´¦
  { type: 'exact', key: 'å¼€å§‹è®°è´¦', title: 'å¼€å§‹è®°è´¦', desc: 'æ¿€æ´»æœºå™¨äººå¹¶å¼€å§‹è®°å½•', examples: ['å¼€å§‹', 'å¼€å§‹è®°è´¦'], group: 'åŸºç¡€è®°è´¦' },
  { type: 'exact', key: 'åœæ­¢è®°è´¦', title: 'åœæ­¢è®°è´¦', desc: 'æš‚åœæœºå™¨äººè®°å½•', examples: ['åœæ­¢', 'åœæ­¢è®°è´¦'], group: 'åŸºç¡€è®°è´¦' },
  { type: 'prefix', key: 'ä¸‹å‘', title: 'ä¸‹å‘', desc: 'è®°å½•ä¸‹å‘é‡‘é¢ï¼Œæ”¯æŒ RMB/USDT', examples: ['ä¸‹å‘10', 'ä¸‹å‘10u'], group: 'åŸºç¡€è®°è´¦' },
  { type: 'prefix', key: 'å¤‡æ³¨ ä¸‹å‘', title: 'å¤‡æ³¨ä¸‹å‘', desc: 'å¤‡æ³¨é‡ä¸‹å‘', examples: ['å¤‡æ³¨ ä¸‹å‘1000'], group: 'åŸºç¡€è®°è´¦' },

  // è´¦å•ç›¸å…³
  { type: 'exact', key: 'æ˜¾ç¤ºè´¦å•', title: 'æ˜¾ç¤ºè´¦å•', desc: 'æŸ¥çœ‹å½“å‰è´¦å•', examples: ['æ˜¾ç¤ºè´¦å•', '+0'], group: 'è´¦å•' },
  { type: 'exact', key: 'æ˜¾ç¤ºå†å²è´¦å•', title: 'æ˜¾ç¤ºå†å²è´¦å•', desc: 'æŸ¥çœ‹å·²ä¿å­˜è´¦å•', examples: ['æ˜¾ç¤ºå†å²è´¦å•'], group: 'è´¦å•' },
  { type: 'exact', key: 'æŸ¥çœ‹è´¦å•', title: 'æŸ¥çœ‹è´¦å•', desc: 'æŸ¥çœ‹å®Œæ•´è´¦å•ï¼ˆåå°é“¾æ¥ï¼‰', examples: ['æŸ¥çœ‹è´¦å•'], group: 'è´¦å•' },
  { type: 'exact', key: 'ä¿å­˜è´¦å•', title: 'ä¿å­˜è´¦å•', desc: 'ä¿å­˜å¹¶æ¸…ç©ºå½“å‰', examples: ['ä¿å­˜è´¦å•'], group: 'è´¦å•' },
  { type: 'exact', key: 'åˆ é™¤è´¦å•', title: 'åˆ é™¤è´¦å•', desc: 'æ¸…ç©ºå½“å‰ï¼ˆä¸ä¿å­˜ï¼‰', examples: ['åˆ é™¤è´¦å•'], group: 'è´¦å•' },
  { type: 'exact', key: 'åˆ é™¤å…¨éƒ¨è´¦å•', title: 'åˆ é™¤å…¨éƒ¨è´¦å•', desc: 'æ¸…é™¤å…¨éƒ¨è´¦å•', examples: ['åˆ é™¤å…¨éƒ¨è´¦å•'], group: 'è´¦å•' },
  { type: 'exact', key: 'æˆ‘çš„è´¦å•', title: 'æˆ‘çš„è´¦å•', desc: 'æŸ¥çœ‹è‡ªå·±çš„è®°è´¦è®°å½•', examples: ['æˆ‘çš„è´¦å•', '/æˆ‘'], group: 'è´¦å•' },
  { type: 'exact', key: 'æŒ‡å®šè´¦å•', title: 'æŒ‡å®šè´¦å•', desc: 'å›å¤æŒ‡å®šäººæ¶ˆæ¯åæŸ¥çœ‹å…¶è®°å½•', examples: ['è´¦å•'], group: 'è´¦å•' },

  // å¸®åŠ©
  { type: 'exact', key: 'ä½¿ç”¨è¯´æ˜', title: 'ä½¿ç”¨è¯´æ˜', desc: 'æ˜¾ç¤ºå¸®åŠ©æ–‡æ¡£', examples: ['ä½¿ç”¨è¯´æ˜'], group: 'å¸®åŠ©' },

  // æ±‡ç‡/è´¹ç‡
  { type: 'prefix', key: 'è®¾ç½®æ±‡ç‡', title: 'è®¾ç½®æ±‡ç‡', desc: 'å›ºå®šæ±‡ç‡ï¼ˆ1U=...ï¼‰', examples: ['è®¾ç½®æ±‡ç‡ 7.2', 'è®¾ç½®æ±‡ç‡7.2'], group: 'æ±‡ç‡è´¹ç‡' },
  { type: 'exact', key: 'è®¾ç½®å®æ—¶æ±‡ç‡', title: 'è®¾ç½®å®æ—¶æ±‡ç‡', desc: 'è‡ªåŠ¨æŠ“å–å¸‚åœºæ±‡ç‡', examples: ['è®¾ç½®å®æ—¶æ±‡ç‡'], group: 'æ±‡ç‡è´¹ç‡' },
  { type: 'exact', key: 'åˆ·æ–°å®æ—¶æ±‡ç‡', title: 'åˆ·æ–°å®æ—¶æ±‡ç‡', desc: 'æ‰‹åŠ¨æ›´æ–°å®æ—¶æ±‡ç‡', examples: ['åˆ·æ–°å®æ—¶æ±‡ç‡'], group: 'æ±‡ç‡è´¹ç‡' },
  { type: 'exact', key: 'æ˜¾ç¤ºå®æ—¶æ±‡ç‡', title: 'æ˜¾ç¤ºå®æ—¶æ±‡ç‡', desc: 'æŸ¥çœ‹æ±‡ç‡', examples: ['æ˜¾ç¤ºå®æ—¶æ±‡ç‡'], group: 'æ±‡ç‡è´¹ç‡' },
  { type: 'prefix', key: 'è®¾ç½®è´§å¸', title: 'è®¾ç½®è´§å¸', desc: 'åˆ‡æ¢æœ¬ç¾¤è®°è´¦å¸ç§', examples: ['è®¾ç½®è´§å¸ USD', 'è®¾ç½®è´§å¸ CNY'], group: 'æ±‡ç‡è´¹ç‡' },
  { type: 'exact', key: 'æ˜¾ç¤ºè´§å¸', title: 'æ˜¾ç¤ºè´§å¸', desc: 'æŸ¥çœ‹å½“å‰ç¾¤çš„å¸ç§', examples: ['æ˜¾ç¤ºè´§å¸'], group: 'æ±‡ç‡è´¹ç‡' },
  { type: 'prefix', key: 'è®¾ç½®è´¹ç‡', title: 'è®¾ç½®è´¹ç‡', desc: 'è®¾ç½®æ‰‹ç»­è´¹ç™¾åˆ†æ¯”', examples: ['è®¾ç½®è´¹ç‡ 5'], group: 'æ±‡ç‡è´¹ç‡' },

  // é¢åº¦æé†’
  { type: 'prefix', key: 'è®¾ç½®é¢åº¦', title: 'è®¾ç½®é¢åº¦', desc: 'è®¾ç½®è¶…æŠ¼æé†’é¢åº¦', examples: ['è®¾ç½®é¢åº¦ 10000', 'è®¾ç½®é¢åº¦10000'], group: 'é¢åº¦æé†’' },

  // è®°è´¦æ¨¡å¼
  { type: 'prefix', key: 'è®¾ç½®è®°è´¦æ¨¡å¼', title: 'è®¾ç½®è®°è´¦æ¨¡å¼', desc: 'é€‰æ‹©è®°è´¦æ¨¡å¼', examples: ['è®¾ç½®è®°è´¦æ¨¡å¼ æ¸…é›¶æ¨¡å¼'], group: 'è®°è´¦æ¨¡å¼' },
  { type: 'prefix', key: 'æŸ¥çœ‹è®°è´¦æ¨¡å¼', title: 'æŸ¥çœ‹è®°è´¦æ¨¡å¼', desc: 'æŸ¥çœ‹å½“å‰æ¨¡å¼', examples: ['æŸ¥çœ‹è®°è´¦æ¨¡å¼'], group: 'è®°è´¦æ¨¡å¼' },
  { type: 'prefix', key: 'è®¾ç½®æ—¥åˆ‡æ—¶é—´', title: 'è®¾ç½®æ—¥åˆ‡æ—¶é—´', desc: 'è®¾ç½®æ¯æ—¥ç»“ç®—èµ·å§‹æ—¶é—´', examples: ['è®¾ç½®æ—¥åˆ‡æ—¶é—´ 2'], group: 'è®°è´¦æ¨¡å¼' },

  // æ˜¾ç¤ºæ¨¡å¼
  { type: 'prefix', key: 'æ˜¾ç¤ºæ¨¡å¼', title: 'æ˜¾ç¤ºæ¨¡å¼', desc: 'é…ç½®æ˜¾ç¤ºè®°å½•æ¡æ•°', examples: ['æ˜¾ç¤ºæ¨¡å¼4'], group: 'æ˜¾ç¤ºæ¨¡å¼' },
  { type: 'exact', key: 'äººæ°‘å¸æ¨¡å¼', title: 'å•å¸æ˜¾ç¤º', desc: 'ä»…æ˜¾ç¤ºå½“å‰å¸ç§', examples: ['äººæ°‘å¸æ¨¡å¼'], group: 'æ˜¾ç¤ºæ¨¡å¼' },
  { type: 'exact', key: 'åŒæ˜¾æ¨¡å¼', title: 'åŒå¸æ˜¾ç¤º', desc: 'å½“å‰å¸ç§ä¸USDTåŒæ˜¾', examples: ['åŒæ˜¾æ¨¡å¼'], group: 'æ˜¾ç¤ºæ¨¡å¼' },

  // æƒé™
  { type: 'prefix', key: 'æ·»åŠ æ“ä½œå‘˜', title: 'æ·»åŠ æ“ä½œå‘˜', desc: 'æ·»åŠ å¤šä¸ªæ“ä½œå‘˜', examples: ['æ·»åŠ æ“ä½œå‘˜ @AAA @BBB'], group: 'æƒé™' },
  { type: 'prefix', key: 'åˆ é™¤æ“ä½œå‘˜', title: 'åˆ é™¤æ“ä½œå‘˜', desc: 'åˆ é™¤å¤šä¸ªæ“ä½œå‘˜', examples: ['åˆ é™¤æ“ä½œå‘˜ @AAA @BBB'], group: 'æƒé™' },
  { type: 'exact', key: 'æ˜¾ç¤ºæ“ä½œäºº', title: 'æ˜¾ç¤ºæ“ä½œäºº', desc: 'æ˜¾ç¤ºç¾¤ç»„æƒé™ä¿¡æ¯', examples: ['æ˜¾ç¤ºæ“ä½œäºº', 'ç®¡ç†å‘˜', 'æƒé™äºº'], group: 'æƒé™' },

  // OKX æŸ¥è¯¢
  { type: 'exact', key: 'z0', title: 'z0', desc: 'OKX å®æ—¶Uä»·', examples: ['z0'], group: 'OKX' },
  { type: 'exact', key: 'lz', title: 'lz', desc: 'OKX æ”¯ä»˜å®Uä»·', examples: ['lz'], group: 'OKX' },
  { type: 'exact', key: 'lw', title: 'lw', desc: 'OKX å¾®ä¿¡Uä»·', examples: ['lw'], group: 'OKX' },
  { type: 'exact', key: 'lk', title: 'lk', desc: 'OKX é“¶è¡Œå¡Uä»·', examples: ['lk'], group: 'OKX' },

  // å…¶ä»–
  { type: 'prefix', key: 'è®¾ç½®æ ‡é¢˜', title: 'è®¾ç½®æ ‡é¢˜', desc: 'è‡ªå®šä¹‰è´¦å•æ ‡é¢˜', examples: ['è®¾ç½®æ ‡é¢˜ æœ¬ç¾¤è´¦å•'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'æ’¤é”€å…¥æ¬¾', title: 'æ’¤é”€å…¥æ¬¾', desc: 'æ’¤é”€æœ€è¿‘ä¸€æ¡å…¥æ¬¾è®°å½•', examples: ['æ’¤é”€å…¥æ¬¾'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'æ’¤é”€ä¸‹å‘', title: 'æ’¤é”€ä¸‹å‘', desc: 'æ’¤é”€æœ€è¿‘ä¸€æ¡ä¸‹å‘è®°å½•', examples: ['æ’¤é”€ä¸‹å‘'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'åˆ é™¤', title: 'åˆ é™¤', desc: 'å›å¤æŒ‡å®šè®°å½•æ¶ˆæ¯ååˆ é™¤è¯¥è®°å½•', examples: ['åˆ é™¤'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'æœºå™¨äººé€€ç¾¤', title: 'æœºå™¨äººé€€ç¾¤', desc: 'æœºå™¨äººé€€å‡ºæœ¬ç¾¤å¹¶æ¸…é™¤æ•°æ®', examples: ['æœºå™¨äººé€€ç¾¤'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'å¼€å¯æ‰€æœ‰åŠŸèƒ½', title: 'å¼€å¯æ‰€æœ‰åŠŸèƒ½', desc: 'å¯ç”¨æ‰€æœ‰åŠŸèƒ½å¼€å…³', examples: ['å¼€å¯æ‰€æœ‰åŠŸèƒ½'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'å…³é—­æ‰€æœ‰åŠŸèƒ½', title: 'å…³é—­æ‰€æœ‰åŠŸèƒ½', desc: 'å…³é—­æ‰€æœ‰åŠŸèƒ½å¼€å…³', examples: ['å…³é—­æ‰€æœ‰åŠŸèƒ½'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'æ‰“å¼€è®¡ç®—å™¨', title: 'æ‰“å¼€è®¡ç®—å™¨', desc: 'å¯ç”¨æ•°å­¦è®¡ç®—åŠŸèƒ½', examples: ['æ‰“å¼€è®¡ç®—å™¨'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'å…³é—­è®¡ç®—å™¨', title: 'å…³é—­è®¡ç®—å™¨', desc: 'ç¦ç”¨æ•°å­¦è®¡ç®—åŠŸèƒ½', examples: ['å…³é—­è®¡ç®—å™¨'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'ç¾¤åˆ—è¡¨', title: 'ç¾¤åˆ—è¡¨', desc: 'åˆ—å‡ºå½“å‰æœºå™¨äººæ‰€åœ¨çš„ç¾¤', examples: ['ç¾¤åˆ—è¡¨'], group: 'å…¶ä»–' },
  { type: 'prefix', key: 'æ·»åŠ è‡ªå®šä¹‰æŒ‡ä»¤', title: 'æ·»åŠ è‡ªå®šä¹‰æŒ‡ä»¤', desc: 'æ–°å¢æˆ–ç¼–è¾‘æ–‡æœ¬å†…å®¹', examples: ['æ·»åŠ è‡ªå®šä¹‰æŒ‡ä»¤ å°ååœ°å€ è¿™é‡Œæ˜¯å†…å®¹'], group: 'å…¶ä»–' },
  { type: 'prefix', key: 'è®¾ç½®è‡ªå®šä¹‰å›¾ç‰‡', title: 'è®¾ç½®è‡ªå®šä¹‰å›¾ç‰‡', desc: 'ä¸ºæŒ‡ä»¤è®¾ç½®å›¾ç‰‡URL', examples: ['è®¾ç½®è‡ªå®šä¹‰å›¾ç‰‡ å°ååœ°å€ https://.../img.png'], group: 'å…¶ä»–' },
  { type: 'prefix', key: 'åˆ é™¤è‡ªå®šä¹‰æŒ‡ä»¤', title: 'åˆ é™¤è‡ªå®šä¹‰æŒ‡ä»¤', desc: 'åˆ é™¤æŒ‡å®šçš„è‡ªå®šä¹‰æŒ‡ä»¤', examples: ['åˆ é™¤è‡ªå®šä¹‰æŒ‡ä»¤ å°ååœ°å€'], group: 'å…¶ä»–' },
  { type: 'exact', key: 'è‡ªå®šä¹‰æŒ‡ä»¤åˆ—è¡¨', title: 'è‡ªå®šä¹‰æŒ‡ä»¤åˆ—è¡¨', desc: 'æŸ¥çœ‹å·²é…ç½®çš„è‡ªå®šä¹‰æŒ‡ä»¤', examples: ['è‡ªå®šä¹‰æŒ‡ä»¤åˆ—è¡¨'], group: 'å…¶ä»–' },
]

export default commandsRegistry;
// In-memory state store per chat
// ä¼˜åŒ–ï¼šæ·»åŠ  LRU ç¼“å­˜å’Œå¤§å°é™åˆ¶ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼

import { LRUCache, limitMapSize, limitArraySize } from './lru-cache.js'

// é…ç½®é¡¹ï¼šå†…å­˜ä¼˜åŒ–ï¼ˆé™ä½å†…å­˜å ç”¨ï¼‰
const MAX_BOTS = 5 // æœ€å¤šæ”¯æŒçš„æœºå™¨äººæ•°é‡
const MAX_CHATS_PER_BOT = 100 // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šæ¯ä¸ªæœºå™¨äººæœ€å¤šç¼“å­˜çš„èŠå¤©æ•°é‡ï¼ˆä»500å‡å°‘åˆ°100ï¼‰
const MAX_USER_ID_CACHE = 100 // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šæ¯ä¸ªèŠå¤©æœ€å¤šç¼“å­˜çš„ç”¨æˆ·IDæ˜ å°„ï¼ˆä»200å‡å°‘åˆ°100ï¼‰
const MAX_COMMISSIONS = 30 // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šæ¯ä¸ªèŠå¤©æœ€å¤šç¼“å­˜çš„ä½£é‡‘è®°å½•ï¼ˆä»50å‡å°‘åˆ°30ï¼‰
const MAX_HISTORY = 5 // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šæœ€å¤šä¿ç•™çš„å†å²è´¦å•æ•°é‡ï¼ˆä»10å‡å°‘åˆ°5ï¼Œå†å²è®°å½•å­˜æ•°æ®åº“ï¼‰
const MAX_INCOMES = 100 // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šå½“å‰è´¦å•æœ€å¤šä¿ç•™çš„å…¥æ¬¾è®°å½•ï¼ˆä»200å‡å°‘åˆ°100ï¼Œå®é™…æ•°æ®åœ¨æ•°æ®åº“ï¼‰
const MAX_DISPATCHES = 100 // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šå½“å‰è´¦å•æœ€å¤šä¿ç•™çš„ä¸‹å‘è®°å½•ï¼ˆä»200å‡å°‘åˆ°100ï¼Œå®é™…æ•°æ®åœ¨æ•°æ®åº“ï¼‰

// ä½¿ç”¨ LRU ç¼“å­˜å­˜å‚¨ bot
const bots = new LRUCache(MAX_BOTS)

function ensureBot(botId) {
  if (!bots.has(botId)) {
    bots.set(botId, new LRUCache(MAX_CHATS_PER_BOT))
  }
  return bots.get(botId)
}

function createInitialChatState() {
  return {
    operators: new Set(),
    operatorIds: new Set(), // Set<number>
    userIdByUsername: new Map(), // Map<@username, userId> - ä¼šå®šæœŸæ¸…ç†
    everyoneAllowed: false,
    headerText: '',
    fixedRate: null, // number | null
    realtimeRate: null, // ğŸ”¥ ä¿®æ”¹ï¼šä¸å†é»˜è®¤7.15ï¼Œå¯åŠ¨æ—¶è·å–æœ€æ–°æ±‡ç‡
    feePercent: 0, // 0-100
    displayMode: 1, // 1 | 2 | 3
    rmbMode: false,
    currencyCode: 'cny',
    commissionMode: false,
    commissions: new Map(), // username -> number - ä¼šå®šæœŸæ¸…ç†
    muteMode: false,
    workStartedAt: null, // Date | null
    workTotalMs: 0, // number
    lastActivityAt: Date.now(), // æœ€åæ´»åŠ¨æ—¶é—´ï¼ˆç”¨äºæ¸…ç†ä¸æ´»è·ƒçš„èŠå¤©ï¼‰
    // current working bill (not yet saved)
    current: {
      incomes: [], // ä¼šå®šæœŸé™åˆ¶å¤§å°
      dispatches: [], // ä¼šå®šæœŸé™åˆ¶å¤§å°
    },
    // saved bills history (array of snapshots)
    history: [], // ä¼šå®šæœŸé™åˆ¶å¤§å°
  }
}

function getChat(botId, chatId) {
  const botChats = ensureBot(botId)
  if (!botChats.has(chatId)) {
    botChats.set(chatId, createInitialChatState())
  }
  const chat = botChats.get(chatId)

  // æ›´æ–°æœ€åæ´»åŠ¨æ—¶é—´
  chat.lastActivityAt = Date.now()

  // å®šæœŸæ¸…ç†å¤§å‹æ•°æ®ç»“æ„ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
  limitMapSize(chat.userIdByUsername, MAX_USER_ID_CACHE)
  limitMapSize(chat.commissions, MAX_COMMISSIONS)
  chat.history = limitArraySize(chat.history, MAX_HISTORY)
  chat.current.incomes = limitArraySize(chat.current.incomes, MAX_INCOMES)
  chat.current.dispatches = limitArraySize(chat.current.dispatches, MAX_DISPATCHES)

  return chat
}

/**
 * æ¸…ç†ä¸æ´»è·ƒçš„èŠå¤©ï¼ˆğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šå‡å°‘é˜ˆå€¼ï¼Œæ›´é¢‘ç¹æ¸…ç†ï¼‰
 */
function cleanupInactiveChats() {
  const now = Date.now()
  const INACTIVE_THRESHOLD = 2 * 60 * 60 * 1000 // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šä»24å°æ—¶å‡å°‘åˆ°2å°æ—¶

  let cleaned = 0
  let removed = 0
  for (const [botId, botChats] of bots.cache.entries()) {
    const chatsToRemove = []
    for (const [chatId, chat] of botChats.cache.entries()) {
      if (now - chat.lastActivityAt > INACTIVE_THRESHOLD) {
        // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šå®Œå…¨ç§»é™¤ä¸æ´»è·ƒçš„èŠå¤©ï¼Œè€Œä¸æ˜¯åªæ¸…ç†æ•°æ®
        chatsToRemove.push(chatId)
        cleaned++
      } else {
        // æ¸…ç†å¤§å‹æ•°æ®ç»“æ„ï¼ˆå³ä½¿è¿˜æ²¡åˆ°é˜ˆå€¼ï¼Œä¹Ÿå®šæœŸæ¸…ç†ï¼‰
        chat.userIdByUsername.clear()
        chat.commissions.clear()
        // ğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šåªä¿ç•™æœ€è¿‘çš„æ•°æ®
        chat.current.incomes = chat.current.incomes.slice(-50)
        chat.current.dispatches = chat.current.dispatches.slice(-50)
        chat.history = chat.history.slice(-3)
      }
    }
    // ç§»é™¤ä¸æ´»è·ƒçš„èŠå¤©
    for (const chatId of chatsToRemove) {
      botChats.delete(chatId)
      removed++
    }
  }

  if (cleaned > 0) {
    console.log(`[memory-cleanup] æ¸…ç†äº† ${cleaned} ä¸ªä¸æ´»è·ƒçš„èŠå¤©ï¼Œç§»é™¤äº† ${removed} ä¸ª`)
  }
}

/**
 * å®‰å…¨åœ°è®¡ç®—æ•°å­¦è¡¨è¾¾å¼ï¼ˆåªæ”¯æŒæ•°å­—å’Œ + - * /ï¼‰
 * @param {string} expr - æ•°å­¦è¡¨è¾¾å¼ï¼Œå¦‚ "100-50", "100*2", "80/2"
 * @returns {number|null} - è®¡ç®—ç»“æœï¼Œå¦‚æœè¡¨è¾¾å¼æ— æ•ˆè¿”å› null
 */
function safeCalculate(expr) {
  try {
    // ç§»é™¤æ‰€æœ‰ç©ºæ ¼
    const clean = expr.replace(/\s+/g, '')

    // å®‰å…¨æ£€æŸ¥ï¼šåªå…è®¸æ•°å­—ã€å°æ•°ç‚¹å’Œè¿ç®—ç¬¦
    if (!/^[\d+\-*/.()]+$/.test(clean)) {
      return null
    }

    // ä½¿ç”¨ Function æ„é€ å‡½æ•°æ¯” eval æ›´å®‰å…¨
    // ä½†ä»ç„¶éœ€è¦ä¸¥æ ¼éªŒè¯è¾“å…¥
    const result = Function('"use strict"; return (' + clean + ')')()

    // æ£€æŸ¥ç»“æœæ˜¯å¦ä¸ºæœ‰æ•ˆæ•°å­—
    if (!Number.isFinite(result)) {
      return null
    }

    return Number(result.toFixed(1))
  } catch (e) {
    return null
  }
}

/**
 * ğŸ”¥ å¢å¼ºç‰ˆè§£æå‡½æ•°ï¼šæ”¯æŒå•ç‹¬æ±‡ç‡ã€å•ç‹¬è´¹ç‡ã€ç»„åˆæ ¼å¼ã€æ•°å­¦è¡¨è¾¾å¼
 * æ”¯æŒçš„æ ¼å¼ï¼š
 * - +1000ï¼ˆç®€å•æ•°å­—ï¼‰
 * - +3232+321ï¼ˆåŠ æ³•è®¡ç®—ï¼Œç»“æœ+3553ï¼‰
 * - +100-20ï¼ˆå‡æ³•è®¡ç®—ï¼Œç»“æœ+80ï¼‰
 * - +1000*0.95ï¼ˆå•ç‹¬è´¹ç‡ï¼Œç»“æœ+950ï¼‰
 * - +100/2ï¼ˆå•ç‹¬æ±‡ç‡ï¼Œ100å…ƒæŒ‰æ±‡ç‡2è®¡ç®—ä¸º50Uï¼Œå…¥è´¦100å…ƒï¼‰
 * - +1000/7ï¼ˆæŒ‡å®šæ±‡ç‡7ï¼‰
 * - +1000/7*0.95ï¼ˆç»„åˆï¼šæ±‡ç‡å’Œè´¹ç‡ï¼‰
 * - +1000u/7*0.95ï¼ˆç»„åˆï¼šUSDT + æ±‡ç‡ + è´¹ç‡ï¼‰
 * 
 * ğŸ”¥ é‡è¦è§„åˆ™ï¼š
 * - * è¡¨ç¤ºè´¹ç‡ï¼ˆå¦‚ +1000*0.95 = 950å…ƒï¼‰
 * - / è¡¨ç¤ºæ±‡ç‡ï¼ˆå¦‚ +100/2 = 100å…ƒæŒ‰æ±‡ç‡2è®¡ç®—ï¼‰
 * - +ã€- è¡¨ç¤ºæ•°å­¦è®¡ç®—ï¼ˆå¦‚ +100-20 = 80å…ƒï¼‰
 */
function parseAmountAndRate(text) {
  let rate = null
  let feeRate = null
  let amount = null

  // ğŸ”¥ å¤„ç†ç»„åˆæ ¼å¼ï¼š+1000/7*0.95 æˆ– +1000u/7*0.95
  const comboMatch = text.match(/^([+\-]?\d+(?:\.\d+)?)\s*\/\s*(\d+(?:\.\d+)?)\s*\*\s*(\d+(?:\.\d+)?)$/)
  if (comboMatch) {
    amount = Number(comboMatch[1])
    rate = Number(comboMatch[2])
    feeRate = Number(comboMatch[3])
    if (Number.isFinite(amount) && Number.isFinite(rate) && Number.isFinite(feeRate)) {
      return { amount, rate, feeRate }
    }
  }

  // ğŸ”¥ å•ç‹¬è´¹ç‡æ ¼å¼ï¼š+1000u*0.95 æˆ– +1000*0.95ï¼ˆä¹˜æ³•æ˜¯è´¹ç‡ï¼‰
  const feeMatch = text.match(/^([+\-]?\d+(?:\.\d+)?)\s*\*\s*(\d+(?:\.\d+)?)$/)
  if (feeMatch) {
    amount = Number(feeMatch[1])
    feeRate = Number(feeMatch[2])
    if (Number.isFinite(amount) && Number.isFinite(feeRate)) {
      return { amount, rate, feeRate }
    }
  }

  // ğŸ”¥ å•ç‹¬æ±‡ç‡æ ¼å¼ï¼š+1000u/7 æˆ– +100/2ï¼ˆé™¤æ³•æ˜¯æ±‡ç‡ï¼‰
  const rateMatch = text.match(/^([+\-]?\d+(?:\.\d+)?)\s*\/\s*(\d+(?:\.\d+)?)$/)
  if (rateMatch) {
    amount = Number(rateMatch[1])
    rate = Number(rateMatch[2])
    if (Number.isFinite(amount) && Number.isFinite(rate) && rate > 0) {
      return { amount, rate, feeRate }
    }
  }

  // ğŸ”¥ å¤„ç†åŠ å‡æ³•è®¡ç®—ï¼š+3232+321, +100-20ï¼ˆåŠ å‡æ³•æ‰æ˜¯æ•°å­¦è®¡ç®—ï¼‰
  const expr = text.trim()
  const firstChar = expr[0]
  const hasLeadingSign = firstChar === '+' || firstChar === '-'
  const sign = firstChar === '-' ? '-' : ''
  const cleanExpr = hasLeadingSign ? expr.slice(1) : expr

  // æ£€æŸ¥æ˜¯å¦åŒ…å«åŠ å‡è¿ç®—ç¬¦ï¼ˆä¸åŒ…æ‹¬ä¹˜é™¤ï¼Œä¹˜é™¤æ˜¯è´¹ç‡/æ±‡ç‡ï¼‰
  if (/[+\-]/.test(cleanExpr)) {
    const calculated = safeCalculate(sign + cleanExpr)
    if (calculated !== null && Number.isFinite(calculated)) {
      return { amount: calculated, rate, feeRate }
    }
  }

  // ğŸ”¥ ç®€å•æ•°å­—ï¼š+1000 æˆ– -1000
  amount = Number(sign + cleanExpr)
  if (!Number.isFinite(amount)) return null

  return { amount, rate, feeRate }
}

function calcUSDT(amountRMB, rate) {
  if (!rate || rate <= 0) return 0
  return Number((amountRMB / rate).toFixed(2))
}

/**
 * æ±‡æ€»å½“å‰è´¦å•
 * @param {object} chat - å†…å­˜ä¸­çš„èŠå¤©çŠ¶æ€
 */
function summarize(chat) {
  // ğŸ”¥ ç¡®ä¿ç²¾åº¦ï¼šä½¿ç”¨ Number è½¬æ¢ï¼Œé¿å…æµ®ç‚¹æ•°ç´¯åŠ ç²¾åº¦é—®é¢˜
  const totalIncome = Number(chat.current.incomes.reduce((s, i) => {
    const amount = Number(i.amount) || 0
    return s + amount
  }, 0).toFixed(2))
  
  const totalDispatched = Number(chat.current.dispatches.reduce((s, d) => {
    const amount = Number(d.amount) || 0
    return s + amount
  }, 0).toFixed(2))

  const effectiveRate = chat.fixedRate ?? chat.realtimeRate ?? 0
  const fee = Number(((totalIncome * chat.feePercent) / 100).toFixed(2))
  // å…è®¸è´Ÿæ•°ï¼šå½“æœ‰è´Ÿæ•°å…¥æ¬¾æ—¶ä¹Ÿè®¡å…¥
  const shouldDispatch = Number((totalIncome - fee).toFixed(2))

  // é€ç¬”æŒ‰æŒ‡å®šæ±‡ç‡è®¡ç®—å…¥æ¬¾USDTæ€»å’Œï¼ˆè‹¥è¯¥ç¬”æ— rateåˆ™å›é€€åˆ°å½“å‰æœ‰æ•ˆæ±‡ç‡ï¼‰
  // ğŸ”¥ ç¡®ä¿ç²¾åº¦ï¼šæ¯æ­¥è®¡ç®—éƒ½ä½¿ç”¨ Number è½¬æ¢
  const incomeUSDTTotal = Number(chat.current.incomes.reduce((sum, i) => {
    const rateUsed = (i.rate != null ? i.rate : effectiveRate)
    if (!rateUsed || rateUsed <= 0) return sum
    const amount = Number(i.amount) || 0
    return sum + (amount / rateUsed)
  }, 0).toFixed(2))

  // è´¹ç”¨åœ¨USDTå±‚é¢æŒ‰æ¯”ä¾‹æ‰£å‡ï¼šç­‰åŒäº incomeUSDTTotal * (1 - feePercent/100)
  const shouldDispatchUSDT = Number((incomeUSDTTotal * (1 - (chat.feePercent || 0) / 100)).toFixed(2))

  // ä¸‹å‘USDTä¼˜å…ˆä½¿ç”¨æ¯æ¡è®°å½•è‡ªå¸¦usdtå­—æ®µï¼Œç¼ºå¤±åˆ™å›é€€ç”¨æœ‰æ•ˆæ±‡ç‡æ¢ç®—
  // ğŸ”¥ ç¡®ä¿ç²¾åº¦ï¼šæ¯æ­¥è®¡ç®—éƒ½ä½¿ç”¨ Number è½¬æ¢
  const dispatchedUSDT = Number(chat.current.dispatches.reduce((sum, d) => {
    if (typeof d.usdt === 'number' && Number.isFinite(d.usdt)) {
      return sum + Number(d.usdt)
    }
    return sum + calcUSDT(d.amount, effectiveRate)
  }, 0).toFixed(2))

  // å…è®¸è´Ÿæ•°ï¼šå½“ä¸‹å‘è¶…è¿‡åº”ä¸‹å‘æ—¶ä¸ºè´Ÿ
  const notDispatched = Number((shouldDispatch - totalDispatched).toFixed(2))
  const notDispatchedUSDT = Number((shouldDispatchUSDT - dispatchedUSDT).toFixed(2))

  return {
    totalIncome,
    totalIncomeUSDT: incomeUSDTTotal,
    feePercent: chat.feePercent,
    effectiveRate,
    shouldDispatch,
    shouldDispatchUSDT,
    dispatched: totalDispatched,
    dispatchedUSDT,
    notDispatched,
    notDispatchedUSDT,
  }
}

export { getChat, parseAmountAndRate, calcUSDT, summarize, safeCalculate, cleanupInactiveChats }
// ä¸­é—´ä»¶æ¨¡å—
import { prisma } from '../lib/db.js'
import { ensureDbChat } from './database.js'
import { LRUCache } from './lru-cache.js'
import { DEFAULT_FEATURES } from './constants.js'

// åŠŸèƒ½å¼€å…³ç¼“å­˜ï¼ˆğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šå‡å°‘ç¼“å­˜å¤§å°ï¼‰
const featureCache = new LRUCache(100)
const FEATURE_TTL_MS = 30 * 60 * 1000 // 30åˆ†é’Ÿï¼ˆå‡å°‘TTLï¼‰

/**
 * æ£€æŸ¥åŠŸèƒ½æ˜¯å¦å¯ç”¨
 */
export async function isFeatureEnabled(ctx, feature) {
  try {
    const chatId = await ensureDbChat(ctx)
    if (!chatId) {
      // ğŸ”¥ å¦‚æœæ²¡æœ‰ chatIdï¼Œé»˜è®¤å…è®¸ä½¿ç”¨ï¼ˆç¡®ä¿æ–°ç¾¤ç»„å¯ä»¥æ­£å¸¸ä½¿ç”¨ï¼‰
      return true
    }

    const now = Date.now()
    const cached = featureCache.get(chatId)
    if (cached && cached.expires > now) {
      return cached.set.has(feature)
    }

    const flags = await prisma.chatFeatureFlag.findMany({
      where: { chatId },
      select: { feature: true, enabled: true }
    })

    // ğŸ”¥ å¦‚æœæ²¡æœ‰åŠŸèƒ½å¼€å…³è®°å½•ï¼Œé»˜è®¤å…è®¸ä½¿ç”¨ï¼ˆç¡®ä¿é»˜è®¤å¯ç”¨ï¼‰
    // ç¼“å­˜æ‰€æœ‰é»˜è®¤åŠŸèƒ½ï¼Œé¿å…é‡å¤æŸ¥è¯¢
    if (flags.length === 0) {
      const defaultSet = new Set(DEFAULT_FEATURES)
      featureCache.set(chatId, { expires: now + FEATURE_TTL_MS, set: defaultSet })
      return true // é»˜è®¤å…¨éƒ¨å¯ç”¨
    }

    // ğŸ”¥ åªè¿”å›æ˜ç¡®å¯ç”¨ï¼ˆenabled: trueï¼‰çš„åŠŸèƒ½
    const set = new Set(flags.filter(f => f.enabled).map(f => f.feature))

    featureCache.set(chatId, { expires: now + FEATURE_TTL_MS, set })
    return set.has(feature)
  } catch (e) {
    console.error('[isFeatureEnabled] å¼‚å¸¸', { feature, error: e.message })
    // ğŸ”¥ å¼‚å¸¸æ—¶é»˜è®¤å…è®¸ï¼Œç¡®ä¿å¯ç”¨æ€§
    return true
  }
}

/**
 * æ¸…é™¤åŠŸèƒ½å¼€å…³ç¼“å­˜ï¼ˆç”¨äºåŠŸèƒ½å¼€å…³æ›´æ–°åç«‹å³ç”Ÿæ•ˆï¼‰
 */
export function clearFeatureCache(chatId) {
  featureCache.delete(chatId)
}

/**
 * åˆ¤æ–­æ˜¯å¦æ˜¯è®°è´¦å‘½ä»¤
 */
export function isAccountingCommand(text) {
  if (!text) return false
  const t = text.trim()
  if (/^(å¼€å§‹è®°è´¦|å¼€å§‹|åœæ­¢è®°è´¦|åœæ­¢)$/i.test(t)) return true // ğŸ”¥ æ·»åŠ å¼€å§‹/åœæ­¢å‘½ä»¤
  if (/^[+\-]\s*[\d+\-*/.()]/i.test(t)) return true
  if (/^(ä¸‹å‘)\b/.test(t)) return true
  if (/^(æ˜¾ç¤ºè´¦å•|\+0)$/i.test(t)) return true
  if (/^æ˜¾ç¤ºå†å²è´¦å•$/i.test(t)) return true
  if (/^(ä¿å­˜è´¦å•|åˆ é™¤è´¦å•|åˆ é™¤å…¨éƒ¨è´¦å•|æ¸…é™¤å…¨éƒ¨è´¦å•)$/i.test(t)) return true
  if (/^(æˆ‘çš„è´¦å•|\/æˆ‘)$/i.test(t)) return true
  return false
}

// ğŸ”¥ è®°è´¦å¼€å…³ç¼“å­˜ï¼ˆå‡å°‘æ•°æ®åº“æŸ¥è¯¢ï¼ŒğŸ”¥ å†…å­˜ä¼˜åŒ–ï¼šå‡å°‘ç¼“å­˜å¤§å°ï¼‰
const accountingEnabledCache = new LRUCache(100)
const ACCOUNTING_CACHE_TTL_MS = 5 * 60 * 1000 // 5åˆ†é’Ÿ

/**
 * æ£€æŸ¥è®°è´¦æ˜¯å¦å¯ç”¨ï¼ˆå¸¦ç¼“å­˜ä¼˜åŒ–ï¼‰
 */
export async function isAccountingEnabled(ctx) {
  try {
    const chatId = await ensureDbChat(ctx)
    if (!chatId) return true // é»˜è®¤å¼€å¯

    // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ç¼“å­˜å‡å°‘æ•°æ®åº“æŸ¥è¯¢
    const now = Date.now()
    const cached = accountingEnabledCache.get(chatId)
    if (cached && cached.expires > now) {
      return cached.enabled
    }

    const setting = await prisma.setting.findUnique({
      where: { chatId },
      select: { accountingEnabled: true }
    })

    // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦ï¼ˆå¦‚æœå­—æ®µä¸å­˜åœ¨ï¼Œè§†ä¸ºå¼€å¯ï¼‰
    const enabled = setting?.accountingEnabled !== false
    accountingEnabledCache.set(chatId, { expires: now + ACCOUNTING_CACHE_TTL_MS, enabled })
    return enabled
  } catch (e) {
    console.error('[isAccountingEnabled] å¼‚å¸¸', e)
    return true // å‡ºé”™æ—¶é»˜è®¤å¼€å¯
  }
}

/**
 * æ¸…é™¤è®°è´¦å¼€å…³ç¼“å­˜ï¼ˆç”¨äºæ›´æ–°åç«‹å³ç”Ÿæ•ˆï¼‰
 */
export function clearAccountingCache(chatId) {
  accountingEnabledCache.delete(chatId)
}

/**
 * æƒé™æ£€æŸ¥ä¸­é—´ä»¶
 */
export function createPermissionMiddleware() {
  return async (ctx, next) => {
    try {
      const text = ctx.message?.text
      if (!text || !isAccountingCommand(text)) {
        return next()
      }

      // ğŸ”¥ æ£€æŸ¥è®°è´¦æ˜¯å¦å¯ç”¨
      const accountingOk = await isAccountingEnabled(ctx)
      if (!accountingOk) {
        try {
          const chatId = await ensureDbChat(ctx)
          const setting = await prisma.setting.findUnique({
            where: { chatId },
            select: { featureWarningMode: true }
          })

          const warningMode = setting?.featureWarningMode || 'always'
          let shouldWarn = false

          if (warningMode === 'always') {
            shouldWarn = true
            // ğŸ”¥ æ¸…é™¤ä¹‹å‰çš„è­¦å‘Šè®°å½•ï¼Œç¡®ä¿åˆ‡æ¢åˆ°alwaysæ¨¡å¼åç«‹å³ç”Ÿæ•ˆ
            await prisma.featureWarningLog.deleteMany({
              where: { chatId, feature: 'accounting_disabled' }
            }).catch(() => { })
          } else if (warningMode === 'once') {
            const existingLog = await prisma.featureWarningLog.findUnique({
              where: { chatId_feature: { chatId, feature: 'accounting_disabled' } }
            })
            if (!existingLog) {
              shouldWarn = true
              await prisma.featureWarningLog.upsert({
                where: { chatId_feature: { chatId, feature: 'accounting_disabled' } },
                create: { chatId, feature: 'accounting_disabled' },
                update: { warnedAt: new Date() }
              }).catch(() => { })
            }
          } else if (warningMode === 'daily') {
            const existingLog = await prisma.featureWarningLog.findUnique({
              where: { chatId_feature: { chatId, feature: 'accounting_disabled' } }
            })
            const now = new Date()
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())

            if (!existingLog || existingLog.warnedAt < today) {
              shouldWarn = true
              await prisma.featureWarningLog.upsert({
                where: { chatId_feature: { chatId, feature: 'accounting_disabled' } },
                create: { chatId, feature: 'accounting_disabled' },
                update: { warnedAt: now }
              }).catch(() => { })
            }
          }
          // warningMode === 'silent' æ—¶ä¸æé†’

          if (shouldWarn) {
            return ctx.reply('â¸ï¸ è®°è´¦åŠŸèƒ½å·²æš‚åœï¼Œå‘é€"å¼€å§‹"å¯é‡æ–°æ¿€æ´»è®°è´¦ã€‚')
          }
        } catch (e) {
          console.error('[è®°è´¦æš‚åœæ£€æŸ¥][é”™è¯¯]', e)
          // å‡ºé”™æ—¶é»˜è®¤æé†’
          return ctx.reply('â¸ï¸ è®°è´¦åŠŸèƒ½å·²æš‚åœï¼Œå‘é€"å¼€å§‹"å¯é‡æ–°æ¿€æ´»è®°è´¦ã€‚')
        }
        return // ä¸æé†’ï¼Œç›´æ¥è¿”å›
      }

      const ok = await isFeatureEnabled(ctx, 'accounting_basic')
      if (!ok) {
        try {
          const chatId = await ensureDbChat(ctx)
          const setting = await prisma.setting.findUnique({
            where: { chatId },
            select: { featureWarningMode: true }
          })

          const warningMode = setting?.featureWarningMode || 'always'
          let shouldWarn = false

          if (warningMode === 'always') {
            shouldWarn = true
          } else if (warningMode === 'once') {
            const existingLog = await prisma.featureWarningLog.findUnique({
              where: { chatId_feature: { chatId, feature: 'accounting_basic' } }
            })
            if (!existingLog) {
              shouldWarn = true
              await prisma.featureWarningLog.upsert({
                where: { chatId_feature: { chatId, feature: 'accounting_basic' } },
                create: { chatId, feature: 'accounting_basic' },
                update: { warnedAt: new Date() }
              }).catch(() => { })
            }
          } else if (warningMode === 'daily') {
            const existingLog = await prisma.featureWarningLog.findUnique({
              where: { chatId_feature: { chatId, feature: 'accounting_basic' } }
            })
            const now = new Date()
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())

            if (!existingLog || existingLog.warnedAt < today) {
              shouldWarn = true
              await prisma.featureWarningLog.upsert({
                where: { chatId_feature: { chatId, feature: 'accounting_basic' } },
                create: { chatId, feature: 'accounting_basic' },
                update: { warnedAt: now }
              }).catch(() => { })
            }
          }

          if (shouldWarn) {
            await ctx.reply('æœªå¼€é€šåŸºç¡€è®°è´¦åŠŸèƒ½')
          }
        } catch (e) {
          console.error('[æƒé™æ£€æŸ¥][é”™è¯¯]', e)
        }
        return
      }

      return next()
    } catch (e) {
      console.error('[æƒé™æ£€æŸ¥ä¸­é—´ä»¶][å¼‚å¸¸]', e)
      return next()
    }
  }
}

import 'dotenv/config'
import { spawn } from 'node:child_process'
import { fileURLToPath } from 'node:url'
import path from 'node:path'
import fs from 'node:fs'
import dotenv from 'dotenv'
import { prisma } from '../lib/db.js'
import logger from './logger.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// Fallback: if DATABASE_URL not set by .env, try config/env
if (!process.env.DATABASE_URL) {
  const configEnvPath = path.resolve(__dirname, '../config/env')
  if (fs.existsSync(configEnvPath)) {
    dotenv.config({ path: configEnvPath })
  }
}

logger.initLogger({ dir: 'logs', level: process.env.DEBUG_BOT === 'true' ? 'debug' : 'info', stdout: true })
logger.hijackConsole()
console.log('[manager] DATABASE_URL=', process.env.DATABASE_URL)

const children = new Map() // botId -> ChildProcess

function startBotProcess(bot) {
  if (children.has(bot.id)) return
  const env = { ...process.env, BOT_TOKEN: bot.token }
  if (bot.proxyUrl) env.PROXY_URL = bot.proxyUrl
  const child = spawn('node', [path.resolve(__dirname, './index.js')], {
    stdio: 'inherit',
    env,
  })
  children.set(bot.id, child)
  child.on('exit', (code) => {
    children.delete(bot.id)
    console.log(`[bot:${bot.name}] é€€å‡º code=${code}`)
  })
  console.log(`[bot:${bot.name}] å·²å¯åŠ¨`)
}

function stopBotProcess(botId) {
  const child = children.get(botId)
  if (child) {
    child.kill('SIGTERM')
    children.delete(botId)
  }
}

async function syncBotsOnce() {
  const bots = await prisma.bot.findMany({ where: { enabled: true } })
  const running = new Set(children.keys())
  const shouldRun = new Set(bots.map(b => b.id))

  // start new ones
  for (const bot of bots) {
    if (!running.has(bot.id)) startBotProcess(bot)
  }
  // stop disabled/removed
  for (const id of running) {
    if (!shouldRun.has(id)) stopBotProcess(id)
  }
}

async function main() {
  await syncBotsOnce()
  // poll every 30s for changes
  setInterval(() => {
    syncBotsOnce().catch((e) => console.error('syncBotsOnce error', e))
  }, 30000)
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})
// è¾…åŠ©å‡½æ•°æ¨¡å—
import { prisma } from '../lib/db.js'
import { formatMoney, isPublicUrl } from './utils.js'

const BACKEND_URL = process.env.BACKEND_URL

/**
 * è·å–è´§å¸ç¬¦å·æˆ–ç®€ç 
 */
export function getDisplayCurrencySymbol(code = 'cny') {
  const lc = String(code || '').toLowerCase()
  switch (lc) {
    case 'cny': return 'Â¥'
    case 'usd': return '$'
    case 'hkd': return 'HK$'
    case 'eur': return 'â‚¬'
    case 'jpy': return 'Â¥'
    case 'twd': return 'NT$'
    case 'krw': return 'â‚©'
    case 'gbp': return 'Â£'
    case 'aud': return 'A$'
    case 'chf': return 'CHF'
    case 'cad': return 'C$'
    case 'nzd': return 'NZ$'
    default: return lc.toUpperCase()
  }
}

/**
 * è·å– USDT -> ç›®æ ‡æ³•å¸ çš„æ±‡ç‡ï¼Œä¿ç•™ä¸¤ä½å°æ•°
 * ä¸»æºï¼šjsdelivrï¼›å¤‡æºï¼šCloudflare
 */
export async function fetchUsdtToFiatRate(code = 'cny') {
  const lc = String(code || 'cny').toLowerCase()
  const controller = new AbortController()
  const timeout = setTimeout(() => controller.abort(), 5000)
  try {
    const url = 'https://cdn.jsdelivr.net/npm/@fawazahmed0/currency-api@latest/v1/currencies/usdt.json'
    const resp = await fetch(url, { method: 'GET', signal: controller.signal })
    if (resp.ok) {
      const data = await resp.json()
      const rate = Number(data?.usdt?.[lc])
      if (Number.isFinite(rate) && rate > 0) return Number(rate.toFixed(2))
    }
    // fallthrough to fallback
  } catch {
    // ignore and try fallback
  } finally {
    clearTimeout(timeout)
  }

  const controller2 = new AbortController()
  const timeout2 = setTimeout(() => controller2.abort(), 5000)
  try {
    const url2 = 'https://latest.currency-api.pages.dev/v1/currencies/usdt.json'
    const resp2 = await fetch(url2, { method: 'GET', signal: controller2.signal })
    if (resp2.ok) {
      const data2 = await resp2.json()
      const rate2 = Number(data2?.usdt?.[lc])
      if (Number.isFinite(rate2) && rate2 > 0) return Number(rate2.toFixed(2))
    }
  } catch {
    // ignore
  } finally {
    clearTimeout(timeout2)
  }
  return null
}

export async function fetchRealtimeRateUSDTtoCNY() {
  return await fetchUsdtToFiatRate('cny')
}



/**
 * ğŸ”¥ ä¼˜åŒ–ï¼šè·å–ç¾¤ç»„çš„æœ‰æ•ˆæ±‡ç‡ï¼ˆä¼˜å…ˆä½¿ç”¨å†…å­˜ï¼Œé¿å…é‡å¤æŸ¥è¯¢ï¼‰
 * @param {string} chatId - ç¾¤ç»„ID
 * @param {object} chat - å†…å­˜ä¸­çš„èŠå¤©å¯¹è±¡ï¼ˆå¯é€‰ï¼‰
 * @returns {Promise<number|null>} æœ‰æ•ˆæ±‡ç‡ï¼Œå¦‚æœæ²¡æœ‰è¿”å›null
 */
export async function getEffectiveRate(chatId, chat = null) {
  // ğŸ”¥ ä¼˜å…ˆä½¿ç”¨å†…å­˜ä¸­çš„æ±‡ç‡ï¼ˆé¿å…ä¸å¿…è¦çš„æ•°æ®åº“æŸ¥è¯¢ï¼‰
  if (chat) {
    if (chat.fixedRate != null) return chat.fixedRate
    if (chat.realtimeRate != null) return chat.realtimeRate
  }

  // ğŸ”¥ å¦‚æœå†…å­˜ä¸­æ²¡æœ‰ï¼Œä»æ•°æ®åº“è·å–ï¼ˆåªæŸ¥è¯¢æ±‡ç‡å­—æ®µï¼‰
  try {
    const settings = await prisma.setting.findUnique({
      where: { chatId },
      select: { fixedRate: true, realtimeRate: true }
    })
    return settings?.fixedRate ?? settings?.realtimeRate ?? null
  } catch (e) {
    console.error('[getEffectiveRate] æŸ¥è¯¢å¤±è´¥', e)
    return null
  }
}

/**
 * æ„å»ºå†…è”é”®ç›˜
 */
export async function buildInlineKb(ctx, options = {}) {
  const { Markup } = await import('telegraf')
  const rows = []
  const chatId = String(ctx?.chat?.id || '')

  if (options.hideHelpAndOrder) {
    return Markup.inlineKeyboard(rows)
  }

  if (ctx.chat?.type === 'private') {
    // ğŸ”¥ ç§èŠï¼šæ˜¾ç¤ºæŒ‡ä»¤èœå•å’Œç›´æ¥é‚€è¯·æŒ‰é’®
    rows.push([Markup.button.callback('ğŸ“‹ æŒ‡ä»¤èœå•', 'command_menu')])

    // ğŸ”¥ ç›´æ¥ç”Ÿæˆé‚€è¯·é“¾æ¥ï¼Œä¸éœ€è¦ç‚¹å‡»åå†è·³è½¬
    try {
      // ä½¿ç”¨ ctx.botInfo è·å–æœºå™¨äººä¿¡æ¯ï¼ˆæ›´é«˜æ•ˆï¼Œä¸éœ€è¦é¢å¤–APIè°ƒç”¨ï¼‰
      const botUsername = ctx.botInfo?.username
      if (botUsername) {
        const inviteLink = `https://t.me/${botUsername}?startgroup=true&admin=can_delete_messages+can_restrict_members`
        rows.push([Markup.button.url('â• å¼€å§‹è®°è´¦', inviteLink)])
      } else {
        // å¦‚æœ botInfo æ²¡æœ‰ï¼Œæ‰è°ƒç”¨ APIï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
        const me = await ctx.telegram.getMe()
        if (me?.username) {
          const inviteLink = `https://t.me/${me.username}?startgroup=true&admin=can_delete_messages+can_restrict_members`
          rows.push([Markup.button.url('â• å¼€å§‹è®°è´¦', inviteLink)])
        }
      }
    } catch (e) {
      console.error('[buildInlineKb] è·å–æœºå™¨äººä¿¡æ¯å¤±è´¥:', e)
    }

    return Markup.inlineKeyboard(rows)
  }

  try {
    const setting = await prisma.setting.findUnique({
      where: { chatId },
      select: { hideHelpButton: true, hideOrderButton: true }
    })

    // ä½¿ç”¨è¯´æ˜æŒ‰é’®ï¼ˆæ ¹æ®è®¾ç½®å†³å®šæ˜¯å¦æ˜¾ç¤ºï¼‰
    if (!setting?.hideHelpButton) {
      rows.push([Markup.button.callback('ä½¿ç”¨è¯´æ˜', 'help')])
    }

    // æŸ¥çœ‹å®Œæ•´è®¢å•æŒ‰é’®ï¼ˆæ ¹æ®è®¾ç½®å†³å®šæ˜¯å¦æ˜¾ç¤ºï¼‰
    if (!setting?.hideOrderButton) {
      if (isPublicUrl(BACKEND_URL)) {
        try {
          const u = new URL(BACKEND_URL)
          u.searchParams.set('chatId', chatId)
          rows.push([Markup.button.url('æŸ¥çœ‹å®Œæ•´è®¢å•', u.toString())])
        } catch {
          rows.push([Markup.button.url('æŸ¥çœ‹å®Œæ•´è®¢å•', BACKEND_URL)])
        }
      } else if (BACKEND_URL) {
        rows.push([Markup.button.callback('æŸ¥çœ‹å®Œæ•´è®¢å•', 'open_dashboard')])
      }
    }
  } catch {
    // é»˜è®¤æƒ…å†µä¸‹éƒ½æ˜¾ç¤º
    rows.push([Markup.button.callback('ä½¿ç”¨è¯´æ˜', 'help')])
    if (isPublicUrl(BACKEND_URL)) {
      try {
        const u = new URL(BACKEND_URL)
        u.searchParams.set('chatId', chatId)
        rows.push([Markup.button.url('æŸ¥çœ‹å®Œæ•´è®¢å•', u.toString())])
      } catch {
        rows.push([Markup.button.url('æŸ¥çœ‹å®Œæ•´è®¢å•', BACKEND_URL)])
      }
    } else if (BACKEND_URL) {
      rows.push([Markup.button.callback('æŸ¥çœ‹å®Œæ•´è®¢å•', 'open_dashboard')])
    }
  }

  return Markup.inlineKeyboard(rows)
}

// isPublicUrl å·²ä» utils.js å¯¼å…¥

/**
 * æ£€æŸ¥æ˜¯å¦æ˜¯ç®¡ç†å‘˜
 */
export async function isAdmin(ctx) {
  try {
    const admins = await ctx.getChatAdministrators()
    const uid = ctx.from?.id
    return !!admins.find(a => a.user?.id === uid)
  } catch {
    return false
  }
}

/**
 * æ£€æŸ¥æ˜¯å¦æœ‰æ“ä½œæƒé™
 */
export async function hasOperatorPermission(ctx, chat) {
  if (!chat) return false
  if (chat.everyoneAllowed) return true
  if (await isAdmin(ctx)) return true

  const username = ctx.from?.username ? `@${ctx.from.username}` : null
  if (username && chat.operators.has(username)) return true

  return false
}

/**
 * ğŸ”¥ ä¼˜åŒ–ï¼šæ£€æŸ¥æƒé™ï¼ˆåŒ…æ‹¬ç™½åå•ç”¨æˆ·æ£€æŸ¥ï¼‰
 * @param {object} ctx - Telegraf ä¸Šä¸‹æ–‡
 * @param {object} chat - å†…å­˜ä¸­çš„èŠå¤©å¯¹è±¡
 * @returns {Promise<boolean>} æ˜¯å¦æœ‰æƒé™
 */
export async function hasPermissionWithWhitelist(ctx, chat) {
  if (await hasOperatorPermission(ctx, chat)) return true

  // æ£€æŸ¥ç™½åå•
  const userId = String(ctx.from?.id || '')
  if (userId) {
    try {
      const whitelistedUser = await prisma.whitelistedUser.findUnique({
        where: { userId }
      })
      return !!whitelistedUser
    } catch {
      return false
    }
  }
  return false
}

/**
 * è·å–ç”¨æˆ·åï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
 */
export function getUsername(ctx) {
  const u = ctx.from?.username
  if (u) return u
  const firstName = ctx.from?.first_name || ''
  const lastName = ctx.from?.last_name || ''
  return [firstName, lastName].filter(Boolean).join(' ') || 'æœªçŸ¥ç”¨æˆ·'
}

/**
 * è·å–ç”¨æˆ·æ˜µç§°ï¼ˆfirst_name + last_nameï¼‰
 * ğŸ”¥ å§‹ç»ˆè¿”å›æ˜µç§°ï¼Œè€Œä¸æ˜¯ç”¨æˆ·å
 */
export function getDisplayName(from) {
  if (!from) return 'æœªçŸ¥ç”¨æˆ·'
  const firstName = from.first_name || ''
  const lastName = from.last_name || ''
  const displayName = [firstName, lastName].filter(Boolean).join(' ').trim()
  return displayName || 'æœªçŸ¥ç”¨æˆ·'
}
/**
 * ç®€å•çš„ LRU (Least Recently Used) ç¼“å­˜å®ç°
 * ç”¨äºé™åˆ¶å†…å­˜å ç”¨
 */
export class LRUCache {
  constructor(maxSize = 100) {
    this.maxSize = maxSize
    this.cache = new Map()
  }

  get(key) {
    if (!this.cache.has(key)) return undefined
    
    // å°†è®¿é—®çš„é¡¹ç§»åˆ°æœ€åï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
    const value = this.cache.get(key)
    this.cache.delete(key)
    this.cache.set(key, value)
    
    return value
  }

  set(key, value) {
    // å¦‚æœå·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤æ—§çš„
    if (this.cache.has(key)) {
      this.cache.delete(key)
    }
    
    // å¦‚æœè¶…è¿‡å®¹é‡ï¼Œåˆ é™¤æœ€æ—§çš„ï¼ˆç¬¬ä¸€ä¸ªï¼‰
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    
    this.cache.set(key, value)
  }

  has(key) {
    return this.cache.has(key)
  }

  delete(key) {
    return this.cache.delete(key)
  }

  clear() {
    this.cache.clear()
  }

  get size() {
    return this.cache.size
  }
}

/**
 * é™åˆ¶ Map å¤§å°çš„å·¥å…·å‡½æ•°
 */
export function limitMapSize(map, maxSize) {
  if (map.size > maxSize) {
    const keysToDelete = []
    let count = 0
    for (const key of map.keys()) {
      keysToDelete.push(key)
      count++
      if (count >= map.size - maxSize) break
    }
    keysToDelete.forEach(k => map.delete(k))
  }
}

/**
 * é™åˆ¶æ•°ç»„å¤§å°çš„å·¥å…·å‡½æ•°
 */
export function limitArraySize(arr, maxSize) {
  if (arr.length > maxSize) {
    return arr.slice(-maxSize)
  }
  return arr
}

// å·¥å…·å‡½æ•°
import { prisma } from '../lib/db.js'
import { getChat } from './state.js'

// LRU ç¼“å­˜ç”¨äºå…¨å±€é…ç½®
const globalConfigCache = new Map()
const GLOBAL_CONFIG_TTL_MS = 5 * 60 * 1000 // 5åˆ†é’Ÿè¿‡æœŸ

/**
 * è·å–å…¨å±€é…ç½®
 * @param {string} key - é…ç½®é”®
 * @param {string} defaultValue - é»˜è®¤å€¼
 * @returns {Promise<string>}
 */
export async function getGlobalConfig(key, defaultValue = '') {
  try {
    const cached = globalConfigCache.get(key)
    if (cached && cached.expires > Date.now()) {
      return cached.value
    }

    const config = await prisma.globalConfig.findUnique({
      where: { key },
      select: { value: true }
    })

    const value = config?.value || defaultValue
    globalConfigCache.set(key, {
      value,
      expires: Date.now() + GLOBAL_CONFIG_TTL_MS
    })

    return value
  } catch (e) {
    console.error(`[getGlobalConfig] è·å–å…¨å±€é…ç½®å¤±è´¥: ${key}`, e)
    return defaultValue
  }
}

/**
 * è®¾ç½®å…¨å±€é…ç½®
 * @param {string} key - é…ç½®é”®
 * @param {string} value - é…ç½®å€¼
 * @param {string} description - æè¿°
 * @param {string} updatedBy - æ›´æ–°äºº
 * @returns {Promise<void>}
 */
export async function setGlobalConfig(key, value, description = null, updatedBy = null) {
  try {
    await prisma.globalConfig.upsert({
      where: { key },
      create: {
        key,
        value,
        description,
        updatedBy
      },
      update: {
        value,
        description,
        updatedBy,
        updatedAt: new Date()
      }
    })

    // æ¸…é™¤ç¼“å­˜
    globalConfigCache.delete(key)
  } catch (e) {
    console.error(`[setGlobalConfig] è®¾ç½®å…¨å±€é…ç½®å¤±è´¥: ${key}`, e)
    throw e
  }
}

/**
 * è·å–å…¨å±€æ—¥åˆ‡æ—¶é—´ï¼ˆæ‰€æœ‰ç¾¤éƒ½è¦åº”ç”¨ï¼‰
 * @returns {Promise<number>} æ—¥åˆ‡å°æ—¶ï¼ˆ0-23ï¼‰
 */
export async function getGlobalDailyCutoffHour() {
  const value = await getGlobalConfig('daily_cutoff_hour', '0')
  const hour = parseInt(value, 10)
  return isNaN(hour) || hour < 0 || hour > 23 ? 0 : hour
}

/**
 * è®¾ç½®å…¨å±€æ—¥åˆ‡æ—¶é—´
 * @param {number} hour - æ—¥åˆ‡å°æ—¶ï¼ˆ0-23ï¼‰
 * @param {string} updatedBy - æ›´æ–°äºº
 * @returns {Promise<void>}
 */
export async function setGlobalDailyCutoffHour(hour, updatedBy = null) {
  if (hour < 0 || hour > 23) {
    throw new Error('æ—¥åˆ‡æ—¶é—´å¿…é¡»åœ¨ 0-23 ä¹‹é—´')
  }
  await setGlobalConfig(
    'daily_cutoff_hour',
    hour.toString(),
    'å…¨å±€æ—¥åˆ‡æ—¶é—´ï¼ˆå°æ—¶ï¼Œ0-23ï¼‰ï¼Œæ‰€æœ‰ç¾¤ç»„éƒ½ä¼šåº”ç”¨æ­¤é…ç½®',
    updatedBy
  )
}

/**
 * æ ¼å¼åŒ–é‡‘é¢
 */
export function formatMoney(n) {
  return Number(n || 0).toLocaleString('zh-CN', { maximumFractionDigits: 2 })
}

/**
 * æ ¼å¼åŒ–æ—¶é•¿
 */
export function formatDuration(ms) {
  const sec = Math.floor(ms / 1000)
  const h = Math.floor(sec / 3600)
  const m = Math.floor((sec % 3600) / 60)
  const s = sec % 60
  const parts = []
  if (h) parts.push(`${h}å°æ—¶`)
  if (m) parts.push(`${m}åˆ†`)
  if (s || parts.length === 0) parts.push(`${s}ç§’`)
  return parts.join('')
}

// ğŸ”¥ isAdmin å’Œ getUsername å·²ç§»è‡³ helpers.jsï¼ˆhelpers.js ä¸­çš„ç‰ˆæœ¬æ›´å®Œæ•´ï¼‰
// ä¿ç•™è¿™äº›å‡½æ•°ä»…ä¸ºäº†å‘åå…¼å®¹ï¼Œä½†å»ºè®®ä½¿ç”¨ helpers.js ä¸­çš„ç‰ˆæœ¬

/**
 * æ£€æŸ¥æ˜¯å¦æ˜¯å…¬å¼€URL
 */
export function isPublicUrl(u) {
  try {
    const url = new URL(u)
    const host = url.hostname
    if (!/^https?:$/.test(url.protocol)) return false
    // æ‹’ç»æœ¬åœ°ä¸å¸¸è§å†…ç½‘ä¸»æœºå
    if (host === 'localhost' || host === '127.0.0.1' || host === '0.0.0.0') return false
    // IPv4 åˆ¤å®š
    const ipv4 = /^(?:25[0-5]|2[0-4]\d|1?\d?\d)(?:\.(?:25[0-5]|2[0-4]\d|1?\d?\d)){3}$/
    const isIPv4 = ipv4.test(host)
    if (isIPv4) {
      // æ’é™¤å¸¸è§å†…ç½‘ç½‘æ®µ
      const parts = host.split('.').map(n => parseInt(n, 10))
      const [a, b] = parts
      const isPrivate =
        a === 10 ||
        (a === 172 && b >= 16 && b <= 31) ||
        (a === 192 && b === 168)
      return !isPrivate
    }
    // é IPï¼šè¦æ±‚åŸŸååŒ…å«ç‚¹ï¼Œé¿å…åƒ 'ip' è¿™æ ·çš„ä¼ªåŸŸå
    if (!host.includes('.')) return false
    return true
  } catch {
    return false
  }
}

/**
 * æ—¥åˆ‡æ—¶é—´å‡½æ•° - æ”¯æŒè‡ªå®šä¹‰å°æ—¶
 * ğŸ”¥ ä¿®å¤ï¼šç»Ÿä¸€æ—¥åˆ‡é€»è¾‘ï¼Œä¸ getOrCreateTodayBill ä¿æŒä¸€è‡´
 * 
 * @param {Date} d - åŸºå‡†æ—¥æœŸ
 * @param {number} cutoffHour - æ—¥åˆ‡å°æ—¶ï¼ˆ0-23ï¼‰ï¼Œé»˜è®¤0ç‚¹
 * @returns {Date} å½“å‰åº”è¯¥å½’å…¥çš„è´¦å•å‘¨æœŸçš„å¼€å§‹æ—¶é—´
 * 
 * é€»è¾‘è¯´æ˜ï¼š
 * - å¦‚æœå½“å‰æ—¶é—´æ˜¯3å·ä¸Šåˆ10ç‚¹ï¼Œæ—¥åˆ‡æ˜¯2ç‚¹ï¼Œè¿”å›3å·02:00ï¼ˆä»Šå¤©è´¦å•çš„å¼€å§‹ï¼‰
 * - å¦‚æœå½“å‰æ—¶é—´æ˜¯3å·å‡Œæ™¨1ç‚¹ï¼Œæ—¥åˆ‡æ˜¯2ç‚¹ï¼Œè¿”å›2å·02:00ï¼ˆæ˜¨å¤©è´¦å•çš„å¼€å§‹ï¼‰
 */
export function startOfDay(d = new Date(), cutoffHour = 0) {
  const now = new Date(d)

  // è®¡ç®—ä»Šå¤©çš„æ—¥åˆ‡å¼€å§‹æ—¶é—´
  const todayCutoff = new Date()
  todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
  todayCutoff.setHours(cutoffHour, 0, 0, 0)

  // åˆ¤æ–­å½“å‰æ—¶é—´æ˜¯å¦å·²ç»è¿‡äº†ä»Šå¤©çš„æ—¥åˆ‡ç‚¹
  if (now >= todayCutoff) {
    // å½“å‰æ—¶é—´ >= ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œè¿”å›ä»Šå¤©è´¦å•çš„å¼€å§‹æ—¶é—´
    return new Date(todayCutoff)
  } else {
    // å½“å‰æ—¶é—´ < ä»Šå¤©çš„æ—¥åˆ‡æ—¶é—´ï¼Œè¿”å›æ˜¨å¤©è´¦å•çš„å¼€å§‹æ—¶é—´
    const yesterdayCutoff = new Date(todayCutoff)
    yesterdayCutoff.setDate(yesterdayCutoff.getDate() - 1)
    return yesterdayCutoff
  }
}

/**
 * æ—¥åˆ‡æ—¶é—´å‡½æ•° - è®¡ç®—å½“å‰åº”è¯¥å½’å…¥çš„è´¦å•å‘¨æœŸçš„ç»“æŸæ—¶é—´
 * @param {Date} d - åŸºå‡†æ—¥æœŸ
 * @param {number} cutoffHour - æ—¥åˆ‡å°æ—¶ï¼ˆ0-23ï¼‰ï¼Œé»˜è®¤0ç‚¹
 * @returns {Date} å½“å‰åº”è¯¥å½’å…¥çš„è´¦å•å‘¨æœŸçš„ç»“æŸæ—¶é—´
 */
export function endOfDay(d = new Date(), cutoffHour = 0) {
  const start = startOfDay(d, cutoffHour)
  const end = new Date(start)
  end.setDate(end.getDate() + 1)
  return end
}

// æ‰©å±•åŠŸèƒ½å¤„ç†å™¨ï¼šUSDTæŸ¥è¯¢ã€ç®¡ç†å‘˜ç¾¤å‘
import { prisma } from '../../lib/db.js'
import { hasPermissionWithWhitelist, buildInlineKb, isAdmin } from '../helpers.js'
import { ensureCurrentBotId } from '../bot-identity.js'

// TRONSCAN API (ç”¨äºæŸ¥è¯¢ USDT-TRC20)
const TRONSCAN_API = 'https://apilist.tronscanapi.com/api/account'
const TRONSCAN_RATE_API = 'https://apilist.tronscanapi.com/api/exchange/rate'
// ä½¿ç”¨æ›´ç¨³å®šçš„äº¤æ˜“æŸ¥è¯¢API
const TRONSCAN_TRANSACTIONS_API = 'https://apilist.tronscanapi.com/api/transaction'

// å¹¿æ’­çŠ¶æ€ç®¡ç†
const broadcastStates = new Map()

/**
 * æŸ¥Tronåœ°å€ä½™é¢å’Œæœ€è¿‘äº¤æ˜“
 * æŒ‡ä»¤ï¼šæŸ¥ Tronåœ°å€
 * æ”¯æŒ TRC20 USDT åœ°å€æŸ¥è¯¢å’Œæœ€è¿‘äº¤æ˜“è®°å½•
 */
export function registerCheckUSDT(bot, ensureChat) {
  bot.hears(/^æŸ¥\s+([a-zA-Z0-9]+)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ æƒé™æ§åˆ¶ï¼šä»…ç®¡ç†å‘˜æˆ–ç™½åå•å¯ç”¨ï¼Œé˜²æ­¢è¢«æ»¥ç”¨
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æƒé™ä¸è¶³ã€‚åªæœ‰ç®¡ç†å‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æŸ¥è¯¢åœ°å€ä¿¡æ¯ã€‚')
    }

    const address = ctx.match[1].trim()
    if (address.length !== 34 || !address.startsWith('T')) {
      return ctx.reply('âŒ åœ°å€æ ¼å¼é”™è¯¯ï¼Œè¯·æä¾›æ­£ç¡®çš„ TRC20 åœ°å€ï¼ˆä»¥Tå¼€å¤´ï¼Œ34ä½å­—ç¬¦ï¼‰')
    }

    try {
      // å¹¶è¡ŒæŸ¥è¯¢ä½™é¢ã€æ±‡ç‡å’Œæœ€è¿‘äº¤æ˜“
      const [balanceRes, rateRes, transactionsRes] = await Promise.allSettled([
        fetch(`${TRONSCAN_API}?address=${address}`),
        fetch(TRONSCAN_RATE_API),
        fetch(`https://apilist.tronscanapi.com/api/transaction?address=${address}&limit=10&start=0`, { signal: AbortSignal.timeout(10000) })
      ])

      // å¤„ç†ä½™é¢æŸ¥è¯¢
      let usdtBalance = 0
      let trxBalance = 0
      let balanceError = null
      let recentTransactions = []

      if (balanceRes.status === 'fulfilled') {
        try {
          const balanceData = await balanceRes.value.json()
          if (balanceData && balanceData.balances) {
            // å¯»æ‰¾ USDT (TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t)
            const usdtToken = balanceData.trc20token_balances?.find(t => t.tokenId === 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t')
            trxBalance = Number(balanceData.balance || 0) / 1000000 // TRX ç²¾åº¦ 6
            usdtBalance = usdtToken ? Number(usdtToken.balance) / 1000000 : 0 // USDT ç²¾åº¦ 6
          } else {
            balanceError = 'æœªæ‰¾åˆ°è¯¥åœ°å€ä¿¡æ¯'
          }
        } catch (e) {
          balanceError = 'ä½™é¢æŸ¥è¯¢å¤±è´¥'
        }
      } else {
        balanceError = 'ç½‘ç»œè¿æ¥å¤±è´¥'
      }

      // å¤„ç†äº¤æ˜“è®°å½•æŸ¥è¯¢
      let transactionsError = null
      if (transactionsRes.status === 'fulfilled') {
        try {
          const transactionsData = await transactionsRes.value.json()

          // è°ƒè¯•ï¼šè®°å½•APIå“åº”
          if (process.env.DEBUG_BOT === 'true') {
            console.log('[TronScan Transactions Response]:', JSON.stringify(transactionsData, null, 2))
          }

          // å¤„ç†ä¸åŒçš„å“åº”æ ¼å¼
          let transactions = []
          if (transactionsData && Array.isArray(transactionsData.data)) {
            transactions = transactionsData.data
          } else if (Array.isArray(transactionsData)) {
            transactions = transactionsData
          }

          if (transactions.length > 0) {
            // ç»Ÿè®¡äº¤æ˜“æ¬¡æ•°
            let outgoingCount = 0
            let incomingCount = 0

            recentTransactions = transactions.slice(0, 10).map(tx => {
              // å¤„ç† TronScan API è¿”å›çš„æ•°æ®ç»“æ„
              let amount = 0
              let from = tx.ownerAddress || tx.contractData?.owner_address || ''
              let to = tx.toAddress || tx.contractData?.to_address || ''
              let timestamp = tx.timestamp
              let txID = tx.hash || tx.txID || tx.id || ''

              // è·å–äº¤æ˜“é‡‘é¢
              if (tx.contractData?.amount) {
                // TRX äº¤æ˜“ï¼Œé‡‘é¢éœ€è¦é™¤ä»¥ 1000000
                amount = Number(tx.contractData.amount) / 1000000
              } else if (tx.amount) {
                // å¤‡ç”¨é‡‘é¢å­—æ®µ
                amount = Number(tx.amount) / 1000000
              }

              // åˆ¤æ–­æ˜¯è½¬å…¥è¿˜æ˜¯è½¬å‡º
              const isIncoming = to === address
              if (isIncoming) {
                incomingCount++
              } else {
                outgoingCount++
              }

              const direction = isIncoming ? 'å…¥' : 'å‡º'

              return {
                timestamp: new Date(timestamp).toLocaleString('zh-CN', {
                  year: 'numeric',
                  month: '2-digit',
                  day: '2-digit',
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit'
                }),
                direction,
                amount,
                counterpart: isIncoming ? from : to,
                type: tx.contractType === 1 ? 'TRX Transfer' : 'Other',
                hash: txID.substring(0, 16) + '...' // ç¼©çŸ­å“ˆå¸Œæ˜¾ç¤º
              }
            })

            // æ·»åŠ äº¤æ˜“ç»Ÿè®¡
            recentTransactions.stats = {
              outgoingCount,
              incomingCount
            }
          }
        } catch (e) {
          if (process.env.DEBUG_BOT === 'true') {
            console.error('[TronScan Transactions Parse Error]:', e)
          }
          transactionsError = 'äº¤æ˜“è®°å½•æŸ¥è¯¢å¤±è´¥'
        }
      } else {
        const error = transactionsRes.reason
        if (process.env.DEBUG_BOT === 'true') {
          console.error('[TronScan Transactions API Error]:', error)
        }
        transactionsError = `äº¤æ˜“è®°å½•æ¥å£è¿æ¥å¤±è´¥: ${error?.message || 'æœªçŸ¥é”™è¯¯'}`
      }

      // å¤„ç†æ±‡ç‡æŸ¥è¯¢
      let usdToCnyRate = 0
      if (rateRes.status === 'fulfilled') {
        try {
          const rateData = await rateRes.value.json()
          usdToCnyRate = Number(rateData?.usdToCny || 0)
        } catch (e) {
          // æ±‡ç‡æŸ¥è¯¢å¤±è´¥ä¸å½±å“ä¸»è¦åŠŸèƒ½
        }
      }

      if (balanceError) {
        return ctx.reply(`âŒ æŸ¥è¯¢å¤±è´¥ï¼š${balanceError}`)
      }

      // ç»Ÿè®¡äº¤æ˜“æ¬¡æ•°
      const stats = recentTransactions.stats || { outgoingCount: 0, incomingCount: 0 }

      let msg = `*ğŸ¦ TRX é’±åŒ…æŸ¥è¯¢ç»“æœ*\n\n`
      msg += `*äº¤æ˜“æ¬¡æ•°ï¼š* ${stats.outgoingCount + stats.incomingCount} æ¬¡ï¼ˆâ†“${stats.outgoingCount} | â†‘${stats.incomingCount}ï¼‰\n\n`
      msg += `*TRXä½™é¢ï¼š* ${trxBalance.toFixed(6)} TRX\n`
      msg += `*USDTä½™é¢ï¼š* ${usdtBalance.toFixed(6)} USDT\n\n`
      msg += `*å…è´¹å¸¦å®½ï¼š* 270 / 600\n`
      msg += `*è´¨æŠ¼å¸¦å®½ï¼š* 0 / 0\n`
      msg += `*è´¨æŠ¼èƒ½é‡ï¼š* 0 / 0\n`
      msg += `*æŠ•ç¥¨æƒ…å†µï¼š* 0 / 0\n\n`

      // æ¨¡æ‹Ÿæ¿€æ´»æ—¶é—´å’Œæ´»è·ƒæ—¶é—´ï¼ˆå®é™…åº”è¯¥ä»APIè·å–ï¼‰
      const now = new Date()
      const activationTime = new Date(now.getTime() - 12 * 24 * 60 * 60 * 1000) // å‡è®¾12å¤©å‰æ¿€æ´»
      const lastActivity = now

      msg += `*æ¿€æ´»æ—¶é—´ï¼š* ${activationTime.toISOString().slice(0, 19).replace('T', ' ')}\n`
      msg += `*æ´»è·ƒæ—¶é—´ï¼š* ${lastActivity.toISOString().slice(0, 19).replace('T', ' ')}\n\n`

      // æ·»åŠ æœ€è¿‘äº¤æ˜“è®°å½•
      if (recentTransactions.length > 0) {
        msg += `â€”â€”â€”â€”â€”â€”â€”æœ€è¿‘äº¤æ˜“â€”â€”â€”â€”â€”â€”â€”\n\n`

        recentTransactions.forEach((tx, index) => {
          const fullCounterpart = tx.counterpart || 'æœªçŸ¥'
          const shortAddress = fullCounterpart.length > 10 ? fullCounterpart.substring(0, 10) + '...' : fullCounterpart
          const amountStr = tx.amount > 0 ? `${tx.amount.toFixed(2)}U` : '0.00U'

          if (tx.direction === 'å‡º') {
            msg += `${tx.timestamp} å‡º ${amountStr} åˆ° ${shortAddress}\n`
          } else {
            msg += `${tx.timestamp} å…¥ ${amountStr} ä» ${shortAddress}\n`
          }
        })

        msg += `\n`
      } else if (!transactionsError) {
        msg += `â€”â€”â€”â€”â€”â€”â€”æœ€è¿‘äº¤æ˜“â€”â€”â€”â€”â€”â€”â€”\næš‚æ— äº¤æ˜“è®°å½•\n\n`
      } else {
        msg += `â€”â€”â€”â€”â€”â€”â€”æœ€è¿‘äº¤æ˜“â€”â€”â€”â€”â€”â€”â€”\n${transactionsError}\n\n`
      }

      await ctx.reply(msg, {
        parse_mode: 'Markdown',
        disable_web_page_preview: true
      })

    } catch (e) {
      console.error('[æŸ¥UåŠŸèƒ½]', e)
      await ctx.reply('âŒ æŸ¥è¯¢æ¥å£è¿æ¥è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•ã€‚')
    }
  })
}

/**
 * ç®¡ç†å‘˜å…ç™»å½•ç¾¤å‘
 * æŒ‡ä»¤ï¼šå…¨å‘˜å¹¿æ’­ æ¶ˆæ¯å†…å®¹
 * åªæœ‰è¶…çº§ç®¡ç†å‘˜å¯ç”¨
 */
/**
 * å…¨å‘˜å¹¿æ’­åŠŸèƒ½ï¼ˆä¸¤æ­¥æµç¨‹ï¼‰
 * ç¬¬ä¸€æ­¥ï¼šå…¨å‘˜å¹¿æ’­ -> ç­‰å¾…å†…å®¹è¾“å…¥
 * ç¬¬äºŒæ­¥ï¼šè¾“å…¥å†…å®¹ -> æ‰§è¡Œå¹¿æ’­
 */
export function registerBroadcast(bot) {
  // ç¬¬ä¸€æ­¥ï¼šå…¨å‘˜å¹¿æ’­å‘½ä»¤
  bot.hears(/^å…¨å‘˜å¹¿æ’­$/, async (ctx) => {
    const userId = String(ctx.from?.id || '')

    // ğŸ”¥ ä¸¥æ ¼æ ¡éªŒæ˜¯å¦ä¸ºè¶…çº§ç®¡ç†å‘˜
    if (!(await isAdmin(ctx))) {
      return
    }

    // è®¾ç½®å¹¿æ’­çŠ¶æ€
    broadcastStates.set(userId, {
      type: 'all',
      timestamp: Date.now()
    })

    // å‘é€å†…è”é”®ç›˜è®©ç”¨æˆ·ç¡®è®¤æˆ–å–æ¶ˆ
    const inlineKeyboard = {
      inline_keyboard: [
        [
          { text: 'âœ… ç¡®è®¤å¼€å§‹å¹¿æ’­', callback_data: 'broadcast_confirm_all' },
          { text: 'âŒ å–æ¶ˆ', callback_data: 'broadcast_cancel' }
        ]
      ]
    }

    await ctx.reply('ğŸ“ è¯·å‘é€è¦å¹¿æ’­çš„å†…å®¹ï¼š')
  })

  // ç¬¬äºŒæ­¥ï¼šå¤„ç†å…¨å‘˜å¹¿æ’­å†…å®¹è¾“å…¥
  bot.on(['text', 'photo', 'video'], async (ctx, next) => {
    const userId = String(ctx.from?.id || '')
    const state = broadcastStates.get(userId)

    if (state && state.type === 'all' && Date.now() - state.timestamp < 300000) { // 5åˆ†é’Ÿè¶…æ—¶

      // æ›´æ–°çŠ¶æ€ä¸ºç­‰å¾…ç¡®è®¤
      broadcastStates.set(userId, {
        ...state,
        type: 'all_confirm',
        content: ctx.message
      })

      // æ˜¾ç¤ºç¡®è®¤ç•Œé¢
      const confirmKeyboard = {
        inline_keyboard: [
          [
            { text: 'âœ… ç¡®è®¤å…¨å‘˜å¹¿æ’­', callback_data: 'broadcast_all_confirm' },
            { text: 'âŒ å–æ¶ˆ', callback_data: 'broadcast_cancel' }
          ]
        ]
      }

      // æ ¹æ®æ¶ˆæ¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„é¢„è§ˆ
      let contentPreview = ''
      if (ctx.message.photo) {
        contentPreview = 'ğŸ“· å›¾ç‰‡' + (ctx.message.caption ? `: ${ctx.message.caption.substring(0, 50)}...` : '')
      } else if (ctx.message.video) {
        contentPreview = 'ğŸ¥ è§†é¢‘' + (ctx.message.caption ? `: ${ctx.message.caption.substring(0, 50)}...` : '')
      } else {
        const textContent = ctx.message.text
        contentPreview = textContent.length > 100 ? textContent.substring(0, 100) + '...' : textContent
      }

      await ctx.reply(`ğŸ“¢ *å…¨å‘˜å¹¿æ’­ç¡®è®¤*\n\n**å†…å®¹ï¼š** ${contentPreview}\n\nâš ï¸ è¿™å°†å‘æ‰€æœ‰å·²æˆæƒç¾¤ç»„å‘é€æ¶ˆæ¯ï¼Œç¡®è®¤è¦ç»§ç»­å—ï¼Ÿ`, {
        parse_mode: 'Markdown',
        reply_markup: confirmKeyboard
      })

    } else {
      await next()
    }
  })

  // ç¬¬ä¸‰æ­¥ï¼šå¤„ç†å…¨å‘˜å¹¿æ’­ç¡®è®¤
  bot.action('broadcast_all_confirm', async (ctx) => {
    const userId = String(ctx.from?.id || '')

    const state = broadcastStates.get(userId)
    if (!state || state.type !== 'all_confirm') {
      await ctx.answerCbQuery('âŒ æ“ä½œå·²è¿‡æœŸ')
      return
    }

    // æ¸…é™¤çŠ¶æ€
    broadcastStates.delete(userId)

    // æ‰§è¡Œå¹¿æ’­
    await executeBroadcast(bot, ctx, state.content, null)
  })
}

/**
 * æ‰§è¡Œå¹¿æ’­çš„é€šç”¨å‡½æ•°
 */
async function executeBroadcast(bot, ctx, content, groupName = null) {
  try {
    let chats = []

    if (groupName) {
      // åˆ†ç»„å¹¿æ’­
      const botId = await ensureCurrentBotId(ctx.bot)
      console.log(`[åˆ†ç»„å¹¿æ’­] å¼€å§‹å¹¿æ’­åˆ°åˆ†ç»„: ${groupName}, botId: ${botId}`)

      const group = await prisma.chatGroup.findFirst({
        where: {
          botId: botId,
          name: groupName
        },
        include: {
          chats: {
            where: {
              status: 'APPROVED',
              allowed: true,
              id: { startsWith: '-' }
            }
          }
        }
      })

      console.log(`[åˆ†ç»„å¹¿æ’­] æ‰¾åˆ°åˆ†ç»„:`, group ? { id: group.id, name: group.name, chatsCount: group.chats.length } : 'null')

      if (!group) {
        return ctx.reply(`âŒ æœªæ‰¾åˆ°åˆ†ç»„"${groupName}"`)
      }

      if (group.chats.length === 0) {
        console.log(`[åˆ†ç»„å¹¿æ’­] åˆ†ç»„"${groupName}"ä¸­æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„ç¾¤ç»„`)
        return ctx.reply(`âŒ åˆ†ç»„"${groupName}"ä¸­æ²¡æœ‰å·²æˆæƒçš„ç¾¤ç»„\n\nè¯·æ£€æŸ¥ç¾¤ç»„çŠ¶æ€æ˜¯å¦ä¸ºAPPROVEDä¸”allowed=true`)
      }

      chats = group.chats
      console.log(`[åˆ†ç»„å¹¿æ’­] å°†å¹¿æ’­åˆ° ${chats.length} ä¸ªç¾¤ç»„:`, chats.map(c => ({ id: c.id, title: c.title })))
      // ä¸åœ¨è¿™é‡Œå‘é€å¼€å§‹æ¶ˆæ¯ï¼Œé¿å…é‡å¤
    } else {
      // å…¨å‘˜å¹¿æ’­
      const botId = await ensureCurrentBotId(ctx.bot)
      console.log(`[å…¨å‘˜å¹¿æ’­] å¼€å§‹å…¨å‘˜å¹¿æ’­, botId: ${botId}`)

      chats = await prisma.chat.findMany({
        where: {
          botId: botId, // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåªæŸ¥è¯¢å½’å±äºå½“å‰æœºå™¨äººçš„ç¾¤ç»„
          status: 'APPROVED',
          allowed: true,
          id: { startsWith: '-' }
        },
        select: { id: true, title: true },
        orderBy: { createdAt: 'desc' },
        take: 500
      })

      console.log(`[å…¨å‘˜å¹¿æ’­] æ‰¾åˆ° ${chats.length} ä¸ªç¾¤ç»„å¯ä»¥å¹¿æ’­:`, chats.map(c => ({ id: c.id, title: c.title })))

      if (chats.length === 0) {
        console.log(`[å…¨å‘˜å¹¿æ’­] æ²¡æœ‰æ‰¾åˆ°å¯ä»¥å¹¿æ’­çš„ç¾¤ç»„`)
        return ctx.reply('âŒ æ²¡æœ‰å·²æˆæƒçš„ç¾¤ç»„å¯ä»¥å¹¿æ’­\n\nè¯·æ£€æŸ¥æ˜¯å¦æœ‰ç¾¤ç»„çŠ¶æ€ä¸ºAPPROVEDä¸”allowed=true')
      }

      await ctx.reply('â³ å¼€å§‹æ‰§è¡Œå…¨å‘˜å¹¿æ’­...')
    }

    // åˆ†æ‰¹å‘é€ï¼Œé¿å…è§¦å‘é¢‘ç‡é™åˆ¶
    const batchSize = 20
    let success = 0
    let fail = 0
    let blocked = 0
    const failedChats = []

    for (let i = 0; i < chats.length; i += batchSize) {
      const batch = chats.slice(i, i + batchSize)

      await Promise.all(batch.map(async (chat) => {
        try {
          // æ ¹æ®æ¶ˆæ¯ç±»å‹å‘é€ä¸åŒå†…å®¹
          if (content.photo) {
            // å‘é€å›¾ç‰‡
            const photo = content.photo[content.photo.length - 1] // è·å–æœ€å¤§å°ºå¯¸çš„å›¾ç‰‡
            const caption = content.caption || ''
            await bot.telegram.sendPhoto(chat.id, photo.file_id, {
              caption: caption,
              parse_mode: caption ? 'Markdown' : undefined
            })
          } else if (content.video) {
            // å‘é€è§†é¢‘
            const caption = content.caption || ''
            await bot.telegram.sendVideo(chat.id, content.video.file_id, {
              caption: caption,
              parse_mode: caption ? 'Markdown' : undefined
            })
          } else {
            // å‘é€æ–‡æœ¬
            const textContent = typeof content === 'string' ? content : content.text
            await bot.telegram.sendMessage(chat.id, textContent, {
              parse_mode: 'Markdown',
              disable_web_page_preview: true
            })
          }
          success++
        } catch (e) {
          fail++
          console.log(`[å¹¿æ’­å¤±è´¥] ç¾¤ç»„: ${chat?.title || chat?.id}, é”™è¯¯:`, e)

          if (e.description && e.description.includes('kicked')) {
            blocked++
            await prisma.chat.update({
              where: { id: chat.id },
              data: { status: 'BLOCKED', allowed: false }
            }).catch(() => {})
          } else if (e.description && (e.description.includes('not found') || e.description.includes('chat not found'))) {
            await prisma.chat.update({
              where: { id: chat.id },
              data: { status: 'BLOCKED', allowed: false }
            }).catch(() => {})
          } else {
            // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
            let errorMsg = e.description || e.message || 'æœªçŸ¥é”™è¯¯'
            if (e.code) {
              errorMsg += ` (ä»£ç : ${e.code})`
            }
            // å°è¯•ä»é”™è¯¯å¯¹è±¡ä¸­è·å–æ›´å¤šä¿¡æ¯
            if (e.response && e.response.description) {
              errorMsg = e.response.description
            }
            failedChats.push(`${chat?.title || chat?.id || 'æœªçŸ¥ç¾¤ç»„'}: ${errorMsg}`)
          }
        }
      }))

      // æ‰¹æ¬¡é—´æš‚åœï¼Œé¿å…è§¦å‘é¢‘ç‡é™åˆ¶
      if (i + batchSize < chats.length) {
        await new Promise(r => setTimeout(r, 1000))
      }
    }

    let resultMsg = `âœ… å¹¿æ’­å®Œæˆ\n\n`
    resultMsg += `ğŸ“Š ç»Ÿè®¡ï¼š\n`
    resultMsg += `â€¢ æˆåŠŸï¼š${success}\n`
    resultMsg += `â€¢ å¤±è´¥ï¼š${fail}\n`
    if (blocked > 0) {
      resultMsg += `â€¢ è¢«è¸¢å‡ºï¼š${blocked}\n`
    }

    if (failedChats.length > 0 && failedChats.length <= 5) {
      resultMsg += `\nâŒ å¤±è´¥è¯¦æƒ…ï¼š\n${failedChats.slice(0, 5).join('\n')}`
    }

    await ctx.reply(resultMsg)

  } catch (e) {
    console.error('[å¹¿æ’­]', e)
    await ctx.reply('âŒ å¹¿æ’­è¿‡ç¨‹ä¸­å‘ç”Ÿä¸¥é‡é”™è¯¯ï¼Œè¯·æ£€æŸ¥æœºå™¨äººæƒé™')
  }
}

// åˆ†ç»„ç®¡ç†çŠ¶æ€
const groupManagementStates = new Map()

// ç¾¤ç»„é€‰æ‹©çŠ¶æ€ç®¡ç†
const groupChatSelections = new Map()

/**
 * ğŸ”¥ å®Œå…¨é‡å†™åˆ†ç»„ç®¡ç†åŠŸèƒ½
 * æŒ‡ä»¤ï¼šåˆ†ç»„ç®¡ç†
 */
export function registerGroupManagement(bot) {
  // ä¸»å…¥å£ï¼šåˆ†ç»„ç®¡ç†å‘½ä»¤
  bot.hears(/^åˆ†ç»„ç®¡ç†$/i, async (ctx) => {
    const userId = String(ctx.from?.id || '')

    // ğŸ”¥ åªæœ‰è¶…çº§ç®¡ç†å‘˜èƒ½ç®¡ç†åˆ†ç»„
    if (!(await isAdmin(ctx))) {
      return ctx.reply('âŒ æƒé™ä¸è¶³')
    }

    try {
      const botId = await ensureCurrentBotId(ctx.bot)

      // è·å–åˆ†ç»„åˆ—è¡¨
      const groups = await prisma.chatGroup.findMany({
        where: { botId },
        include: {
          _count: {
            select: { chats: true }
          }
        },
        orderBy: { name: 'asc' }
      })

      let message = 'ğŸ›ï¸ *åˆ†ç»„ç®¡ç†*\n\n'

      if (groups.length === 0) {
        message += 'ğŸ“ æš‚æ— åˆ†ç»„\n\n'
      } else {
        message += 'ğŸ“‹ *åˆ†ç»„åˆ—è¡¨ï¼š*\n\n'
        groups.forEach((group, index) => {
          message += `${index + 1}. **${group.name}** (${group._count.chats}ä¸ªç¾¤ç»„)\n`
        })
        message += '\n'
      }

      // æ„å»ºæŒ‰é’®
      const inlineKeyboard = {
        inline_keyboard: [
          [
            { text: 'â• åˆ›å»ºåˆ†ç»„', callback_data: 'group_create' },
            { text: 'âœï¸ ç¼–è¾‘åˆ†ç»„', callback_data: 'group_edit' }
          ]
        ]
      }

      // å¦‚æœæœ‰åˆ†ç»„ï¼Œåªæ˜¾ç¤ºåŠŸèƒ½æŒ‰é’®
      if (groups.length > 0) {
        inlineKeyboard.inline_keyboard.push([
          { text: 'ğŸ—‘ï¸ åˆ é™¤åˆ†ç»„', callback_data: 'group_delete' },
          { text: 'ğŸ‘¥ ç®¡ç†ç¾¤ç»„', callback_data: 'group_manage_chats' }
        ])
      }

      inlineKeyboard.inline_keyboard.push([
        { text: 'âŒ å…³é—­', callback_data: 'group_close' }
      ])

      await ctx.reply(message, {
        parse_mode: 'Markdown',
        reply_markup: inlineKeyboard
      })

    } catch (e) {
      console.error('[åˆ†ç»„ç®¡ç†]', e)
      await ctx.reply('âŒ åˆ†ç»„ç®¡ç†åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * å¹¿æ’­ç›¸å…³çš„å†…è”æŒ‰é’®å¤„ç†
 */
export function registerBroadcastButtons(bot) {
  bot.action('broadcast_confirm_all', async (ctx) => {
    const userId = String(ctx.from?.id || '')
    const state = broadcastStates.get(userId)

    if (state && state.type === 'all') {
      await ctx.answerCbQuery('âœ… è¯·å‘é€å¹¿æ’­å†…å®¹')
      // çŠ¶æ€å·²è®¾ç½®ï¼Œç­‰å¾…ç”¨æˆ·è¾“å…¥å†…å®¹
    } else {
      await ctx.answerCbQuery('âŒ æ“ä½œå·²è¿‡æœŸ')
      broadcastStates.delete(userId)
    }
  })

  bot.action('broadcast_confirm_group', async (ctx) => {
    const userId = String(ctx.from?.id || '')
    const state = broadcastStates.get(userId)

    if (state && state.type === 'group') {
      await ctx.answerCbQuery('âœ… è¯·å‘é€å¹¿æ’­å†…å®¹')
      // çŠ¶æ€å·²è®¾ç½®ï¼Œç­‰å¾…ç”¨æˆ·è¾“å…¥å†…å®¹
    } else {
      await ctx.answerCbQuery('âŒ æ“ä½œå·²è¿‡æœŸ')
      broadcastStates.delete(userId)
    }
  })

  bot.action('broadcast_cancel', async (ctx) => {
    const userId = String(ctx.from?.id || '')
    broadcastStates.delete(userId)

    await ctx.answerCbQuery('âŒ å·²å–æ¶ˆå¹¿æ’­')
    await ctx.editMessageText('âŒ å¹¿æ’­å·²å–æ¶ˆ')
  })
}

/**
 * ğŸ”¥ å®Œå…¨é‡å†™åˆ†ç»„ç®¡ç†æŒ‰é’®å¤„ç†
 */
export function registerGroupManagementButtons(bot) {

  // ç¼–è¾‘åˆ†ç»„ - æ˜¾ç¤ºåˆ†ç»„åˆ—è¡¨ä¾›é€‰æ‹©ç¼–è¾‘
  bot.action('group_refresh', async (ctx) => {
    try {
      const botId = await ensureCurrentBotId(ctx.bot)
      const groups = await prisma.chatGroup.findMany({
        where: { botId },
        select: { id: true, name: true },
        orderBy: { name: 'asc' }
      })

      if (groups.length === 0) {
        await ctx.answerCbQuery('âŒ æ²¡æœ‰åˆ†ç»„å¯ç¼–è¾‘')
        return
      }

      // åˆ›å»ºåˆ†ç»„æŒ‰é’®ï¼Œæ¯è¡Œæ˜¾ç¤ºä¸¤ä¸ª
      const inlineKeyboard = {
        inline_keyboard: []
      }

      for (let i = 0; i < groups.length; i += 2) {
        const row = []
        row.push({
          text: `âœï¸ ${groups[i].name}`,
          callback_data: `group_edit_select_${groups[i].id}`
        })

        if (i + 1 < groups.length) {
          row.push({
            text: `âœï¸ ${groups[i + 1].name}`,
            callback_data: `group_edit_select_${groups[i + 1].id}`
          })
        }

        inlineKeyboard.inline_keyboard.push(row)
      }

      inlineKeyboard.inline_keyboard.push([
        { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
      ])

      await ctx.editMessageText('âœï¸ *é€‰æ‹©è¦ç¼–è¾‘çš„åˆ†ç»„*\n\nç‚¹å‡»åˆ†ç»„åç§°è¿›è¡Œç¼–è¾‘ï¼š', {
        parse_mode: 'Markdown',
        reply_markup: inlineKeyboard
      })
    } catch (e) {
      console.error('[ç¼–è¾‘åˆ†ç»„èœå•]', e)
      await ctx.answerCbQuery('âŒ æŸ¥è¯¢å¤±è´¥')
    }
  })

  // åˆ›å»ºåˆ†ç»„
  bot.action('group_create', async (ctx) => {
    const userId = String(ctx.from?.id || '')

    groupManagementStates.set(userId, {
      action: 'create_group',
      step: 'name',
      timestamp: Date.now()
    })

    await ctx.editMessageText('ğŸ“ *åˆ›å»ºæ–°åˆ†ç»„*\n\nè¯·å‘é€åˆ†ç»„åç§°ï¼š', {
      parse_mode: 'Markdown'
    })
  })

  // ç¼–è¾‘åˆ†ç»„ - æ˜¾ç¤ºåˆ†ç»„åˆ—è¡¨ä¾›é€‰æ‹©
  bot.action('group_edit', async (ctx) => {
    try {
      const botId = await ensureCurrentBotId(ctx.bot)
      const groups = await prisma.chatGroup.findMany({
        where: { botId },
        select: { id: true, name: true },
        orderBy: { name: 'asc' }
      })

      if (groups.length === 0) {
        await ctx.answerCbQuery('âŒ æ²¡æœ‰åˆ†ç»„å¯ç¼–è¾‘')
        return
      }

      // åˆ›å»ºåˆ†ç»„æŒ‰é’®ï¼Œæ¯è¡Œæ˜¾ç¤ºä¸¤ä¸ª
      const inlineKeyboard = {
        inline_keyboard: []
      }

      for (let i = 0; i < groups.length; i += 2) {
        const row = []
        row.push({
          text: `âœï¸ ${groups[i].name}`,
          callback_data: `group_edit_select_${groups[i].id}`
        })

        if (i + 1 < groups.length) {
          row.push({
            text: `âœï¸ ${groups[i + 1].name}`,
            callback_data: `group_edit_select_${groups[i + 1].id}`
          })
        }

        inlineKeyboard.inline_keyboard.push(row)
      }

      inlineKeyboard.inline_keyboard.push([
        { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
      ])

      await ctx.editMessageText('âœï¸ *é€‰æ‹©è¦ç¼–è¾‘çš„åˆ†ç»„*\n\nç‚¹å‡»åˆ†ç»„åç§°è¿›è¡Œç¼–è¾‘ï¼š', {
        parse_mode: 'Markdown',
        reply_markup: inlineKeyboard
      })
    } catch (e) {
      console.error('[ç¼–è¾‘åˆ†ç»„èœå•]', e)
      await ctx.answerCbQuery('âŒ æŸ¥è¯¢å¤±è´¥')
    }
  })

  // åˆ é™¤åˆ†ç»„ - æ˜¾ç¤ºåˆ†ç»„åˆ—è¡¨ä¾›é€‰æ‹©
  bot.action('group_delete', async (ctx) => {
    try {
      const botId = await ensureCurrentBotId(ctx.bot)
      const groups = await prisma.chatGroup.findMany({
        where: { botId },
        select: { id: true, name: true },
        orderBy: { name: 'asc' }
      })

      if (groups.length === 0) {
        await ctx.answerCbQuery('âŒ æ²¡æœ‰åˆ†ç»„å¯åˆ é™¤')
        return
      }

      // åˆ›å»ºåˆ†ç»„æŒ‰é’®ï¼Œæ¯è¡Œæ˜¾ç¤ºä¸¤ä¸ª
      const inlineKeyboard = {
        inline_keyboard: []
      }

      for (let i = 0; i < groups.length; i += 2) {
        const row = []
        row.push({
          text: `ğŸ—‘ï¸ ${groups[i].name}`,
          callback_data: `group_delete_select_${groups[i].id}`
        })

        if (i + 1 < groups.length) {
          row.push({
            text: `ğŸ—‘ï¸ ${groups[i + 1].name}`,
            callback_data: `group_delete_select_${groups[i + 1].id}`
          })
        }

        inlineKeyboard.inline_keyboard.push(row)
      }

      inlineKeyboard.inline_keyboard.push([
        { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
      ])

      await ctx.editMessageText('ğŸ—‘ï¸ *é€‰æ‹©è¦åˆ é™¤çš„åˆ†ç»„*\n\nâš ï¸ åˆ é™¤åä¸å¯æ¢å¤ï¼Œè¯·è°¨æ…æ“ä½œï¼š', {
        parse_mode: 'Markdown',
        reply_markup: inlineKeyboard
      })
    } catch (e) {
      console.error('[åˆ é™¤åˆ†ç»„èœå•]', e)
      await ctx.answerCbQuery('âŒ æŸ¥è¯¢å¤±è´¥')
    }
  })

  // ç®¡ç†ç¾¤ç»„
  bot.action('group_manage_chats', async (ctx) => {
    try {
      const botId = await ensureCurrentBotId(ctx.bot)
      const groups = await prisma.chatGroup.findMany({
        where: { botId },
        select: { id: true, name: true },
        orderBy: { name: 'asc' }
      })

      if (groups.length === 0) {
        await ctx.answerCbQuery('âŒ è¯·å…ˆåˆ›å»ºåˆ†ç»„')
        return
      }

      const inlineKeyboard = {
        inline_keyboard: groups.map(group => [{
          text: `ğŸ‘¥ ${group.name}`,
          callback_data: `group_manage_chats_${group.id}`
        }])
      }

      inlineKeyboard.inline_keyboard.push([
        { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
      ])

      await ctx.editMessageText('ğŸ‘¥ *é€‰æ‹©åˆ†ç»„æ¥ç®¡ç†ç¾¤ç»„*\n\né€‰æ‹©è¦ç®¡ç†ç¾¤ç»„çš„åˆ†ç»„ï¼š', {
        parse_mode: 'Markdown',
        reply_markup: inlineKeyboard
      })
    } catch (e) {
      console.error('[ç®¡ç†ç¾¤ç»„èœå•]', e)
      await ctx.answerCbQuery('âŒ æŸ¥è¯¢å¤±è´¥')
    }
  })

  // è¿”å›ä¸»èœå•
  bot.action('group_back_menu', async (ctx) => {
    try {
      const botId = await ensureCurrentBotId(ctx.bot)

      // è·å–åˆ†ç»„åˆ—è¡¨
      const groups = await prisma.chatGroup.findMany({
        where: { botId },
        include: {
          _count: {
            select: { chats: true }
          }
        },
        orderBy: { name: 'asc' }
      })

      let message = 'ğŸ›ï¸ *åˆ†ç»„ç®¡ç†*\n\n'

      if (groups.length === 0) {
        message += 'ğŸ“ æš‚æ— åˆ†ç»„\n\n'
      } else {
        message += 'ğŸ“‹ *åˆ†ç»„åˆ—è¡¨ï¼š*\n\n'
        groups.forEach((group, index) => {
          message += `${index + 1}. **${group.name}** (${group._count.chats}ä¸ªç¾¤ç»„)\n`
        })
        message += '\n'
      }

      // æ„å»ºæŒ‰é’®
      const inlineKeyboard = {
        inline_keyboard: [
          [
            { text: 'â• åˆ›å»ºåˆ†ç»„', callback_data: 'group_create' },
            { text: 'âœï¸ ç¼–è¾‘åˆ†ç»„', callback_data: 'group_refresh' }
          ]
        ]
      }

      // å¦‚æœæœ‰åˆ†ç»„ï¼Œåªæ˜¾ç¤ºåŠŸèƒ½æŒ‰é’®
      if (groups.length > 0) {
        inlineKeyboard.inline_keyboard.push([
          { text: 'ğŸ—‘ï¸ åˆ é™¤åˆ†ç»„', callback_data: 'group_delete' },
          { text: 'ğŸ‘¥ ç®¡ç†ç¾¤ç»„', callback_data: 'group_manage_chats' }
        ])
      }

      inlineKeyboard.inline_keyboard.push([
        { text: 'âŒ å…³é—­', callback_data: 'group_close' }
      ])

      // å°è¯•ç¼–è¾‘æ¶ˆæ¯ï¼Œå¦‚æœå†…å®¹ç›¸åŒä¼šå¤±è´¥ï¼Œè¿™æ˜¯æ­£å¸¸çš„
      try {
        await ctx.editMessageText(message, {
          parse_mode: 'Markdown',
          reply_markup: inlineKeyboard
        })
      } catch (editError) {
        // å¦‚æœæ˜¯"message is not modified"é”™è¯¯ï¼Œè¯´æ˜ç”¨æˆ·å·²ç»åœ¨ä¸»èœå•äº†
        if (editError.response?.description?.includes('message is not modified')) {
          await ctx.answerCbQuery('â„¹ï¸ æ‚¨å·²ç»åœ¨åˆ†ç»„ç®¡ç†ä¸»èœå•äº†')
        } else {
          console.error('[è¿”å›ä¸»èœå•]', editError)
          await ctx.answerCbQuery('âŒ è¿”å›å¤±è´¥')
        }
      }

    } catch (e) {
      console.error('[è¿”å›ä¸»èœå•]', e)
      await ctx.answerCbQuery('âŒ è¿”å›å¤±è´¥')
    }
  })

  // å…³é—­èœå•
  bot.action('group_close', async (ctx) => {
    await ctx.editMessageText('âœ… åˆ†ç»„ç®¡ç†å·²å…³é—­')
  })

  // å¤„ç†ç¼–è¾‘åˆ†ç»„é€‰æ‹©
  bot.action(/^group_edit_select_(.+)$/, async (ctx) => {
    const groupId = ctx.match[1]
    const userId = String(ctx.from?.id || '')

    groupManagementStates.set(userId, {
      action: 'edit_group',
      groupId: groupId,
      step: 'name',
      timestamp: Date.now()
    })

    await ctx.editMessageText('âœï¸ *ç¼–è¾‘åˆ†ç»„*\n\nè¯·å‘é€æ–°çš„åˆ†ç»„åç§°ï¼š', {
      parse_mode: 'Markdown'
    })
  })

  // å¤„ç†åˆ é™¤åˆ†ç»„é€‰æ‹©
  bot.action(/^group_delete_select_(.+)$/, async (ctx) => {
    const groupId = ctx.match[1]

    try {
      const botId = await ensureCurrentBotId(ctx.bot)

      const group = await prisma.chatGroup.findFirst({
        where: { id: groupId, botId },
        select: { name: true, _count: { select: { chats: true } } }
      })

      if (!group) {
        await ctx.editMessageText('âš ï¸ åˆ†ç»„å·²ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ·æ–°åˆ—è¡¨...', {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
            ]]
          }
        })
        return
      }

      const inlineKeyboard = {
        inline_keyboard: [
          [
            { text: 'âœ… ç¡®è®¤åˆ é™¤', callback_data: `group_delete_confirm_${groupId}` },
            { text: 'âŒ å–æ¶ˆ', callback_data: 'group_refresh' }
          ]
        ]
      }

      await ctx.editMessageText(`ğŸ—‘ï¸ *ç¡®è®¤åˆ é™¤åˆ†ç»„*\n\nåˆ†ç»„åç§°ï¼š**${group.name}**\nåŒ…å«ç¾¤ç»„ï¼š${group._count.chats} ä¸ª\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ¢å¤ï¼Œç¡®å®šè¦åˆ é™¤å—ï¼Ÿ`, {
        parse_mode: 'Markdown',
        reply_markup: inlineKeyboard
      })
    } catch (e) {
      console.error('[åˆ é™¤åˆ†ç»„ç¡®è®¤]', e)
      await ctx.editMessageText('âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
          ]]
        }
      })
    }
  })

  // ğŸ”¥ å®Œå…¨é‡å†™åˆ é™¤åˆ†ç»„ç¡®è®¤é€»è¾‘
  bot.action(/^group_delete_confirm_(.+)$/, async (ctx) => {
    const groupId = ctx.match[1]

    try {
      console.log(`[åˆ é™¤åˆ†ç»„] å¼€å§‹åˆ é™¤åˆ†ç»„ ${groupId}`)

      // ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šå…ˆå°†è¯¥åˆ†ç»„ä¸‹çš„æ‰€æœ‰ç¾¤ç»„ç§»å‡ºåˆ†ç»„ï¼ˆè§£é™¤å…³è”ï¼‰
      const updateResult = await prisma.chat.updateMany({
        where: { groupId: groupId },
        data: { groupId: null }
      })
      console.log(`[åˆ é™¤åˆ†ç»„] ç§»é™¤äº† ${updateResult.count} ä¸ªç¾¤ç»„çš„å…³è”`)

      // ç„¶åå†åˆ é™¤åˆ†ç»„
      await prisma.chatGroup.delete({
        where: { id: groupId }
      })
      console.log(`[åˆ é™¤åˆ†ç»„] åˆ†ç»„åˆ é™¤æˆåŠŸ`)

      await ctx.editMessageText('âœ… åˆ†ç»„å·²æˆåŠŸåˆ é™¤', {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”™ è¿”å›åˆ†ç»„ç®¡ç†èœå•', callback_data: 'group_back_menu' }
          ]]
        }
      })
    } catch (e) {
      console.error('[åˆ é™¤åˆ†ç»„]', e)

      // å¤„ç†ä¸åŒç±»å‹çš„é”™è¯¯
      if (e.code === 'P2025' || e.message?.includes('Record to delete does not exist')) {
        console.log('[åˆ é™¤åˆ†ç»„] åˆ†ç»„ä¸å­˜åœ¨')
        await ctx.editMessageText('âš ï¸ åˆ†ç»„å·²ä¸åœ¨æ•°æ®åº“ä¸­ï¼Œåˆ—è¡¨å·²åˆ·æ–°', {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
            ]]
          }
        })
      } else {
        console.log(`[åˆ é™¤åˆ†ç»„] åˆ é™¤å¤±è´¥ï¼Œé”™è¯¯: ${e.code}`)
        await ctx.editMessageText('âŒ åˆ é™¤å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
            ]]
          }
        })
      }
    }
  })

  // å¤„ç†ç®¡ç†ç¾¤ç»„é€‰æ‹©
  bot.action(/^group_manage_chats_(.+)$/, async (ctx) => {
    const groupId = ctx.match[1]

    try {
      const group = await prisma.chatGroup.findUnique({
        where: { id: groupId },
        include: {
          chats: true
        }
      })

      if (!group) {
        // ğŸ”¥ ä¿®å¤ç•Œé¢æ»åé—®é¢˜ï¼šåˆ†ç»„ä¸å­˜åœ¨æ—¶è¿”å›åˆ†ç»„ç®¡ç†èœå•
        await ctx.editMessageText('âš ï¸ åˆ†ç»„å·²ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ·æ–°åˆ—è¡¨...', {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ”™ è¿”å›åˆ†ç»„ç®¡ç†èœå•', callback_data: 'group_back_menu' }
            ]]
          }
        })
        return
      }

      let msg = `ğŸ‘¥ *ç®¡ç†ç¾¤ç»„ - ${group.name}*\n\n`
      msg += `å½“å‰åˆ†ç»„åŒ…å« ${group.chats.length} ä¸ªç¾¤ç»„ï¼š\n\n`

      if (group.chats.length > 0) {
        group.chats.forEach((gc, index) => {
          if (gc.chat) {
            msg += `${index + 1}. ${gc.chat.title || gc.chat.id}\n`
          }
        })
      } else {
        msg += 'æš‚æ— ç¾¤ç»„\n'
      }

      const inlineKeyboard = {
        inline_keyboard: [
          [
            { text: 'â• æ·»åŠ ç¾¤ç»„', callback_data: `group_add_chat_${groupId}` },
            { text: 'â– ç§»é™¤ç¾¤ç»„', callback_data: `group_remove_chat_${groupId}` }
          ],
          [
            { text: 'ğŸ”™ è¿”å›èœå•', callback_data: 'group_back_menu' }
          ]
        ]
      }

      await ctx.editMessageText(msg, {
        parse_mode: 'Markdown',
        reply_markup: inlineKeyboard
      })
    } catch (e) {
      console.error('[ç®¡ç†ç¾¤ç»„]', e)
      await ctx.answerCbQuery('âŒ æŸ¥è¯¢å¤±è´¥')
    }
  })

  // å¤„ç†æ·»åŠ ç¾¤ç»„
  bot.action(/^group_add_chat_(.+)$/, async (ctx) => {
    const groupId = ctx.match[1]
    const userId = String(ctx.from?.id || '')

    try {
      const botId = await ensureCurrentBotId(ctx.bot)

      // è·å–åˆ†ç»„ä¿¡æ¯
      const group = await prisma.chatGroup.findFirst({
        where: { id: groupId, botId }, // ä½¿ç”¨ findFirst æ”¯æŒå¤šæ¡ä»¶
        include: { chats: true }
      })

      if (!group) {
        // ğŸ”¥ ä¿®å¤ç•Œé¢æ»åé—®é¢˜ï¼šåˆ†ç»„ä¸å­˜åœ¨æ—¶è¿”å›åˆ†ç»„ç®¡ç†èœå•
        await ctx.editMessageText('âš ï¸ åˆ†ç»„å·²ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ·æ–°åˆ—è¡¨...', {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ”™ è¿”å›åˆ†ç»„ç®¡ç†èœå•', callback_data: 'group_back_menu' }
            ]]
          }
        })
        return
      }

      // è·å–æ‰€æœ‰å½“å‰æœºå™¨äººç»‘å®šçš„ç¾¤ç»„
      const allChats = await prisma.chat.findMany({
        where: {
          botId: botId,
          status: 'APPROVED',
          allowed: true,
          id: { startsWith: '-' }
        },
        select: { id: true, title: true },
        orderBy: { title: 'asc' }
      })

      if (allChats.length === 0) {
        await ctx.editMessageText('âŒ å½“å‰æ²¡æœ‰å·²ç»‘å®šçš„ç¾¤ç»„', {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ”™ è¿”å›ç®¡ç†', callback_data: `group_manage_chats_${groupId}` }
            ]]
          }
        })
        return
      }

      // åˆå§‹åŒ–ç”¨æˆ·çš„é€‰æ‹©çŠ¶æ€ï¼ˆåŸºäºå½“å‰åˆ†ç»„å·²åŒ…å«çš„ç¾¤ç»„ï¼‰
      const initialSelections = new Set(group.chats.map(gc => gc.id))
      groupChatSelections.set(`${userId}_${groupId}`, initialSelections)

      // åˆ›å»ºä¸‰åˆ—çš„å†…è”é”®ç›˜
      await updateGroupChatSelectionUI(ctx, groupId, userId, group.name, allChats, initialSelections)

    } catch (e) {
      console.error('[æ·»åŠ ç¾¤ç»„ç•Œé¢]', e)
      await ctx.answerCbQuery('âŒ åŠ è½½å¤±è´¥')
    }
  })

  // æ›´æ–°ç¾¤ç»„é€‰æ‹©UIçš„è¾…åŠ©å‡½æ•°
  async function updateGroupChatSelectionUI(ctx, groupId, userId, groupName, allChats, selections) {
    const inlineKeyboard = {
      inline_keyboard: []
    }

    // æ¯è¡Œ3ä¸ªæŒ‰é’®
    const buttonsPerRow = 3
    for (let i = 0; i < allChats.length; i += buttonsPerRow) {
      const row = []
      for (let j = 0; j < buttonsPerRow && i + j < allChats.length; j++) {
        const chat = allChats[i + j]
        const isSelected = selections.has(chat.id)
        const emoji = isSelected ? 'âœ…' : 'â˜‘ï¸'
        const text = `${emoji} ${chat.title || chat.id}`

        row.push({
          text: text,
          callback_data: `group_toggle_chat_${groupId}_${chat.id}`
        })
      }
      inlineKeyboard.inline_keyboard.push(row)
    }

    // æ·»åŠ åº•éƒ¨æŒ‰é’®
    inlineKeyboard.inline_keyboard.push([
      { text: 'ğŸ’¾ ä¿å­˜æ›´æ”¹', callback_data: `group_save_chat_changes_${groupId}` },
      { text: 'ğŸ”™ è¿”å›ç®¡ç†', callback_data: `group_manage_chats_${groupId}` }
    ])

    const selectedCount = selections.size
    const totalCount = allChats.length

    await ctx.editMessageText(`ğŸ‘¥ *é€‰æ‹©è¦æ·»åŠ åˆ°åˆ†ç»„"${groupName}"çš„ç¾¤ç»„*\n\nå½“å‰å·²é€‰æ‹©ï¼š${selectedCount}/${totalCount} ä¸ªç¾¤ç»„\n\nç‚¹å‡»ç¾¤ç»„åç§°è¿›è¡Œé€‰æ‹©/å–æ¶ˆé€‰æ‹©ï¼š`, {
      parse_mode: 'Markdown',
      reply_markup: inlineKeyboard
    })
  }

  // å¤„ç†ç§»é™¤ç¾¤ç»„
  bot.action(/^group_remove_chat_(.+)$/, async (ctx) => {
    const groupId = ctx.match[1]

    try {
      const botId = await ensureCurrentBotId(ctx.bot)

      const group = await prisma.chatGroup.findFirst({
        where: { id: groupId, botId }, // ä½¿ç”¨ findFirst æ”¯æŒå¤šæ¡ä»¶
        include: {
          chats: {
            include: { chat: true }
          }
        }
      })

      if (!group) {
        // ğŸ”¥ ä¿®å¤ç•Œé¢æ»åé—®é¢˜ï¼šåˆ†ç»„ä¸å­˜åœ¨æ—¶è¿”å›åˆ†ç»„ç®¡ç†èœå•
        await ctx.editMessageText('âš ï¸ åˆ†ç»„å·²ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ·æ–°åˆ—è¡¨...', {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ”™ è¿”å›åˆ†ç»„ç®¡ç†èœå•', callback_data: 'group_back_menu' }
            ]]
          }
        })
        return
      }

      if (group.chats.length === 0) {
        await ctx.answerCbQuery('âŒ åˆ†ç»„ä¸­æ²¡æœ‰ç¾¤ç»„å¯ç§»é™¤')
        return
      }

      const inlineKeyboard = {
        inline_keyboard: group.chats.map(gc => [{
          text: `â– ${gc.chat.title || gc.chat.id}`,
          callback_data: `group_remove_chat_confirm_${groupId}_${gc.chatId}`
        }])
      }

      inlineKeyboard.inline_keyboard.push([
        { text: 'ğŸ”™ è¿”å›ç®¡ç†', callback_data: `group_manage_chats_${groupId}` }
      ])

      await ctx.editMessageText('â– *é€‰æ‹©è¦ç§»é™¤çš„ç¾¤ç»„*\n\nç‚¹å‡»ç¾¤ç»„åç§°è¿›è¡Œç§»é™¤ï¼š', {
        parse_mode: 'Markdown',
        reply_markup: inlineKeyboard
      })
    } catch (e) {
      console.error('[ç§»é™¤ç¾¤ç»„èœå•]', e)
      await ctx.answerCbQuery('âŒ æŸ¥è¯¢å¤±è´¥')
    }
  })

  // å¤„ç†ç§»é™¤ç¾¤ç»„ç¡®è®¤
  bot.action(/^group_remove_chat_confirm_(.+)_(.+)$/, async (ctx) => {
    const [groupId, chatId] = ctx.match.slice(1)

    try {
      await prisma.chat.update({
        where: { id: chatId },
        data: { groupId: null }
      })

      await ctx.editMessageText('âœ… ç¾¤ç»„å·²ä»åˆ†ç»„ä¸­ç§»é™¤', {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”™ è¿”å›ç®¡ç†', callback_data: `group_manage_chats_${groupId}` }
          ]]
        }
      })
    } catch (e) {
      console.error('[ç§»é™¤ç¾¤ç»„]', e)
      await ctx.answerCbQuery('âŒ ç§»é™¤å¤±è´¥')
    }
  })

  // å¤„ç†åˆ‡æ¢ç¾¤ç»„é€‰æ‹©çŠ¶æ€
  bot.action(/^group_toggle_chat_(.+)_(.+)$/, async (ctx) => {
    const [groupId, chatId] = ctx.match.slice(1)
    const userId = String(ctx.from?.id || '')

    try {
      const botId = await ensureCurrentBotId(ctx.bot)

      // è·å–åˆ†ç»„ä¿¡æ¯
      const group = await prisma.chatGroup.findFirst({
        where: { id: groupId, botId } // ä½¿ç”¨ findFirst æ”¯æŒå¤šæ¡ä»¶
      })

      if (!group) {
        // ğŸ”¥ ä¿®å¤ç•Œé¢æ»åé—®é¢˜ï¼šåˆ†ç»„ä¸å­˜åœ¨æ—¶è¿”å›åˆ†ç»„ç®¡ç†èœå•
        await ctx.editMessageText('âš ï¸ åˆ†ç»„å·²ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ·æ–°åˆ—è¡¨...', {
          reply_markup: {
            inline_keyboard: [[
              { text: 'ğŸ”™ è¿”å›åˆ†ç»„ç®¡ç†èœå•', callback_data: 'group_back_menu' }
            ]]
          }
        })
        return
      }

      // è·å–æ‰€æœ‰å½“å‰æœºå™¨äººç»‘å®šçš„ç¾¤ç»„
      const allChats = await prisma.chat.findMany({
        where: {
          botId: botId,
          status: 'APPROVED',
          allowed: true,
          id: { startsWith: '-' }
        },
        select: { id: true, title: true },
        orderBy: { title: 'asc' }
      })

      // è·å–æˆ–åˆå§‹åŒ–ç”¨æˆ·çš„é€‰æ‹©çŠ¶æ€
      const selectionKey = `${userId}_${groupId}`
      let selections = groupChatSelections.get(selectionKey)
      if (!selections) {
        // å¦‚æœæ²¡æœ‰é€‰æ‹©çŠ¶æ€ï¼Œåˆå§‹åŒ–ä¸ºå½“å‰åˆ†ç»„åŒ…å«çš„ç¾¤ç»„
        const currentGroup = await prisma.chatGroup.findUnique({
          where: { id: groupId },
          include: { chats: true }
        })
        selections = new Set(currentGroup?.chats.map(gc => gc.id) || [])
        groupChatSelections.set(selectionKey, selections)
      }

      // åˆ‡æ¢é€‰æ‹©çŠ¶æ€
      if (selections.has(chatId)) {
        selections.delete(chatId) // å–æ¶ˆé€‰æ‹©
      } else {
        selections.add(chatId) // é€‰æ‹©
      }

      // æ›´æ–°UI
      await updateGroupChatSelectionUI(ctx, groupId, userId, group.name, allChats, selections)

    } catch (e) {
      console.error('[åˆ‡æ¢ç¾¤ç»„é€‰æ‹©]', e)
      await ctx.answerCbQuery('âŒ æ“ä½œå¤±è´¥')
    }
  })

  // å¤„ç†ä¿å­˜ç¾¤ç»„æ›´æ”¹
  bot.action(/^group_save_chat_changes_(.+)$/, async (ctx) => {
    const groupId = ctx.match[1]
    const userId = String(ctx.from?.id || '')

    try {
      const selectionKey = `${userId}_${groupId}`
      const selections = groupChatSelections.get(selectionKey)

      if (!selections) {
        await ctx.answerCbQuery('âŒ æ²¡æœ‰æ‰¾åˆ°é€‰æ‹©çŠ¶æ€')
        return
      }

      // å°†æ‰€æœ‰é€‰ä¸­çš„ç¾¤ç»„æ·»åŠ åˆ°åˆ†ç»„ï¼Œå–æ¶ˆé€‰æ‹©çš„ä»åˆ†ç»„ç§»é™¤
      await prisma.chat.updateMany({
        where: { id: { in: Array.from(selections) } },
        data: { groupId: groupId }
      })

      await prisma.chat.updateMany({
        where: {
          groupId: groupId,
          id: { notIn: Array.from(selections) }
        },
        data: { groupId: null }
      })

      // æ¸…ç†é€‰æ‹©çŠ¶æ€
      groupChatSelections.delete(selectionKey)

      await ctx.editMessageText('âœ… ç¾¤ç»„åˆ†é…å·²ä¿å­˜ï¼', {
        reply_markup: {
          inline_keyboard: [[
            { text: 'ğŸ”™ è¿”å›ç®¡ç†', callback_data: `group_manage_chats_${groupId}` }
          ]]
        }
      })
    } catch (e) {
      console.error('[ä¿å­˜ç¾¤ç»„æ›´æ”¹]', e)
      await ctx.answerCbQuery('âŒ ä¿å­˜å¤±è´¥')
    }
  })
}

/**
 * å¤„ç†åˆ†ç»„ç®¡ç†ç›¸å…³çš„æ–‡æœ¬è¾“å…¥
 */
export function registerGroupManagementText(bot) {
  bot.on('text', async (ctx, next) => {
    const userId = String(ctx.from?.id || '')
    const state = groupManagementStates.get(userId)

    if (!state || Date.now() - state.timestamp > 300000) { // 5åˆ†é’Ÿè¶…æ—¶
      groupManagementStates.delete(userId)
      await next()
      return
    }

    const text = ctx.message.text.trim()

    try {
      if (state.action === 'create_group' && state.step === 'name') {
        // åˆ›å»ºåˆ†ç»„ - ç›´æ¥åˆ›å»ºï¼ˆæ— æè¿°ï¼‰
        if (text.length > 50) {
          return ctx.reply('âŒ åˆ†ç»„åç§°è¿‡é•¿ï¼ˆæœ€å¤š50å­—ç¬¦ï¼‰')
        }

        const botId = await ensureCurrentBotId(ctx.bot)

        // æ£€æŸ¥åˆ†ç»„åæ˜¯å¦å·²å­˜åœ¨
        const existing = await prisma.chatGroup.findUnique({
          where: {
            botId_name: {
              botId: botId,
              name: text
            }
          }
        })

        if (existing) {
          return ctx.reply('âŒ åˆ†ç»„åç§°å·²å­˜åœ¨ï¼Œè¯·é€‰æ‹©å…¶ä»–åç§°')
        }

        // ç›´æ¥åˆ›å»ºåˆ†ç»„ï¼ˆæ— æè¿°ï¼‰
        await prisma.chatGroup.create({
          data: {
            botId: botId,
            name: text,
            description: null
          }
        })

        groupManagementStates.delete(userId)

        const successKeyboard = {
          inline_keyboard: [[
            { text: 'ğŸ”™ è¿”å›åˆ†ç»„ç®¡ç†', callback_data: 'group_back_menu' }
          ]]
        }

        await ctx.reply(`âœ… åˆ†ç»„"${text}"åˆ›å»ºæˆåŠŸï¼`, {
          reply_markup: successKeyboard
        })

      } else if (state.action === 'edit_group' && state.step === 'name') {
        // ç¼–è¾‘åˆ†ç»„ - åç§°è¾“å…¥
        if (text.length > 50) {
          return ctx.reply('âŒ åˆ†ç»„åç§°è¿‡é•¿ï¼ˆæœ€å¤š50å­—ç¬¦ï¼‰')
        }

        const botId = await ensureCurrentBotId(ctx.bot)

        // æ£€æŸ¥åˆ†ç»„åæ˜¯å¦å·²å­˜åœ¨ï¼ˆæ’é™¤å½“å‰åˆ†ç»„ï¼‰
        const existing = await prisma.chatGroup.findFirst({
          where: {
            botId: botId,
            name: text,
            id: { not: state.groupId }
          }
        })

        if (existing) {
          return ctx.reply('âŒ åˆ†ç»„åç§°å·²å­˜åœ¨ï¼Œè¯·é€‰æ‹©å…¶ä»–åç§°')
        }

        await prisma.chatGroup.update({
          where: { id: state.groupId },
          data: { name: text }
        })

        groupManagementStates.delete(userId)

        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯å’Œè¿”å›èœå•æŒ‰é’®
        const successKeyboard = {
          inline_keyboard: [[
            { text: 'ğŸ”™ è¿”å›åˆ†ç»„ç®¡ç†', callback_data: 'group_back_menu' }
          ]]
        }

        await ctx.reply('âœ… åˆ†ç»„åç§°ä¿®æ”¹æˆåŠŸï¼', {
          reply_markup: successKeyboard
        })

      }

    } catch (e) {
      console.error('[åˆ†ç»„ç®¡ç†æ–‡æœ¬å¤„ç†]', e)
      groupManagementStates.delete(userId)
      await ctx.reply('âŒ æ“ä½œå¤±è´¥ï¼Œè¯·é‡è¯•')
    }

    await next()
  })

}

/**
 * åˆ†ç»„å¹¿æ’­åŠŸèƒ½
 * æŒ‡ä»¤ï¼šåˆ†ç»„å¹¿æ’­ åˆ†ç»„å æ¶ˆæ¯å†…å®¹
 */
/**
 * åˆ†ç»„å¹¿æ’­åŠŸèƒ½ï¼ˆä¸‰æ­¥æµç¨‹ï¼‰
 * ç¬¬ä¸€æ­¥ï¼šåˆ†ç»„å¹¿æ’­ -> æ˜¾ç¤ºåˆ†ç»„é€‰æ‹©
 * ç¬¬äºŒæ­¥ï¼šé€‰æ‹©åˆ†ç»„ -> ç­‰å¾…å†…å®¹è¾“å…¥
 * ç¬¬ä¸‰æ­¥ï¼šè¾“å…¥å†…å®¹ -> ç¡®è®¤å¹¿æ’­
 * ç¬¬å››æ­¥ï¼šç¡®è®¤ -> æ‰§è¡Œå¹¿æ’­
 */
export function registerGroupBroadcast(bot) {
  // ç¬¬ä¸€æ­¥ï¼šåˆ†ç»„å¹¿æ’­å‘½ä»¤
  bot.hears(/^åˆ†ç»„å¹¿æ’­$/, async (ctx) => {
    const userId = String(ctx.from?.id || '')

    // ğŸ”¥ ä¸¥æ ¼æ ¡éªŒæ˜¯å¦ä¸ºè¶…çº§ç®¡ç†å‘˜
    if (!(await isAdmin(ctx))) {
      return
    }

    const botId = await ensureCurrentBotId(ctx.bot)

    // è·å–æ‰€æœ‰åˆ†ç»„
    const groups = await prisma.chatGroup.findMany({
      where: { botId },
      include: {
        _count: {
          select: { chats: true }
        }
      },
      orderBy: { name: 'asc' }
    })

    if (groups.length === 0) {
      return ctx.reply('âŒ å½“å‰æ²¡æœ‰åˆ›å»ºä»»ä½•åˆ†ç»„ï¼Œè¯·å…ˆåˆ›å»ºåˆ†ç»„')
    }

    // åˆ›å»ºåˆ†ç»„é€‰æ‹©æŒ‰é’®
    const inlineKeyboard = {
      inline_keyboard: []
    }

    // æ¯è¡Œ2ä¸ªåˆ†ç»„æŒ‰é’®
    const buttonsPerRow = 2
    for (let i = 0; i < groups.length; i += buttonsPerRow) {
      const row = []
      for (let j = 0; j < buttonsPerRow && i + j < groups.length; j++) {
        const group = groups[i + j]
        const buttonText = `${group.name} (${group._count.chats}ç¾¤ç»„)`
        row.push({
          text: buttonText,
          callback_data: `group_broadcast_select_${group.id}`
        })
      }
      inlineKeyboard.inline_keyboard.push(row)
    }

    // æ·»åŠ å–æ¶ˆæŒ‰é’®
    inlineKeyboard.inline_keyboard.push([
      { text: 'âŒ å–æ¶ˆ', callback_data: 'group_broadcast_cancel' }
    ])

    await ctx.reply('ğŸ“ *é€‰æ‹©è¦å¹¿æ’­çš„åˆ†ç»„*\n\nç‚¹å‡»åˆ†ç»„åç§°è¿›è¡Œé€‰æ‹©ï¼š', {
      parse_mode: 'Markdown',
      reply_markup: inlineKeyboard
    })
  })

  // ç¬¬äºŒæ­¥ï¼šå¤„ç†åˆ†ç»„é€‰æ‹©
  bot.action(/^group_broadcast_select_(.+)$/, async (ctx) => {
    const groupId = ctx.match[1]
    const userId = String(ctx.from?.id || '')

    try {
      const group = await prisma.chatGroup.findUnique({
        where: { id: groupId },
        include: {
          _count: {
            select: { chats: true }
          }
        }
      })

      if (!group) {
        await ctx.answerCbQuery('âŒ åˆ†ç»„ä¸å­˜åœ¨')
        return
      }

      if (group._count.chats === 0) {
        await ctx.answerCbQuery('âŒ è¯¥åˆ†ç»„ä¸­æ²¡æœ‰ç¾¤ç»„')
        return
      }

      // è®¾ç½®å¹¿æ’­çŠ¶æ€
      broadcastStates.set(userId, {
        type: 'group_select',
        groupId: groupId,
        groupName: group.name,
        timestamp: Date.now()
      })

      await ctx.editMessageText(`ğŸ“ *åˆ†ç»„ "${group.name}" å·²é€‰æ‹©*\n\nè¯·å‘é€è¦å¹¿æ’­çš„å†…å®¹ï¼š`, {
        parse_mode: 'Markdown'
      })

    } catch (e) {
      console.error('[åˆ†ç»„å¹¿æ’­é€‰æ‹©]', e)
      await ctx.answerCbQuery('âŒ é€‰æ‹©å¤±è´¥')
    }
  })

  // å–æ¶ˆåˆ†ç»„å¹¿æ’­
  bot.action('group_broadcast_cancel', async (ctx) => {
    await ctx.editMessageText('âŒ åˆ†ç»„å¹¿æ’­å·²å–æ¶ˆ')
  })

  // ç¬¬ä¸‰æ­¥ï¼šå¤„ç†å¹¿æ’­å†…å®¹è¾“å…¥ï¼ˆæ–‡æœ¬ã€å›¾ç‰‡ã€è§†é¢‘ï¼‰
  bot.on(['text', 'photo', 'video'], async (ctx, next) => {
    const userId = String(ctx.from?.id || '')
    const state = broadcastStates.get(userId)

    if (state && state.type === 'group_select' && Date.now() - state.timestamp < 300000) { // 5åˆ†é’Ÿè¶…æ—¶

      // æ›´æ–°çŠ¶æ€ä¸ºç­‰å¾…ç¡®è®¤
      broadcastStates.set(userId, {
        ...state,
        type: 'group_confirm',
        content: ctx.message
      })

      // æ˜¾ç¤ºç¡®è®¤ç•Œé¢
      const confirmKeyboard = {
        inline_keyboard: [
          [
            { text: 'âœ… ç¡®è®¤å¹¿æ’­', callback_data: 'group_broadcast_confirm' },
            { text: 'âŒ å–æ¶ˆ', callback_data: 'group_broadcast_cancel_confirm' }
          ]
        ]
      }

      // æ ¹æ®æ¶ˆæ¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„é¢„è§ˆ
      let contentPreview = ''
      if (ctx.message.photo) {
        contentPreview = 'ğŸ“· å›¾ç‰‡' + (ctx.message.caption ? `: ${ctx.message.caption.substring(0, 50)}...` : '')
      } else if (ctx.message.video) {
        contentPreview = 'ğŸ¥ è§†é¢‘' + (ctx.message.caption ? `: ${ctx.message.caption.substring(0, 50)}...` : '')
      } else {
        const textContent = ctx.message.text
        contentPreview = textContent.length > 100 ? textContent.substring(0, 100) + '...' : textContent
      }

      await ctx.reply(`ğŸ“¢ *å¹¿æ’­ç¡®è®¤*\n\n**åˆ†ç»„ï¼š** ${state.groupName}\n**å†…å®¹ï¼š** ${contentPreview}\n\nç¡®è®¤è¦å‘é€å—ï¼Ÿ`, {
        parse_mode: 'Markdown',
        reply_markup: confirmKeyboard
      })

    } else {
      await next()
    }
  })

  // ç¬¬å››æ­¥ï¼šå¤„ç†å¹¿æ’­ç¡®è®¤
  bot.action('group_broadcast_confirm', async (ctx) => {
    const userId = String(ctx.from?.id || '')

    try {
      const state = broadcastStates.get(userId)

      if (!state || state.type !== 'group_confirm') {
        await ctx.answerCbQuery('âŒ æ“ä½œå·²è¿‡æœŸ')
        return
      }

      // æ¸…é™¤çŠ¶æ€
      const { groupName, content } = state
      broadcastStates.delete(userId)

      await ctx.editMessageText(`â³ å¼€å§‹å‘åˆ†ç»„"${groupName}"æ‰§è¡Œå¹¿æ’­...`)

      // æ‰§è¡Œå¹¿æ’­
      await executeBroadcast(bot, ctx, content, groupName)

    } catch (e) {
      console.error('[åˆ†ç»„å¹¿æ’­ç¡®è®¤]', e)
      await ctx.answerCbQuery('âŒ å¹¿æ’­å¤±è´¥')
    }
  })

  // å–æ¶ˆå¹¿æ’­ç¡®è®¤
  bot.action('group_broadcast_cancel_confirm', async (ctx) => {
    const userId = String(ctx.from?.id || '')
    broadcastStates.delete(userId)

    await ctx.editMessageText('âŒ å¹¿æ’­å·²å–æ¶ˆ')
  })
}

/**
 * æŸ¥çœ‹åˆ†ç»„åˆ—è¡¨
 * æŒ‡ä»¤ï¼šåˆ†ç»„åˆ—è¡¨
 */
export function registerGroupList(bot) {
  bot.hears(/^åˆ†ç»„åˆ—è¡¨$/i, async (ctx) => {
    const userId = String(ctx.from?.id || '')

    // ğŸ”¥ åªæœ‰è¶…çº§ç®¡ç†å‘˜èƒ½æŸ¥çœ‹åˆ†ç»„åˆ—è¡¨
    if (!(await isAdmin(ctx))) {
      return
    }

    try {
      const botId = await ensureCurrentBotId(ctx.bot)
      const groups = await prisma.chatGroup.findMany({
        where: { botId },
        include: {
          _count: {
            select: { chats: true }
          }
        },
        orderBy: { name: 'asc' }
      })

      if (groups.length === 0) {
        return ctx.reply('ğŸ“ å½“å‰æ²¡æœ‰åˆ›å»ºä»»ä½•åˆ†ç»„')
      }

      let msg = 'ğŸ“‹ *åˆ†ç»„åˆ—è¡¨*\n\n'
      groups.forEach(group => {
        msg += `â€¢ ${group.name} (${group._count.chats}ä¸ªç¾¤ç»„)\n`
      })

      await ctx.reply(msg, { parse_mode: 'Markdown' })

    } catch (e) {
      console.error('[åˆ†ç»„åˆ—è¡¨]', e)
      await ctx.reply('âŒ æŸ¥è¯¢åˆ†ç»„åˆ—è¡¨å¤±è´¥')
    }
  })
}
// æ˜¾ç¤º/è®°è´¦/ä½£é‡‘ æ¨¡å¼ç›¸å…³æŒ‡ä»¤
import { prisma } from '../../lib/db.js'
import { hasPermissionWithWhitelist, buildInlineKb } from '../helpers.js'
import { ensureDbChat, updateSettings } from '../database.js'

export function registerDisplayMode(bot, ensureChat) {
  // æ˜¾ç¤ºæ¨¡å¼[1-6]
  bot.hears(/^æ˜¾ç¤ºæ¨¡å¼[123456]$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    const m = ctx.message.text.match(/(\d)/)
    const mode = Number(m[1])
    chat.displayMode = mode
    const modeDesc = {
      1: 'æœ€è¿‘3ç¬”',
      2: 'æœ€è¿‘5ç¬”',
      3: 'ä»…æ€»è®¡',
      4: 'æœ€è¿‘10ç¬”',
      5: 'æœ€è¿‘20ç¬”',
      6: 'æ˜¾ç¤ºå…¨éƒ¨'
    }
    await ctx.reply(`æ˜¾ç¤ºæ¨¡å¼å·²åˆ‡æ¢ä¸º ${mode}ï¼ˆ${modeDesc[mode] || 'æœªçŸ¥æ¨¡å¼'}ï¼‰`)
  })

  // å•æ˜¾æ¨¡å¼ï¼ˆå…¼å®¹äººæ°‘å¸æ¨¡å¼ï¼‰
  bot.hears(/^(å•æ˜¾æ¨¡å¼|äººæ°‘å¸æ¨¡å¼)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    chat.rmbMode = true
    await ctx.reply('å·²åˆ‡æ¢ä¸ºå•æ˜¾æ¨¡å¼ï¼ˆä»…æ˜¾ç¤ºå½“å‰å¸ç§ï¼‰')
  })

  // åŒæ˜¾æ¨¡å¼
  bot.hears(/^(åŒæ˜¾æ¨¡å¼|æ˜¾ç¤ºä¸¤åˆ—)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    chat.rmbMode = false
    await ctx.reply('å·²åˆ‡æ¢ä¸ºåŒæ˜¾æ¨¡å¼ï¼ˆå½“å‰å¸ç§ | USDTï¼‰')
  })
}

export function registerAccountingModes(bot, ensureChat) {
  // è®°è´¦æ¨¡å¼åˆ‡æ¢ï¼ˆç´¯è®¡/ç»“è½¬ï¼‰
  bot.hears(/^(ç´¯è®¡æ¨¡å¼|ç»“è½¬æ¨¡å¼)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    const chatId = await ensureDbChat(ctx)
    await updateSettings(chatId, { accountingMode: 'CARRY_OVER' })
    await ctx.reply('å·²åˆ‡æ¢ä¸ºã€ç´¯è®¡æ¨¡å¼ã€‘\næœªä¸‹å‘é‡‘é¢å°†ç´¯è®¡åˆ°æ¬¡æ—¥ï¼ŒæŒç»­ç»Ÿè®¡ç›´åˆ°å®Œå…¨ä¸‹å‘ã€‚')
  })

  // å•ç¬”è®¢å•æ¨¡å¼
  bot.hears(/^(å•ç¬”è®¢å•|å•ç¬”è®¢å•æ¨¡å¼)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    const chatId = await ensureDbChat(ctx)
    await updateSettings(chatId, { accountingMode: 'SINGLE_BILL_PER_DAY' })
    await ctx.reply('å·²åˆ‡æ¢ä¸ºã€å•ç¬”è®¢å•æ¨¡å¼ã€‘\næ¯å¤©åªæœ‰ä¸€ç¬”è®¢å•ï¼Œä¸æ”¯æŒä¿å­˜è´¦å•ï¼Œä½†æ”¯æŒåˆ é™¤è´¦å•ã€‚æ—¥åˆ‡æ—¶ä¼šè‡ªåŠ¨å…³é—­æ˜¨å¤©çš„è´¦å•ã€‚')
  })

  // æ¸…é›¶æ¨¡å¼
  bot.hears(/^(æ¸…é›¶æ¨¡å¼|æŒ‰æ—¥æ¸…é›¶)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    const chatId = await ensureDbChat(ctx)
    await updateSettings(chatId, { accountingMode: 'DAILY_RESET' })
    await ctx.reply('å·²åˆ‡æ¢ä¸ºã€æ¸…é›¶æ¨¡å¼ã€‘\næ¯æ—¥è´¦å•ç‹¬ç«‹è®¡ç®—ï¼Œä¸ç»“è½¬å†å²æœªä¸‹å‘é‡‘é¢ã€‚')
  })

  // è®¾ç½®è®°è´¦æ¨¡å¼ æŒ‡ä»¤
  bot.hears(/^è®¾ç½®è®°è´¦æ¨¡å¼\s+(ç´¯è®¡æ¨¡å¼|æ¸…é›¶æ¨¡å¼|å•ç¬”è®¢å•)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    const chatId = await ensureDbChat(ctx)
    const mode = ctx.match[1]
    let accountingMode = 'DAILY_RESET'
    let modeName = 'æ¸…é›¶æ¨¡å¼'
    let desc = 'æ¯æ—¥è´¦å•ç‹¬ç«‹è®¡ç®—ï¼Œä¸ç»“è½¬å†å²æœªä¸‹å‘é‡‘é¢ã€‚'

    if (mode === 'ç´¯è®¡æ¨¡å¼') {
      accountingMode = 'CARRY_OVER'
      modeName = 'ç´¯è®¡æ¨¡å¼'
      desc = 'æœªä¸‹å‘é‡‘é¢å°†ç´¯è®¡åˆ°æ¬¡æ—¥ï¼ŒæŒç»­ç»Ÿè®¡ç›´åˆ°å®Œå…¨ä¸‹å‘ã€‚'
    } else if (mode === 'å•ç¬”è®¢å•') {
      accountingMode = 'SINGLE_BILL_PER_DAY'
      modeName = 'å•ç¬”è®¢å•æ¨¡å¼'
      desc = 'æ¯å¤©åªæœ‰ä¸€ç¬”è®¢å•ï¼Œä¸æ”¯æŒä¿å­˜è´¦å•ï¼Œä½†æ”¯æŒåˆ é™¤è´¦å•ã€‚æ—¥åˆ‡æ—¶ä¼šè‡ªåŠ¨å…³é—­æ˜¨å¤©çš„è´¦å•ã€‚'
    }

    await updateSettings(chatId, { accountingMode })
    await ctx.reply(`âœ… å·²åˆ‡æ¢ä¸ºã€${modeName}ã€‘\n${desc}`, { ...(await buildInlineKb(ctx)) })
  })

  // æŸ¥çœ‹è®°è´¦æ¨¡å¼
  bot.hears(/^æŸ¥çœ‹è®°è´¦æ¨¡å¼$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    const chatId = await ensureDbChat(ctx)
    const settings = await prisma.setting.findUnique({ where: { chatId } })
    const mode = settings?.accountingMode || 'DAILY_RESET'
    let modeName = 'æ¸…é›¶æ¨¡å¼ï¼ˆæŒ‰æ—¥æ¸…é›¶ï¼‰'
    let desc = 'å½“å‰æ¨¡å¼ï¼šæ¯æ—¥è´¦å•ç‹¬ç«‹è®¡ç®—ï¼Œä¸ç»“è½¬å†å²'

    if (mode === 'CARRY_OVER') {
      modeName = 'ç´¯è®¡æ¨¡å¼ï¼ˆç»“è½¬æœªä¸‹å‘ï¼‰'
      desc = 'å½“å‰æ¨¡å¼ï¼šæœªä¸‹å‘é‡‘é¢ä¼šç´¯è®¡åˆ°æ¬¡æ—¥ç»§ç»­ç»Ÿè®¡'
    } else if (mode === 'SINGLE_BILL_PER_DAY') {
      modeName = 'å•ç¬”è®¢å•æ¨¡å¼'
      desc = 'å½“å‰æ¨¡å¼ï¼šæ¯å¤©åªæœ‰ä¸€ç¬”è®¢å•ï¼Œä¸æ”¯æŒä¿å­˜ï¼Œä½†æ”¯æŒåˆ é™¤ã€‚æ—¥åˆ‡æ—¶ä¼šè‡ªåŠ¨å…³é—­æ˜¨å¤©çš„è´¦å•ã€‚'
    }

    await ctx.reply(`${modeName}\n${desc}`)
  })
}

export function registerCommissionMode(bot, ensureChat) {
  bot.hears(/^ä½£é‡‘\s*æ¨¡å¼$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    chat.commissionMode = true
    await ensureDbChat(ctx)
    await ctx.reply('å·²å¼€å¯ä½£é‡‘æ¨¡å¼ï¼ˆåœ¨å›å¤æŸäººæ¶ˆæ¯æ—¶è¾“å…¥ +N æˆ– -N è°ƒæ•´ä½£é‡‘ï¼‰')
  })
}
// æ ¸å¿ƒå‘½ä»¤å¤„ç†å™¨ï¼ˆstart, myid, help, dashboardç­‰ï¼‰
import { prisma } from '../../lib/db.js'
import { getChat } from '../state.js'
import { buildInlineKb } from '../helpers.js'

const BACKEND_URL = process.env.BACKEND_URL

/**
 * æ³¨å†Œ start å‘½ä»¤
 */
export function registerStart(bot, ensureChat) {
  bot.start(async (ctx) => {
    const userId = ctx.from?.id
    const username = ctx.from?.username ? `@${ctx.from.username}` : 'æ— '
    const firstName = ctx.from?.first_name || ''
    const lastName = ctx.from?.last_name || ''
    const fullName = `${firstName} ${lastName}`.trim()

    if (ctx.chat?.type === 'private') {
      // ğŸ”¥ ç§èŠï¼šæ£€æŸ¥æ˜¯å¦åœ¨ç™½åå•ï¼Œæ˜¾ç¤ºä¸åŒçš„æç¤ºä¿¡æ¯
      const userIdStr = String(userId || '')
      const whitelistedUser = await prisma.whitelistedUser.findUnique({
        where: { userId: userIdStr }
      })

      if (whitelistedUser) {
        // ğŸ”¥ ç™½åå•ç”¨æˆ·ï¼šæ˜¾ç¤ºç®€è¦ä¿¡æ¯ï¼Œæä¾›å†…è”èœå•
        await ctx.reply(
          `ğŸ‘¤ æ‚¨çš„ç”¨æˆ·ä¿¡æ¯ï¼š\n\n` +
          `ğŸ†” ç”¨æˆ·IDï¼š\`${userId}\`\n` +
          `ğŸ‘¤ ç”¨æˆ·åï¼š${username}\n` +
          `ğŸ“› æ˜µç§°ï¼š${fullName || 'æ— '}\n\n` +
          `âœ… æ‚¨å·²åœ¨ç™½åå•ä¸­ï¼Œå¯ä»¥é‚€è¯·æœºå™¨äººè¿›ç¾¤è‡ªåŠ¨æˆæƒã€‚\n\n` +
          `ğŸ’¡ ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹ä½¿ç”¨ï¼š`,
          {
            parse_mode: 'Markdown',
            ...(await buildInlineKb(ctx))
          }
        )
      } else {
        // ğŸ”¥ éç™½åå•ç”¨æˆ·ï¼šæ˜¾ç¤ºè¯¦ç»†æç¤ºä¿¡æ¯ï¼ˆåªæ˜¾ç¤ºä½¿ç”¨è¯´æ˜æŒ‰é’®ï¼‰
        const { Markup } = await import('telegraf')
        const inlineKb = Markup.inlineKeyboard([
          [Markup.button.callback('ğŸ“‹ ä½¿ç”¨è¯´æ˜', 'help')]
        ])

        await ctx.reply(
          `ğŸ‘¤ æ‚¨çš„ç”¨æˆ·ä¿¡æ¯ï¼š\n\n` +
          `ğŸ†” ç”¨æˆ·IDï¼š\`${userId}\`\n` +
          `ğŸ‘¤ ç”¨æˆ·åï¼š${username}\n` +
          `ğŸ“› æ˜µç§°ï¼š${fullName || 'æ— '}\n\n` +
          `æ‚¨ä¸åœ¨ç™½åå•ä¸­ï¼Œè¯·è”ç³»ç®¡ç†å‘˜å°†æ‚¨åŠ å…¥ç™½åå•ã€‚\n\n` +
          `ğŸ’¡ ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®è·å–ä½¿ç”¨è¯´æ˜ï¼š`,
          {
            parse_mode: 'Markdown',
            ...inlineKb
          }
        )
      }
    } else {
      // ç¾¤èŠï¼šåˆå§‹åŒ–è®°è´¦
      const chat = ensureChat(ctx)
      if (!chat) return
      await ctx.reply(
        `å¼€å§‹è®°è´¦ï¼Œä½¿ç”¨ +é‡‘é¢ / -é‡‘é¢ è®°å½•å…¥æ¬¾ï¼Œä½¿ç”¨ "ä¸‹å‘é‡‘é¢" è®°å½•ä¸‹å‘ã€‚è¾“å…¥ "æ˜¾ç¤ºè´¦å•" æŸ¥çœ‹æ±‡æ€»ã€‚\n\n` +
        `ğŸ‘¤ æ‚¨çš„IDï¼š\`${userId}\` ç”¨æˆ·åï¼š${username}`,
        { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' }
      )
    }
  })
}

// ğŸ”¥ /myid å‘½ä»¤å·²åˆ é™¤ï¼Œåªä¿ç•™ä¸­æ–‡æŒ‡ä»¤

/**
 * è·å–æœºå™¨äººä½¿ç”¨è¯´æ˜æ–‡æœ¬ï¼ˆMarkdownV2 æ ¼å¼ï¼‰
 */
function getHelpText() {
  const content = [
    '*ğŸ“– æœºå™¨äººä½¿ç”¨è¯´æ˜*',
    '',
    '*ğŸ’° è®°è´¦åŠŸèƒ½*',
    'â€¢ å¼€å§‹è®°è´¦ / åœæ­¢è®°è´¦ \\- å¼€å¯/æš‚åœè®°è´¦',
    'â€¢ \\+100 æˆ– \\+100u \\- å…¥æ¬¾ï¼ˆå½“å‰å¸ç§/USDTï¼‰',
    'â€¢ \\+100/7\\.2 \\- æŒ‡å®šæ±‡ç‡ï¼›æå››\\+10000 \\- å¸¦å¤‡æ³¨',
    'â€¢ ä¸‹å‘100 / ä¸‹å‘100u \\- è®°å½•ä¸‹å‘',
    'â€¢ æ˜¾ç¤ºè´¦å• æˆ– \\+0 \\- æŸ¥çœ‹è´¦å•',
    'â€¢ æ’¤é”€å…¥æ¬¾ / æ’¤é”€ä¸‹å‘ \\- æ’¤é”€è®°å½•',
    'â€¢ æŸ¥çœ‹å…¥æ¬¾å†å² / æŸ¥çœ‹ä¸‹å‘å†å² \\- æŸ¥çœ‹å†å²',
    '',
    '*âš™ï¸ è®¾ç½®åŠŸèƒ½*',
    'â€¢ æ˜¾ç¤ºæ¨¡å¼1\\-6 \\- è®¾ç½®æ˜¾ç¤ºç¬”æ•°',
    'â€¢ å•æ˜¾æ¨¡å¼ / åŒæ˜¾æ¨¡å¼ \\- å•/åŒå¸ç§æ˜¾ç¤º',
    'â€¢ è®¾ç½®æ±‡ç‡ 7\\.2 \\- å›ºå®šæ±‡ç‡ï¼›è®¾ç½®å®æ—¶æ±‡ç‡ \\- å®æ—¶æ±‡ç‡',
    'â€¢ è®¾ç½®è´§å¸ USD \\- åˆ‡æ¢å¸ç§',
    'â€¢ è®¾ç½®è´¹ç‡ 5 \\- æ‰‹ç»­è´¹ç‡',
    'â€¢ è®¾ç½®æ ‡é¢˜ xxx \\- è‡ªå®šä¹‰æ ‡é¢˜',
    'â€¢ è®¾ç½®è®°è´¦æ¨¡å¼ ç´¯è®¡æ¨¡å¼/æ¸…é›¶æ¨¡å¼/å•ç¬”è®¢å•',
    'â€¢ è®¾ç½®æ—¥åˆ‡æ—¶é—´ 2 \\- æ—¥åˆ‡æ—¶é—´',
    '',
    '*ğŸ‘¥ æƒé™ç®¡ç†*',
    'â€¢ æ·»åŠ æ“ä½œå‘˜ @ç”¨æˆ· \\- æ·»åŠ æ“ä½œå‘˜',
    'â€¢ åˆ é™¤æ“ä½œå‘˜ @ç”¨æˆ· \\- åˆ é™¤æ“ä½œå‘˜',
    'â€¢ æ˜¾ç¤ºæ“ä½œäºº \\- æŸ¥çœ‹æƒé™',
    'â€¢ å¼€å¯/å…³é—­æ‰€æœ‰åŠŸèƒ½ \\- åŠŸèƒ½å¼€å…³',
    'â€¢ å¼€å¯/å…³é—­åœ°å€éªŒè¯ \\- åœ°å€éªŒè¯',
    '',
    '*ğŸ§® è®¡ç®—å™¨*',
    'â€¢ 288\\*2ã€288/2 ç­‰ \\- æ•°å­¦è¡¨è¾¾å¼',
    'â€¢ æ‰“å¼€/å…³é—­è®¡ç®—å™¨ \\- è®¡ç®—å™¨å¼€å…³',
    '',
    '*ğŸ“Š è¥ä¸šç®¡ç†*',
    'â€¢ ä¸Šè¯¾ / å¼€å§‹ä¸Šè¯¾ \\- å¼€å§‹è¥ä¸š',
    'â€¢ ä¸‹è¯¾ \\- ç»“æŸè¥ä¸šå¹¶ç¦è¨€',
    'â€¢ è§£é™¤ç¦è¨€ / å¼€å£ \\- è§£é™¤ç¦è¨€',
    'â€¢ æŸ¥è¯¢å·¥æ—¶ \\- æŸ¥çœ‹è¥ä¸šæ—¶é•¿',
    '',
    '*ğŸ“¢ å¹¿æ’­åŠŸèƒ½*',
    'â€¢ å…¨å‘˜å¹¿æ’­ \\- å‘æ‰€æœ‰ç¾¤ç»„å¹¿æ’­',
    'â€¢ åˆ†ç»„å¹¿æ’­ åˆ†ç»„å \\- å‘æŒ‡å®šåˆ†ç»„å¹¿æ’­',
    'â€¢ åˆ†ç»„ç®¡ç† \\- ç®¡ç†åˆ†ç»„å’Œç¾¤ç»„',
    'â€¢ åˆ†ç»„åˆ—è¡¨ \\- æŸ¥çœ‹æ‰€æœ‰åˆ†ç»„',
    '',
    '*ğŸ” æŸ¥è¯¢åŠŸèƒ½*',
    'â€¢ z0 \\- OKXå®æ—¶Uä»·ï¼›z600u \\- è®¡ç®—600U',
    'â€¢ lz/lw/lk \\- æ”¯ä»˜å®/å¾®ä¿¡/é“¶è¡Œå¡Uä»·',
    'â€¢ æŸ¥ Tå¼€å¤´çš„åœ°å€ \\- æŸ¥è¯¢TRONåœ°å€',
    'â€¢ æŸ¥è¯¢æ±‡ç‡ \\- æŸ¥çœ‹æ±‡ç‡æ˜ å°„',
    '',
    '*ğŸ”§ å…¶ä»–åŠŸèƒ½*',
    'â€¢ æ·»åŠ è‡ªå®šä¹‰æŒ‡ä»¤ \\- è‡ªå®šä¹‰å‘½ä»¤',
    'â€¢ è®¾ç½®è‡ªå®šä¹‰å›¾ç‰‡ \\- è‡ªå®šä¹‰å›¾ç‰‡',
    'â€¢ ç¾¤åˆ—è¡¨ \\- æŸ¥çœ‹æ‰€åœ¨ç¾¤ç»„',
    'â€¢ æœºå™¨äººé€€ç¾¤ \\- é€€å‡ºç¾¤ç»„',
    '',
    '*â“ å¸®åŠ©*',
    'â€¢ ä½¿ç”¨è¯´æ˜ æˆ– /help \\- æ˜¾ç¤ºæ­¤å¸®åŠ©',
    'â€¢ /start \\- å¼€å§‹ä½¿ç”¨',
    '',
  ]

  return content.join('\n')
}

/**
 * æ³¨å†Œ help action
 */
export function registerHelp(bot) {
  bot.action('help', async (ctx) => {
    try {
      await ctx.answerCbQuery()
    } catch (e) {
      console.error('[help-action][answerCbQuery-error]', e)
    }

    try {
      // ğŸ”¥ ç§èŠå’Œç¾¤èŠéƒ½æ˜¾ç¤ºå®Œæ•´çš„ä½¿ç”¨è¯´æ˜ï¼ˆMarkdownV2æ ¼å¼ï¼‰
      const help = getHelpText()
      const inlineKb = await buildInlineKb(ctx)
      await ctx.reply(help, { 
        parse_mode: 'MarkdownV2', 
        ...inlineKb 
      })
    } catch (e) {
      console.error('[help-action][reply-error]', e)
      // å¦‚æœ MarkdownV2 å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨æ™®é€šæ–‡æœ¬
      try {
    const help = getHelpText()
        // ç§»é™¤ MarkdownV2 è½¬ä¹‰å­—ç¬¦
        const plainHelp = help.replace(/\\([\\_*\[\]()~`>#+\-=|{}.!])/g, '$1')
        await ctx.reply(plainHelp, { 
          ...(await buildInlineKb(ctx))
        })
      } catch (e2) {
        console.error('[help-action][fallback-error]', e2)
        await ctx.reply('âŒ å‘é€ä½¿ç”¨è¯´æ˜å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•').catch(() => {})
      }
    }
  })
}

/**
 * æ³¨å†Œä½¿ç”¨è¯´æ˜å‘½ä»¤
 */
export function registerHelpCommand(bot, ensureChat) {
  bot.hears(/^ä½¿ç”¨è¯´æ˜$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    const help = getHelpText()
    await ctx.reply(help, { parse_mode: 'MarkdownV2', ...(await buildInlineKb(ctx)) })
  })
}

/**
 * æ³¨å†Œ open_dashboard action
 */
export function registerDashboard(bot) {
  bot.action('open_dashboard', async (ctx) => {
    try { await ctx.answerCbQuery('å·²å‘é€é“¾æ¥') } catch { }
    if (!BACKEND_URL) return ctx.reply('æœªé…ç½®åå°åœ°å€ã€‚')
    const chatId = String(ctx.chat?.id || '')
    try {
      const u = new URL(BACKEND_URL)
      u.searchParams.set('chatId', chatId)
      await ctx.reply(`æŸ¥çœ‹å®Œæ•´è®¢å•ï¼š\n${u.toString()}`)
    } catch {
      await ctx.reply(`æŸ¥çœ‹å®Œæ•´è®¢å•ï¼š\n${BACKEND_URL}`)
    }
  })
}

/**
 * æ³¨å†ŒæŸ¥çœ‹è´¦å•å‘½ä»¤ï¼ˆå‘é€è´¦å•é“¾æ¥ï¼‰
 */
export function registerViewBill(bot, ensureChat) {
  bot.hears(/^æŸ¥çœ‹è´¦å•$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (!BACKEND_URL) {
      return ctx.reply('âŒ æœªé…ç½®åå°åœ°å€')
    }

    const chatId = String(ctx.chat?.id || '')
    try {
      const u = new URL(BACKEND_URL)
      u.searchParams.set('chatId', chatId)
      await ctx.reply(
        `ğŸ“Š æŸ¥çœ‹å®Œæ•´è´¦å•ï¼š\n${u.toString()}`,
        { ...(await buildInlineKb(ctx)) }
      )
    } catch {
      await ctx.reply(
        `ğŸ“Š æŸ¥çœ‹å®Œæ•´è´¦å•ï¼š\n${BACKEND_URL}`,
        { ...(await buildInlineKb(ctx)) }
      )
    }
  })
}

/**
 * æ³¨å†Œ command_menu actionï¼ˆç§èŠæ—¶"æŒ‡ä»¤èœå•"æŒ‰é’®å›è°ƒï¼‰
 */
export function registerCommandMenuAction(bot) {
  bot.action('command_menu', async (ctx) => {
    try { 
      await ctx.answerCbQuery() 
    } catch (e) {
      console.error('[command_menu][answerCbQuery]', e)
    }

    // åªåœ¨ç§èŠä¸­å¤„ç†
    if (ctx.chat?.type !== 'private') {
      return
    }

    try {
      // ğŸ”¥ å‘é€å®Œæ•´çš„ä½¿ç”¨è¯´æ˜ï¼ˆä¸ help action ä¸€è‡´ï¼ŒMarkdownV2æ ¼å¼ï¼‰
      const help = getHelpText()
      const inlineKb = await buildInlineKb(ctx)
      await ctx.reply(help, { 
        parse_mode: 'MarkdownV2', 
        ...inlineKb 
      })
    } catch (e) {
      console.error('[command_menu][reply-error]', e)
      // å¦‚æœ MarkdownV2 å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨æ™®é€šæ–‡æœ¬
      try {
    const help = getHelpText()
        // ç§»é™¤ MarkdownV2 è½¬ä¹‰å­—ç¬¦
        const plainHelp = help.replace(/\\([\\_*\[\]()~`>#+\-=|{}.!])/g, '$1')
        await ctx.reply(plainHelp, { 
          ...(await buildInlineKb(ctx))
        })
      } catch (e2) {
        console.error('[command_menu][fallback-error]', e2)
        await ctx.reply('âŒ å‘é€ä½¿ç”¨è¯´æ˜å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•').catch(() => {})
      }
    }
  })
}

// è´¦å•ç›¸å…³å‘½ä»¤å¤„ç†å™¨
import { prisma } from '../../lib/db.js'
import { getChat } from '../state.js'
import { ensureDbChat, getOrCreateTodayBill, deleteLastIncome, deleteLastDispatch, deleteIncomeByMessageId, deleteDispatchByMessageId, getChatDailyCutoffHour } from '../database.js'
import { buildInlineKb, hasPermissionWithWhitelist } from '../helpers.js'
import { formatSummary } from '../formatting.js'
import { getGlobalDailyCutoffHour } from '../utils.js'
import { startOfDay, endOfDay } from '../utils.js'

/**
 * æ˜¾ç¤ºè´¦å•
 */
export function registerShowBill(bot, ensureChat) {
  bot.hears(/^(æ˜¾ç¤ºè´¦å•|\+0)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
    await ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
  })
}

/**
 * ä¿å­˜è´¦å•
 */
export function registerSaveBill(bot, ensureChat) {
  bot.hears(/^ä¿å­˜è´¦å•$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)

    try {
      // ğŸ”¥ æ£€æŸ¥è®°è´¦æ¨¡å¼
      const settings = await prisma.setting.findUnique({
        where: { chatId },
        select: { accountingMode: true }
      })
      const accountingMode = settings?.accountingMode || 'DAILY_RESET'
      const isCumulativeMode = accountingMode === 'CARRY_OVER'
      const isSingleBillMode = accountingMode === 'SINGLE_BILL_PER_DAY'

      // ğŸ”¥ å•ç¬”è®¢å•æ¨¡å¼ï¼šä¸æ”¯æŒä¿å­˜è´¦å•
      if (isSingleBillMode) {
        return ctx.reply('âš ï¸ å½“å‰è®°è´¦æ¨¡å¼ä¸æ”¯æŒä¿å­˜è´¦å•ã€‚æ¯å¤©åªæœ‰ä¸€ç¬”è®¢å•ï¼Œæ—¥åˆ‡æ—¶ä¼šè‡ªåŠ¨å…³é—­ã€‚', { ...(await buildInlineKb(ctx)) })
      }

      const { bill } = await getOrCreateTodayBill(chatId)
      const now = new Date()

      // ğŸ”¥ ä¿å­˜è´¦å•ï¼šè®°å½•closedAtï¼ˆç»“æŸæ—¶é—´ï¼‰ï¼Œç„¶ååˆ›å»ºæ–°è´¦å•ï¼ˆä»¥å½“å‰æ—¶é—´ä½œä¸ºå¼€å§‹æ—¶é—´ï¼‰
      await prisma.bill.update({
        where: { id: bill.id },
        data: { status: 'CLOSED', closedAt: now, savedAt: now }
      })

      // æ¸…ç©ºå†…å­˜
      chat.history.push({
        savedAt: now,
        data: {
          incomes: [...chat.current.incomes],
          dispatches: [...chat.current.dispatches]
        }
      })
      chat.current.incomes = []
      chat.current.dispatches = []

      // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šä¿å­˜åè‡ªåŠ¨åˆ›å»ºæ–°çš„è´¦å•ï¼ˆä»¥å½“å‰æ—¶é—´ä½œä¸ºå¼€å§‹æ—¶é—´ï¼‰
      if (isCumulativeMode) {
        // ğŸ”¥ åˆ›å»ºæ–°è´¦å•ï¼Œä»¥å½“å‰æ—¶é—´ä½œä¸ºå¼€å§‹æ—¶é—´
        await prisma.bill.create({
          data: {
            chatId,
            status: 'OPEN',
            openedAt: now, // ğŸ”¥ ä»¥å½“å‰æ—¶é—´ä½œä¸ºå¼€å§‹æ—¶é—´
            savedAt: now
          }
        })
        await ctx.reply('âœ… è´¦å•å·²ä¿å­˜ï¼Œå·²è‡ªåŠ¨åˆ›å»ºæ–°çš„è´¦å•', { ...(await buildInlineKb(ctx)) })
      } else {
        await ctx.reply('âœ… è´¦å•å·²ä¿å­˜å¹¶æ¸…ç©º', { ...(await buildInlineKb(ctx)) })
      }
    } catch (e) {
      console.error('ä¿å­˜è´¦å•å¤±è´¥', e)
      await ctx.reply('âŒ ä¿å­˜è´¦å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * åˆ é™¤è´¦å•ï¼ˆæ¸…ç©ºå½“å‰ï¼Œä¸ä¿å­˜ï¼‰
 * ğŸ”¥ æ”¯æŒåˆ é™¤ç¡®è®¤åŠŸèƒ½ï¼ˆå¦‚æœåå°è®¾ç½®äº†deleteBillConfirmï¼‰
 */
export function registerDeleteBill(bot, ensureChat) {
  bot.hears(/^åˆ é™¤è´¦å•$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)

    try {
      // ğŸ”¥ æ£€æŸ¥æ˜¯å¦éœ€è¦ç¡®è®¤
      const setting = await prisma.setting.findUnique({
        where: { chatId },
        select: { deleteBillConfirm: true }
      })

      if (setting?.deleteBillConfirm) {
        // éœ€è¦äºŒæ¬¡ç¡®è®¤ï¼Œå…ˆæç¤ºç”¨æˆ·
        const { Markup } = await import('telegraf')
        const keyboard = Markup.inlineKeyboard([
          [Markup.button.callback('âœ… ç¡®è®¤åˆ é™¤', 'confirm_delete_bill')],
          [Markup.button.callback('âŒ å–æ¶ˆ', 'cancel_delete_bill')]
        ])

        // ğŸ”¥ ä½¿ç”¨ä¸´æ—¶å­˜å‚¨ï¼ˆMapï¼‰æ¥å­˜å‚¨å¾…åˆ é™¤çš„chatIdï¼Œé¿å…sessioné—®é¢˜
        // æ ¼å¼ï¼šuserId_chatId -> true
        const deletePendingKey = `${ctx.from?.id}_${chatId}`
        if (!global.pendingDeleteBills) {
          global.pendingDeleteBills = new Map()
        }
        global.pendingDeleteBills.set(deletePendingKey, { chatId, userId: ctx.from?.id, timestamp: Date.now() })

        await ctx.reply(
          'âš ï¸ *åˆ é™¤ç¡®è®¤*\n\nç¡®å®šè¦åˆ é™¤å½“å‰è´¦å•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼\n\nç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ç¡®è®¤æˆ–å–æ¶ˆï¼š',
          { ...keyboard, parse_mode: 'Markdown' }
        )
        return
      }

      // ğŸ”¥ ä¼˜åŒ–ï¼šå…ˆæŸ¥è¯¢å½“å‰è´¦å•ï¼Œä¸è¦è‡ªåŠ¨åˆ›å»ºï¼ˆé¿å…åˆ é™¤åç«‹å³åˆ›å»ºæ–°è´¦å•ï¼‰
      const cutoffHour = await getChatDailyCutoffHour(chatId)
      const now = new Date()
      const todayCutoff = new Date()
      todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
      todayCutoff.setHours(cutoffHour, 0, 0, 0)

      let gte, lt
      if (now >= todayCutoff) {
        gte = new Date(todayCutoff)
        lt = new Date(todayCutoff)
        lt.setDate(lt.getDate() + 1)
      } else {
        gte = new Date(todayCutoff)
        gte.setDate(gte.getDate() - 1)
        lt = new Date(todayCutoff)
      }

      // ğŸ”¥ æŸ¥è¯¢å½“å‰è´¦å•ï¼ˆä¸è‡ªåŠ¨åˆ›å»ºï¼‰
      const bill = await prisma.bill.findFirst({
        where: { chatId, status: 'OPEN', openedAt: { gte, lt } },
        orderBy: { openedAt: 'asc' }
      })

      if (!bill) {
        // å¦‚æœæ²¡æœ‰è´¦å•ï¼Œç›´æ¥æ¸…ç©ºå†…å­˜å³å¯
        chat.current.incomes = []
        chat.current.dispatches = []
        return ctx.reply('âœ… å½“å‰æ²¡æœ‰è´¦å•', { ...(await buildInlineKb(ctx)) })
      }

      // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šåˆ é™¤è´¦å•å’Œæ‰€æœ‰è´¦å•é¡¹ï¼Œç¡®ä¿è¯¥è´¦å•ä¸å†è®¡å…¥å…¶ä»–è´¦å•çš„å†å²æ•°æ®
      // ğŸ”¥ æ¸…é›¶æ¨¡å¼ï¼šåªåˆ é™¤è´¦å•é¡¹ï¼Œä¿ç•™è´¦å•ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
      const settings = await prisma.setting.findUnique({
        where: { chatId },
        select: { accountingMode: true }
      })
      const isCumulativeMode = settings?.accountingMode === 'CARRY_OVER'

      if (isCumulativeMode) {
        // ç´¯è®¡æ¨¡å¼ï¼šå®Œå…¨åˆ é™¤è´¦å•ï¼ˆä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§ï¼‰
        await prisma.$transaction(async (tx) => {
          await tx.billItem.deleteMany({ where: { billId: bill.id } })
          await tx.bill.delete({ where: { id: bill.id } })
        })
      } else {
        // æ¸…é›¶æ¨¡å¼ï¼šåªåˆ é™¤è´¦å•é¡¹
        await prisma.billItem.deleteMany({ where: { billId: bill.id } })
      }

      chat.current.incomes = []
      chat.current.dispatches = []

      // ğŸ”¥ åˆ é™¤è´¦å•åï¼Œé‡æ–°æ˜¾ç¤ºè´¦å•æ‘˜è¦ï¼ˆç¡®ä¿å†å²æœªä¸‹å‘æ­£ç¡®æ›´æ–°ï¼‰
      try {
        const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
        await ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
      } catch (e) {
        console.error('[åˆ é™¤è´¦å•] æ˜¾ç¤ºæ‘˜è¦å¤±è´¥', e)
        await ctx.reply('âœ… å½“å‰è´¦å•å·²æ¸…ç©º', { ...(await buildInlineKb(ctx)) })
      }
    } catch (e) {
      console.error('åˆ é™¤è´¦å•å¤±è´¥', e)
      await ctx.reply('âŒ åˆ é™¤è´¦å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })

  // ğŸ”¥ ç¡®è®¤åˆ é™¤æŒ‰é’®
  bot.action('confirm_delete_bill', async (ctx) => {
    try { await ctx.answerCbQuery() } catch { }

    const chat = ensureChat(ctx)
    if (!chat) return

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    // ğŸ”¥ ä»ä¸´æ—¶å­˜å‚¨ä¸­è·å–chatId
    const chatId = String(ctx.chat?.id || '')
    const userId = ctx.from?.id
    const deletePendingKey = `${userId}_${chatId}`

    if (!global.pendingDeleteBills) {
      return ctx.reply('âŒ æ“ä½œå·²è¿‡æœŸï¼Œè¯·é‡æ–°å‘é€"åˆ é™¤è´¦å•"')
    }

    const pendingInfo = global.pendingDeleteBills.get(deletePendingKey)
    if (!pendingInfo || (Date.now() - pendingInfo.timestamp > 5 * 60 * 1000)) {
      // è¶…è¿‡5åˆ†é’Ÿï¼Œæ¸…é™¤è¿‡æœŸè®°å½•
      global.pendingDeleteBills.delete(deletePendingKey)
      return ctx.reply('âŒ æ“ä½œå·²è¿‡æœŸï¼Œè¯·é‡æ–°å‘é€"åˆ é™¤è´¦å•"')
    }

    // ğŸ”¥ ä½¿ç”¨pendingInfoä¸­çš„chatIdï¼ˆæ›´å¯é ï¼‰
    const finalChatId = pendingInfo.chatId || chatId

    try {
      // ğŸ”¥ ä¼˜åŒ–ï¼šå…ˆæŸ¥è¯¢å½“å‰è´¦å•ï¼Œä¸è¦è‡ªåŠ¨åˆ›å»ºï¼ˆé¿å…åˆ é™¤åç«‹å³åˆ›å»ºæ–°è´¦å•ï¼‰
      const cutoffHour = await getChatDailyCutoffHour(finalChatId)
      const now = new Date()
      const todayCutoff = new Date()
      todayCutoff.setFullYear(now.getFullYear(), now.getMonth(), now.getDate())
      todayCutoff.setHours(cutoffHour, 0, 0, 0)

      let gte, lt
      if (now >= todayCutoff) {
        gte = new Date(todayCutoff)
        lt = new Date(todayCutoff)
        lt.setDate(lt.getDate() + 1)
      } else {
        gte = new Date(todayCutoff)
        gte.setDate(gte.getDate() - 1)
        lt = new Date(todayCutoff)
      }

      // ğŸ”¥ æŸ¥è¯¢å½“å‰è´¦å•ï¼ˆä¸è‡ªåŠ¨åˆ›å»ºï¼‰
      const bill = await prisma.bill.findFirst({
        where: { chatId: finalChatId, status: 'OPEN', openedAt: { gte, lt } },
        orderBy: { openedAt: 'asc' }
      })

      if (!bill) {
        // å¦‚æœæ²¡æœ‰è´¦å•ï¼Œç›´æ¥æ¸…ç©ºå†…å­˜å³å¯
        chat.current.incomes = []
        chat.current.dispatches = []
        // ğŸ”¥ æ¸…é™¤å¾…åˆ é™¤æ ‡è®°
        if (global.pendingDeleteBills) {
          global.pendingDeleteBills.delete(deletePendingKey)
        }
        await ctx.reply('âœ… å½“å‰æ²¡æœ‰è´¦å•', { ...(await buildInlineKb(ctx)) })
        await ctx.deleteMessage().catch(() => { })
        return
      }

      // ğŸ”¥ ç´¯è®¡æ¨¡å¼ï¼šåˆ é™¤è´¦å•å’Œæ‰€æœ‰è´¦å•é¡¹ï¼Œç¡®ä¿è¯¥è´¦å•ä¸å†è®¡å…¥å…¶ä»–è´¦å•çš„å†å²æ•°æ®
      // ğŸ”¥ æ¸…é›¶æ¨¡å¼ï¼šåªåˆ é™¤è´¦å•é¡¹ï¼Œä¿ç•™è´¦å•ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
      const settings = await prisma.setting.findUnique({
        where: { chatId: finalChatId },
        select: { accountingMode: true }
      })
      const isCumulativeMode = settings?.accountingMode === 'CARRY_OVER'

      if (isCumulativeMode) {
        // ç´¯è®¡æ¨¡å¼ï¼šå®Œå…¨åˆ é™¤è´¦å•ï¼ˆä½¿ç”¨äº‹åŠ¡ç¡®ä¿åŸå­æ€§ï¼‰
        await prisma.$transaction(async (tx) => {
          await tx.billItem.deleteMany({ where: { billId: bill.id } })
          await tx.bill.delete({ where: { id: bill.id } })
        })
      } else {
        // æ¸…é›¶æ¨¡å¼ï¼šåªåˆ é™¤è´¦å•é¡¹
        await prisma.billItem.deleteMany({ where: { billId: bill.id } })
      }

      chat.current.incomes = []
      chat.current.dispatches = []

      // ğŸ”¥ æ¸…é™¤å¾…åˆ é™¤æ ‡è®°
      if (global.pendingDeleteBills) {
        global.pendingDeleteBills.delete(deletePendingKey)
      }

      await ctx.reply('âœ… å½“å‰è´¦å•å·²æ¸…ç©º', { ...(await buildInlineKb(ctx)) })
      await ctx.deleteMessage().catch(() => { })
    } catch (e) {
      console.error('åˆ é™¤è´¦å•å¤±è´¥', e)
      await ctx.reply('âŒ åˆ é™¤è´¦å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })

  // ğŸ”¥ å–æ¶ˆåˆ é™¤æŒ‰é’®
  bot.action('cancel_delete_bill', async (ctx) => {
    try { await ctx.answerCbQuery() } catch { }

    // ğŸ”¥ æ¸…é™¤å¾…åˆ é™¤æ ‡è®°
    const chatId = String(ctx.chat?.id || '')
    const userId = ctx.from?.id
    if (global.pendingDeleteBills && userId) {
      global.pendingDeleteBills.delete(`${userId}_${chatId}`)
    }

    await ctx.reply('å·²å–æ¶ˆåˆ é™¤æ“ä½œ', { ...(await buildInlineKb(ctx)) })
    await ctx.deleteMessage().catch(() => { })
  })
}

/**
 * åˆ é™¤å…¨éƒ¨è´¦å•
 */
export function registerDeleteAllBills(bot, ensureChat) {
  bot.hears(/^(åˆ é™¤å…¨éƒ¨è´¦å•|æ¸…é™¤å…¨éƒ¨è´¦å•)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)

    try {
      const allBills = await prisma.bill.findMany({ where: { chatId }, select: { id: true } })
      const billIds = allBills.map(b => b.id)

      await Promise.all([
        prisma.billItem.deleteMany({ where: { billId: { in: billIds } } }),
        prisma.bill.deleteMany({ where: { id: { in: billIds } } })
      ])

      chat.current = { incomes: [], dispatches: [] }
      chat.history = []

      await ctx.reply(`âš ï¸ å·²åˆ é™¤å…¨éƒ¨è´¦å•ï¼ˆå…± ${allBills.length} æ¡è´¦å•è®°å½•ï¼‰\n\nè¯·è°¨æ…ä½¿ç”¨æ­¤åŠŸèƒ½ï¼`)
    } catch (e) {
      console.error('åˆ é™¤å…¨éƒ¨è´¦å•å¤±è´¥', e)
      await ctx.reply('âŒ åˆ é™¤å…¨éƒ¨è´¦å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * æ˜¾ç¤ºå†å²è´¦å•
 */
export function registerShowHistory(bot, ensureChat) {
  bot.hears(/^æ˜¾ç¤ºå†å²è´¦å•$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (chat.history.length === 0) {
      return ctx.reply('æš‚æ— å†å²è´¦å•')
    }

    const lines = chat.history.slice(-5).map((h, i) => {
      const incomes = h.data.incomes.length
      const dispatches = h.data.dispatches.length
      return `#${chat.history.length - (chat.history.length - i - 1)} ä¿å­˜æ—¶é—´: ${new Date(h.savedAt).toLocaleString()} å…¥æ¬¾:${incomes} ä¸‹å‘:${dispatches}`
    })
    await ctx.reply(['æœ€è¿‘å†å²è´¦å•ï¼ˆæœ€å¤š5æ¡ï¼‰ï¼š', ...lines].join('\n'))
  })
}

/**
 * æŸ¥çœ‹å†å²å…¥æ¬¾è®°å½•ï¼ˆæœ€å¤š500æ¡ï¼‰
 */
export function registerShowIncomeHistory(bot, ensureChat) {
  bot.hears(/^æŸ¥çœ‹å…¥æ¬¾å†å²$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const { bill } = await getOrCreateTodayBill(chatId)
    if (!bill) {
      return ctx.reply('âŒ æœªæ‰¾åˆ°è´¦å•')
    }

    // ğŸ”¥ æŸ¥è¯¢æœ€å¤š500æ¡å†å²è®°å½•
    const items = await prisma.billItem.findMany({
      where: { billId: bill.id, type: 'INCOME' },
      select: {
        id: true,
        amount: true,
        rate: true,
        usdt: true,
        displayName: true,
        messageId: true,
        createdAt: true,
      },
      orderBy: { createdAt: 'desc' },
      take: 500
    })

    if (items.length === 0) {
      return ctx.reply('æš‚æ— å…¥æ¬¾è®°å½•')
    }

    // æ ¼å¼åŒ–æ˜¾ç¤ºï¼ˆæœ€å¤šæ˜¾ç¤ºæœ€è¿‘50æ¡ï¼Œé¿å…æ¶ˆæ¯è¿‡é•¿ï¼‰
    const displayItems = items.slice(0, 50)
    const lines = displayItems.map((item, index) => {
      const time = new Date(item.createdAt).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
      const amount = Number(item.amount || 0)
      const rate = item.rate ? Number(item.rate) : null
      const usdt = rate ? Number((Math.abs(amount) / rate).toFixed(1)) : (item.usdt ? Number(item.usdt) : 0)
      const name = item.displayName || 'ç”¨æˆ·'
      return `${index + 1}. ${time} ${amount > 0 ? '+' : ''}${amount}${rate ? ` / ${rate}=${usdt}U` : ''} ${name}`
    })

    const totalText = items.length > 50 
      ? `æœ€è¿‘50æ¡ï¼ˆå…±${items.length}æ¡ï¼Œæœ€å¤šæ”¯æŒ500æ¡ï¼‰ï¼š\n\n${lines.join('\n')}\n\nğŸ’¡ æç¤ºï¼šå›å¤æ¶ˆæ¯è¾“å…¥"æ’¤é”€å…¥æ¬¾"å¯æ’¤é”€å¯¹åº”è®°å½•`
      : `å…±${items.length}æ¡è®°å½•ï¼š\n\n${lines.join('\n')}\n\nğŸ’¡ æç¤ºï¼šå›å¤æ¶ˆæ¯è¾“å…¥"æ’¤é”€å…¥æ¬¾"å¯æ’¤é”€å¯¹åº”è®°å½•`

    await ctx.reply(totalText, { parse_mode: 'MarkdownV2' })
  })
}

/**
 * æŸ¥çœ‹å†å²ä¸‹å‘è®°å½•ï¼ˆæœ€å¤š500æ¡ï¼‰
 */
export function registerShowDispatchHistory(bot, ensureChat) {
  bot.hears(/^æŸ¥çœ‹ä¸‹å‘å†å²$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const { bill } = await getOrCreateTodayBill(chatId)
    if (!bill) {
      return ctx.reply('âŒ æœªæ‰¾åˆ°è´¦å•')
    }

    // ğŸ”¥ æŸ¥è¯¢æœ€å¤š500æ¡å†å²è®°å½•
    const items = await prisma.billItem.findMany({
      where: { billId: bill.id, type: 'DISPATCH' },
      select: {
        id: true,
        amount: true,
        usdt: true,
        displayName: true,
        messageId: true,
        createdAt: true,
      },
      orderBy: { createdAt: 'desc' },
      take: 500
    })

    if (items.length === 0) {
      return ctx.reply('æš‚æ— ä¸‹å‘è®°å½•')
    }

    // æ ¼å¼åŒ–æ˜¾ç¤ºï¼ˆæœ€å¤šæ˜¾ç¤ºæœ€è¿‘50æ¡ï¼Œé¿å…æ¶ˆæ¯è¿‡é•¿ï¼‰
    const displayItems = items.slice(0, 50)
    const lines = displayItems.map((item, index) => {
      const time = new Date(item.createdAt).toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
      const amount = Number(item.amount || 0)
      const usdt = Number(item.usdt || 0)
      const name = item.displayName || 'ç”¨æˆ·'
      return `${index + 1}. ${time} ${amount} (${usdt}U) ${name}`
    })

    const totalText = items.length > 50 
      ? `æœ€è¿‘50æ¡ï¼ˆå…±${items.length}æ¡ï¼Œæœ€å¤šæ”¯æŒ500æ¡ï¼‰ï¼š\n\n${lines.join('\n')}\n\nğŸ’¡ æç¤ºï¼šå›å¤æ¶ˆæ¯è¾“å…¥"æ’¤é”€ä¸‹å‘"å¯æ’¤é”€å¯¹åº”è®°å½•`
      : `å…±${items.length}æ¡è®°å½•ï¼š\n\n${lines.join('\n')}\n\nğŸ’¡ æç¤ºï¼šå›å¤æ¶ˆæ¯è¾“å…¥"æ’¤é”€ä¸‹å‘"å¯æ’¤é”€å¯¹åº”è®°å½•`

    await ctx.reply(totalText, { parse_mode: 'MarkdownV2' })
  })
}

/**
 * æ’¤é”€å…¥æ¬¾
 * ğŸ”¥ æ”¯æŒå›å¤æ¶ˆæ¯æ’¤é”€æŒ‡å®šè®°å½•ï¼Œå¦‚æœæ²¡æœ‰å›å¤åˆ™æ’¤é”€æœ€åä¸€æ¡
 * ğŸ”¥ æ”¯æŒæ’¤é”€æœ€å¤š500æ¡å†å²è®°å½•
 */
export function registerUndoIncome(bot, ensureChat) {
  bot.hears(/^æ’¤é”€å…¥æ¬¾$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    
    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰å›å¤æ¶ˆæ¯
    const replyToMessage = ctx.message.reply_to_message
    let result = null
    
    if (replyToMessage && replyToMessage.message_id) {
      // å¦‚æœæœ‰å›å¤ï¼Œé€šè¿‡ messageId åˆ é™¤å¯¹åº”çš„è®°å½•
      result = await deleteIncomeByMessageId(chatId, replyToMessage.message_id)
      if (!result) {
        return ctx.reply('âŒ æœªæ‰¾åˆ°å¯¹åº”çš„å…¥æ¬¾è®°å½•ï¼ˆå¯èƒ½è¯¥æ¶ˆæ¯ä¸æ˜¯å…¥æ¬¾è®°å½•ï¼‰')
      }
    } else {
      // å¦‚æœæ²¡æœ‰å›å¤ï¼Œåˆ é™¤æœ€åä¸€æ¡
      result = await deleteLastIncome(chatId)
    if (!result) {
      return ctx.reply('âŒ æ²¡æœ‰å¯æ’¤é”€çš„å…¥æ¬¾è®°å½•')
    }
    }

    // ä»å†…å­˜ä¸­ç§»é™¤ï¼Œå¹¶ä¸æ•°æ®åº“é‡æ–°åŒæ­¥ï¼Œé¿å…å…¶å®ƒè®°å½•è¢«è¯¯åˆ /ä¸¢å¤±
    try {
      // å…ˆä»æ•°æ®åº“å®Œæ•´æ‹‰å–å½“å‰è´¦å•çš„æ‰€æœ‰ INCOME è®°å½•ï¼Œä½œä¸ºæƒå¨æ•°æ®
      const { bill } = await getOrCreateTodayBill(chatId)
      if (bill) {
        const items = await prisma.billItem.findMany({
          where: { billId: bill.id, type: 'INCOME' },
          orderBy: { createdAt: 'asc' },
          select: {
            amount: true,
            rate: true,
            usdt: true,
            replier: true,
            operator: true,
            displayName: true,
            userId: true,
            messageId: true,
            createdAt: true,
          },
        })

        chat.current.incomes = items.map((i) => ({
          amount: Number(i.amount || 0),
          rate: i.rate != null ? Number(i.rate) : undefined,
          createdAt: new Date(i.createdAt),
          replier: i.replier || '',
          operator: i.operator || '',
          displayName: i.displayName || null,
          userId: i.userId ? Number(i.userId) : null,
          messageId: i.messageId || null,
        }))
      }
      // è®©åç»­çš„ formatSummary è®¤ä¸ºéœ€è¦é‡æ–°åŒæ­¥ä¸€æ¬¡ï¼ˆé˜²æ­¢æ—§ç¼“å­˜å½±å“ï¼‰
      chat._billLastSync = 0
    } catch (e) {
      console.error('[æ’¤é”€å…¥æ¬¾][sync-from-db-failed]', e)
    }

    const message = replyToMessage 
      ? `âœ… å·²æ’¤é”€æŒ‡å®šçš„å…¥æ¬¾è®°å½•ï¼š${result.amount}`
      : `âœ… å·²æ’¤é”€æœ€åä¸€æ¡å…¥æ¬¾ï¼š${result.amount}`
    await ctx.reply(message, { ...(await buildInlineKb(ctx)) })
  })
}

/**
 * æ’¤é”€ä¸‹å‘
 * ğŸ”¥ æ”¯æŒå›å¤æ¶ˆæ¯æ’¤é”€æŒ‡å®šè®°å½•ï¼Œå¦‚æœæ²¡æœ‰å›å¤åˆ™æ’¤é”€æœ€åä¸€æ¡
 */
export function registerUndoDispatch(bot, ensureChat) {
  bot.hears(/^æ’¤é”€ä¸‹å‘$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    
    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰å›å¤æ¶ˆæ¯
    const replyToMessage = ctx.message.reply_to_message
    let result = null
    
    if (replyToMessage && replyToMessage.message_id) {
      // å¦‚æœæœ‰å›å¤ï¼Œé€šè¿‡ messageId åˆ é™¤å¯¹åº”çš„è®°å½•
      result = await deleteDispatchByMessageId(chatId, replyToMessage.message_id)
      if (!result) {
        return ctx.reply('âŒ æœªæ‰¾åˆ°å¯¹åº”çš„ä¸‹å‘è®°å½•ï¼ˆå¯èƒ½è¯¥æ¶ˆæ¯ä¸æ˜¯ä¸‹å‘è®°å½•ï¼‰')
      }
    } else {
      // å¦‚æœæ²¡æœ‰å›å¤ï¼Œåˆ é™¤æœ€åä¸€æ¡
      result = await deleteLastDispatch(chatId)
    if (!result) {
      return ctx.reply('âŒ æ²¡æœ‰å¯æ’¤é”€çš„ä¸‹å‘è®°å½•')
    }
    }

    // ä»å†…å­˜ä¸­ç§»é™¤ï¼Œå¹¶ä¸æ•°æ®åº“é‡æ–°åŒæ­¥
    try {
      // å…ˆä»æ•°æ®åº“å®Œæ•´æ‹‰å–å½“å‰è´¦å•çš„æ‰€æœ‰ DISPATCH è®°å½•ï¼Œä½œä¸ºæƒå¨æ•°æ®
      const { bill } = await getOrCreateTodayBill(chatId)
      if (bill) {
        const items = await prisma.billItem.findMany({
          where: { billId: bill.id, type: 'DISPATCH' },
          orderBy: { createdAt: 'asc' },
          select: {
            amount: true,
            usdt: true,
            replier: true,
            operator: true,
            displayName: true,
            userId: true,
            messageId: true,
            createdAt: true,
          },
        })

        chat.current.dispatches = items.map((i) => ({
          amount: Number(i.amount || 0),
          usdt: Number(i.usdt || 0),
          createdAt: new Date(i.createdAt),
          replier: i.replier || '',
          operator: i.operator || '',
          displayName: i.displayName || null,
          userId: i.userId ? Number(i.userId) : null,
          messageId: i.messageId || null,
        }))
      }
      // è®©åç»­çš„ formatSummary è®¤ä¸ºéœ€è¦é‡æ–°åŒæ­¥ä¸€æ¬¡ï¼ˆé˜²æ­¢æ—§ç¼“å­˜å½±å“ï¼‰
      chat._billLastSync = 0
    } catch (e) {
      console.error('[æ’¤é”€ä¸‹å‘][sync-from-db-failed]', e)
      // å¦‚æœåŒæ­¥å¤±è´¥ï¼Œè‡³å°‘ä»å†…å­˜ä¸­ç§»é™¤æœ€åä¸€æ¡
    if (chat.current.dispatches.length > 0) {
      chat.current.dispatches.pop()
      }
    }

    const message = replyToMessage 
      ? `âœ… å·²æ’¤é”€æŒ‡å®šçš„ä¸‹å‘è®°å½•ï¼š${result.usdt}U`
      : `âœ… å·²æ’¤é”€æœ€åä¸€æ¡ä¸‹å‘ï¼š${result.usdt}U`
    await ctx.reply(message, { ...(await buildInlineKb(ctx)) })
  })
}

/**
 * ğŸ”¥ å…¨éƒ¨è´¦å•ï¼šæ€»
 */
export function registerAllBill(bot, ensureChat) {
  bot.hears(/^æ€»$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    const chatId = await ensureDbChat(ctx, chat)

    try {
      // è·å–æ‰€æœ‰è´¦å•ï¼ˆåŒ…æ‹¬OPENå’ŒCLOSEDï¼‰
      const allBills = await prisma.bill.findMany({
        where: { chatId },
        include: {
          items: {
            select: {
              type: true,
              amount: true,
              rate: true,
              usdt: true,
              feeRate: true,
              remark: true,
              replier: true,
              operator: true,
              createdAt: true
            },
            orderBy: { createdAt: 'asc' }
          }
        },
        orderBy: { openedAt: 'asc' }
      })

      if (allBills.length === 0) {
        return ctx.reply('æš‚æ— è´¦å•è®°å½•', { ...(await buildInlineKb(ctx)) })
      }

      // æ±‡æ€»æ‰€æœ‰è´¦å•
      let totalIncome = 0
      let totalDispatch = 0
      let totalIncomeUSDT = 0
      let totalDispatchUSDT = 0
      const allIncomes = []
      const allDispatches = []

      for (const bill of allBills) {
        for (const item of bill.items) {
          const amount = Number(item.amount || 0)
          const usdt = Number(item.usdt || 0)

          if (item.type === 'INCOME') {
            totalIncome += amount
            totalIncomeUSDT += usdt
            allIncomes.push(item)
          } else {
            totalDispatch += amount
            totalDispatchUSDT += usdt
            allDispatches.push(item)
          }
        }
      }

      // ğŸ”¥ ä¼˜åŒ–ï¼šåˆå¹¶æŸ¥è¯¢ï¼Œå‡å°‘æ•°æ®åº“è®¿é—®
      const { getEffectiveRate } = await import('../helpers.js')
      const [settings, effectiveRate] = await Promise.all([
        prisma.setting.findUnique({
          where: { chatId },
          select: { feePercent: true }
        }),
        getEffectiveRate(chatId, chat).then(r => r ?? 0)
      ])

      const feePercent = settings?.feePercent ?? 0
      const rate = effectiveRate
      const fee = (totalIncome * feePercent) / 100
      const shouldDispatch = totalIncome - fee
      const shouldDispatchUSDT = rate ? Number((shouldDispatch / rate).toFixed(1)) : 0

      const lines = []
      lines.push('ğŸ“Š *å…¨éƒ¨è´¦å•æ±‡æ€»*\n')
      lines.push(`å…¥æ¬¾ï¼ˆ${allIncomes.length}ç¬”ï¼‰ï¼š${totalIncome.toFixed(2)} å…ƒ`)
      if (totalIncomeUSDT > 0) {
        lines.push(`å…¥æ¬¾USDTï¼š${totalIncomeUSDT.toFixed(1)} U`)
      }
      lines.push(`ä¸‹å‘ï¼ˆ${allDispatches.length}ç¬”ï¼‰ï¼š${totalDispatch.toFixed(2)} å…ƒ`)
      if (totalDispatchUSDT > 0) {
        lines.push(`ä¸‹å‘USDTï¼š${totalDispatchUSDT.toFixed(1)} U`)
      }
      if (feePercent > 0) {
        lines.push(`æ‰‹ç»­è´¹ï¼š${fee.toFixed(2)} å…ƒï¼ˆ${feePercent}%ï¼‰`)
      }
      lines.push(`åº”ä¸‹å‘ï¼š${shouldDispatch.toFixed(2)} å…ƒ`)
      if (shouldDispatchUSDT > 0) {
        lines.push(`åº”ä¸‹å‘USDTï¼š${shouldDispatchUSDT.toFixed(1)} U`)
      }
      lines.push(`å·²ä¸‹å‘ï¼š${totalDispatch.toFixed(2)} å…ƒ`)
      if (totalDispatchUSDT > 0) {
        lines.push(`å·²ä¸‹å‘USDTï¼š${totalDispatchUSDT.toFixed(1)} U`)
      }
      lines.push(`æœªä¸‹å‘ï¼š${(shouldDispatch - totalDispatch).toFixed(2)} å…ƒ`)
      if (shouldDispatchUSDT > 0) {
        lines.push(`æœªä¸‹å‘USDTï¼š${(shouldDispatchUSDT - totalDispatchUSDT).toFixed(1)} U`)
      }

      await ctx.reply(lines.join('\n'), {
        ...(await buildInlineKb(ctx)),
        parse_mode: 'Markdown'
      })
    } catch (e) {
      console.error('æŸ¥è¯¢å…¨éƒ¨è´¦å•å¤±è´¥', e)
      await ctx.reply('âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * æˆ‘çš„è´¦å•
 */
export function registerMyBill(bot, ensureChat) {
  bot.hears(/^(æˆ‘çš„è´¦å•|\/æˆ‘)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    const chatId = await ensureDbChat(ctx, chat)
    const userId = String(ctx.from?.id || '')
    const username = ctx.from?.username ? `@${ctx.from.username}` : null

    try {
      const { bill } = await getOrCreateTodayBill(chatId)

      const items = await prisma.billItem.findMany({
        where: {
          billId: bill.id,
          OR: [
            username ? { operator: username } : undefined,
            username ? { replier: username.replace('@', '') } : undefined,
            { operator: { contains: userId } },
            { replier: { contains: userId } }
          ].filter(Boolean)
        },
        orderBy: { createdAt: 'desc' },
        take: 50 // é™åˆ¶æŸ¥è¯¢æ•°é‡ï¼Œä¼˜åŒ–æ€§èƒ½
      })

      if (items.length === 0) {
        return ctx.reply('âŒ æ‚¨åœ¨æœ¬ç¾¤æš‚æ— è®°è´¦è®°å½•')
      }

      const lines = []
      lines.push(`ğŸ“‹ æ‚¨çš„è´¦å•è®°å½•ï¼ˆå…± ${items.length} æ¡ï¼‰ï¼š\n`)

      let totalIncome = 0
      let totalDispatch = 0
      let totalUSDT = 0

      items.forEach(item => {
        const amount = Number(item.amount || 0)
        const usdt = Number(item.usdt || 0)
        const isIncome = item.type === 'INCOME'
        const remark = item.remark // ğŸ”¥ è·å–å¤‡æ³¨

        if (isIncome) {
          totalIncome += amount
          let line = ''
          if (item.rate) {
            line = `ğŸ’° +${amount} / ${item.rate}=${usdt.toFixed(1)}U`
          } else {
            line = `ğŸ’° +${amount}${usdt > 0 ? ` (${usdt.toFixed(1)}U)` : ''}`
          }
          // ğŸ”¥ å¦‚æœæœ‰å¤‡æ³¨ï¼Œåœ¨è´¦å•åé¢æ˜¾ç¤ºå¤‡æ³¨
          if (remark) {
            line += ` [${remark}]`
          }
          lines.push(line)
        } else {
          totalDispatch += amount
          totalUSDT += usdt
          lines.push(`ğŸ“¤ ä¸‹å‘ ${usdt.toFixed(1)}U (${amount})`)
        }
      })

      // ğŸ”¥ è®¡ç®—æ€»å…¥æ¬¾çš„USDT
      const { getEffectiveRate } = await import('../helpers.js')
      const effectiveRate = await getEffectiveRate(chatId, chat)
      const totalIncomeUSDT = effectiveRate ? (totalIncome / effectiveRate).toFixed(1) : '0'

      lines.push(`\nğŸ“Š æ±‡æ€»ï¼š`)
      lines.push(`å…¥æ¬¾ï¼š${totalIncome.toFixed(2)} (${totalIncomeUSDT}U)`) // ğŸ”¥ æ˜¾ç¤ºå…¥æ¬¾çš„U
      if (totalDispatch > 0 || totalUSDT > 0) {
        lines.push(`ä¸‹å‘ï¼š${totalDispatch.toFixed(2)} (${totalUSDT.toFixed(1)}U)`)
      }

      await ctx.reply(lines.join('\n'), { parse_mode: 'Markdown' })
    } catch (e) {
      console.error('æŸ¥è¯¢æˆ‘çš„è´¦å•å¤±è´¥', e)
      await ctx.reply('âŒ æŸ¥è¯¢è´¦å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

// OKXç›¸å…³å‘½ä»¤å¤„ç†å™¨
import { getOKXC2CSellers } from '../../lib/okx-api.js'

/**
 * æ ¼å¼åŒ–OKXä»·æ ¼æ˜¾ç¤ºï¼ˆé“¶è¡Œå¡æ ¼å¼ï¼Œç”¨äºz600uå’Œz600å‘½ä»¤ï¼‰
 */
function formatOKXPriceForCalculation(sellers) {
  if (sellers.length === 0) {
    return 'âŒ è·å–OKXä»·æ ¼å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'
  }

  const top10 = sellers.slice(0, 10)
  const lines = ['æ¬§æ˜“é“¶è¡Œå¡è´­ä¹°USDTä»·æ ¼']
  lines.push('â”€'.repeat(20))

  top10.forEach((seller, index) => {
    const price = seller.price.toFixed(2)
    const methods = seller.paymentMethods.map(m => {
      if (m === 'aliPay' || m === 'alipay') return 'æ”¯ä»˜å®'
      if (m === 'wxPay') return 'å¾®ä¿¡'
      if (m === 'bank') return 'é“¶è¡Œå¡'
      return m
    }).join(', ')
    
    // ç¬¬ä¸‰ä¸ªç”¨è“è‰²æ ‡è®°ï¼ˆç´¢å¼•ä¸º2ï¼‰
    const marker = index === 2 ? 'ğŸ”µ' : 'ğŸŸ '
    lines.push(`${marker} ${price} ${seller.nickName}${methods ? ` (${methods})` : ''}`)
  })

  return lines.join('\n')
}

/**
 * æ ¼å¼åŒ–OKXä»·æ ¼æ˜¾ç¤º
 */
function formatOKXPrice(sellers, methodName) {
  if (sellers.length === 0) {
    return 'âŒ è·å–OKXä»·æ ¼å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'
  }

  const top10 = sellers.slice(0, 10)
  const lines = [` OKXå®æ—¶Uä»· ${methodName} TOP 10 \n`]

  top10.forEach((seller, index) => {
    const emoji = ['1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ğŸ”Ÿ'][index]
    const price = seller.price.toFixed(2)
    const methods = seller.paymentMethods.map(m => {
      if (m === 'aliPay' || m === 'alipay') return 'æ”¯ä»˜å®'
      if (m === 'wxPay') return 'å¾®ä¿¡'
      if (m === 'bank') return 'é“¶è¡Œå¡'
      return m
    }).join(', ')
    lines.push(`${emoji} ${price} ${seller.nickName}${methods ? ` (${methods})` : ''}`)
  })

  const now = new Date()
  lines.push(`\nè·å–æ—¶é—´ï¼š${now.toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' })}`)

  return lines.join('\n')
}

// å·²åˆ é™¤ï¼šzé‡‘é¢æ¢ç®—å‘½ä»¤ï¼ˆz1000 / z20ï¼‰

/**
 * z0å‘½ä»¤ - æŸ¥è¯¢OKX C2Cä»·æ ¼
 */
export function registerZ0(bot) {
  bot.hears(/^(z0|Z0)$/i, async (ctx) => {
    try {
      const sellers = await getOKXC2CSellers('all')

      if (sellers.length === 0) {
        return ctx.reply('âŒ è·å–OKXä»·æ ¼å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
      }

      const text = formatOKXPrice(sellers, 'å…¨éƒ¨')

      const { Markup } = await import('telegraf')
      const inlineKb = Markup.inlineKeyboard([
        [
          Markup.button.callback('æ‰€æœ‰', 'okx_c2c_all'),
          Markup.button.callback('é“¶è¡Œå¡', 'okx_c2c_bank'),
          Markup.button.callback('æ”¯ä»˜å®', 'okx_c2c_alipay'),
          Markup.button.callback('å¾®ä¿¡', 'okx_c2c_wxpay')
        ]
      ])

      await ctx.reply(text, { ...inlineKb })
    } catch (e) {
      console.error('[z0å‘½ä»¤]', e)
      await ctx.reply('âŒ è·å–OKXä»·æ ¼å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })

  // OKX C2Cæ”¯ä»˜æ–¹å¼ç­›é€‰å›è°ƒ
  bot.action(/^okx_c2c_(all|bank|alipay|wxpay)$/, async (ctx) => {
    try {
      await ctx.answerCbQuery()

      const method = ctx.match[1]
      const methodMap = {
        'all': 'all',
        'bank': 'bank',
        'alipay': 'alipay',
        'wxpay': 'wxPay'
      }

      const sellers = await getOKXC2CSellers(methodMap[method])

      if (sellers.length === 0) {
        return ctx.editMessageText('âŒ è·å–OKXä»·æ ¼å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
      }

      const methodName = { 'all': 'å…¨éƒ¨', 'bank': 'é“¶è¡Œå¡', 'alipay': 'æ”¯ä»˜å®', 'wxpay': 'å¾®ä¿¡' }[method]
      const text = formatOKXPrice(sellers, methodName)

      const { Markup } = await import('telegraf')
      const inlineKb = Markup.inlineKeyboard([
        [
          Markup.button.callback('æ‰€æœ‰', 'okx_c2c_all'),
          Markup.button.callback('é“¶è¡Œå¡', 'okx_c2c_bank'),
          Markup.button.callback('æ”¯ä»˜å®', 'okx_c2c_alipay'),
          Markup.button.callback('å¾®ä¿¡', 'okx_c2c_wxpay')
        ]
      ])

      await ctx.editMessageText(text, { ...inlineKb })
    } catch (e) {
      console.error('[okx_c2c_action]', e)
      await ctx.answerCbQuery('è·å–å¤±è´¥', { show_alert: true }).catch(() => { })
    }
  })
}

/**
 * lzå‘½ä»¤ - æŸ¥è¯¢OKXæ”¯ä»˜å®Uä»·
 */
export function registerLZ(bot) {
  bot.hears(/^lz$/i, async (ctx) => {
    try {
      const sellers = await getOKXC2CSellers('alipay')
      const text = formatOKXPrice(sellers, 'æ”¯ä»˜å®')
      await ctx.reply(text)
    } catch (e) {
      console.error('[lzå‘½ä»¤]', e)
      await ctx.reply('âŒ è·å–OKXæ”¯ä»˜å®Uä»·å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * lwå‘½ä»¤ - æŸ¥è¯¢OKXå¾®ä¿¡Uä»·
 */
export function registerLW(bot) {
  bot.hears(/^lw$/i, async (ctx) => {
    try {
      const sellers = await getOKXC2CSellers('wxPay')
      const text = formatOKXPrice(sellers, 'å¾®ä¿¡')
      await ctx.reply(text)
    } catch (e) {
      console.error('[lwå‘½ä»¤]', e)
      await ctx.reply('âŒ è·å–OKXå¾®ä¿¡Uä»·å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * lkå‘½ä»¤ - æŸ¥è¯¢OKXé“¶è¡Œå¡Uä»·
 */
export function registerLK(bot) {
  bot.hears(/^lk$/i, async (ctx) => {
    try {
      const sellers = await getOKXC2CSellers('bank')
      const text = formatOKXPrice(sellers, 'é“¶è¡Œå¡')
      await ctx.reply(text)
    } catch (e) {
      console.error('[lkå‘½ä»¤]', e)
      await ctx.reply('âŒ è·å–OKXé“¶è¡Œå¡Uä»·å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * zé‡‘é¢uå‘½ä»¤ - ä½¿ç”¨OKXç¬¬ä¸‰ä¸ªæ±‡ç‡è®¡ç®—USDTå¯¹åº”çš„äººæ°‘å¸
 * ä¾‹å¦‚ï¼šz600u - ä½¿ç”¨ç¬¬ä¸‰ä¸ªæ±‡ç‡è®¡ç®—600Uå¯¹åº”çš„äººæ°‘å¸
 */
export function registerZAmountU(bot) {
  bot.hears(/^z(\d+(?:\.\d+)?)u$/i, async (ctx) => {
    try {
      const match = ctx.message.text.match(/^z(\d+(?:\.\d+)?)u$/i)
      if (!match) return

      const usdtAmount = parseFloat(match[1])
      if (!Number.isFinite(usdtAmount) || usdtAmount <= 0) {
        return ctx.reply('âŒ æ— æ•ˆçš„é‡‘é¢')
      }

      // è·å–OKX C2Cä»·æ ¼ï¼ˆé“¶è¡Œå¡ï¼‰
      const sellers = await getOKXC2CSellers('bank')

      if (sellers.length < 3) {
        return ctx.reply('âŒ è·å–OKXä»·æ ¼å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
      }

      // ä½¿ç”¨ç¬¬ä¸‰ä¸ªæ±‡ç‡ï¼ˆç´¢å¼•ä¸º2ï¼‰
      const thirdSeller = sellers[2]
      const rate = thirdSeller.price

      // è®¡ç®—ï¼šæ±‡ç‡ * USDTæ•°é‡ = äººæ°‘å¸
      const rmbAmount = Number((usdtAmount * rate).toFixed(2))

      // æ ¼å¼åŒ–æ˜¾ç¤ºï¼šå…ˆæ˜¾ç¤ºä»·æ ¼åˆ—è¡¨ï¼Œç„¶åç”¨åˆ†å‰²çº¿ï¼Œå†æ˜¾ç¤ºè®¡ç®—ç»“æœ
      const priceList = formatOKXPriceForCalculation(sellers)
      const separator = 'â”€'.repeat(20)
      const calculation = `${usdtAmount.toFixed(2)}U * ${rate.toFixed(2)} = ${rmbAmount.toFixed(2)}RMB`

      const result = `${priceList}\n${separator}\n${calculation}`

      await ctx.reply(result)
    } catch (e) {
      console.error('[zé‡‘é¢uå‘½ä»¤]', e)
      await ctx.reply('âŒ è®¡ç®—å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * zé‡‘é¢å‘½ä»¤ - ä½¿ç”¨OKXç¬¬ä¸‰ä¸ªæ±‡ç‡è®¡ç®—äººæ°‘å¸å¯¹åº”çš„USDT
 * ä¾‹å¦‚ï¼šz600 - ä½¿ç”¨ç¬¬ä¸‰ä¸ªæ±‡ç‡è®¡ç®—600å…ƒå¯¹åº”çš„USDT
 * æ³¨æ„ï¼šä¸åŒ¹é… z0ï¼ˆz0 ç”± registerZ0 å¤„ç†ï¼‰
 */
export function registerZAmount(bot) {
  bot.hears(/^z([1-9]\d*(?:\.\d+)?)$/i, async (ctx) => {
    try {
      const match = ctx.message.text.match(/^z([1-9]\d*(?:\.\d+)?)$/i)
      if (!match) return

      const rmbAmount = parseFloat(match[1])
      if (!Number.isFinite(rmbAmount) || rmbAmount <= 0) {
        return ctx.reply('âŒ æ— æ•ˆçš„é‡‘é¢')
      }

      // è·å–OKX C2Cä»·æ ¼ï¼ˆé“¶è¡Œå¡ï¼‰
      const sellers = await getOKXC2CSellers('bank')

      if (sellers.length < 3) {
        return ctx.reply('âŒ è·å–OKXä»·æ ¼å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
      }

      // ä½¿ç”¨ç¬¬ä¸‰ä¸ªæ±‡ç‡ï¼ˆç´¢å¼•ä¸º2ï¼‰
      const thirdSeller = sellers[2]
      const rate = thirdSeller.price

      // è®¡ç®—ï¼šäººæ°‘å¸ / æ±‡ç‡ = USDT
      const usdtAmount = Number((rmbAmount / rate).toFixed(2))

      // æ ¼å¼åŒ–æ˜¾ç¤ºï¼šå…ˆæ˜¾ç¤ºä»·æ ¼åˆ—è¡¨ï¼Œç„¶åç”¨åˆ†å‰²çº¿ï¼Œå†æ˜¾ç¤ºè®¡ç®—ç»“æœ
      const priceList = formatOKXPriceForCalculation(sellers)
      const separator = 'â”€'.repeat(20)
      const calculation = `${rmbAmount.toFixed(2)}RMB / ${rate.toFixed(2)} = ${usdtAmount.toFixed(2)}U`

      const result = `${priceList}\n${separator}\n${calculation}`

      await ctx.reply(result)
    } catch (e) {
      console.error('[zé‡‘é¢å‘½ä»¤]', e)
      await ctx.reply('âŒ è®¡ç®—å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

import { prisma } from '../../lib/db.js'
import { ensureCurrentBotId } from '../bot-identity.js'
import { ensureDefaultFeatures } from '../constants.js'
import logger from '../logger.js'

// ğŸ”¥ åœ°å€éªŒè¯åŠŸèƒ½ï¼šæ¯ä¸ªç¾¤åªç¡®è®¤ä¸€ä¸ªåœ°å€
async function handleAddressVerificationNew(ctx) {
    try {
        const chatId = String(ctx.chat.id)
        const text = ctx.message?.text || ''

        // æ£€æµ‹é’±åŒ…åœ°å€æ ¼å¼
        const addressPatterns = [
            /\b(T[A-Za-z1-9]{33})\b/g,  // TRC20
            /\b(0x[a-fA-F0-9]{40})\b/g, // ERC20
            /\b([13][a-km-zA-HJ-NP-Z1-9]{25,34})\b/g, // BTC Legacy
            /\b(bc1[a-z0-9]{39,59})\b/g, // BTC SegWit
        ]

        let detectedAddress = null
        for (const pattern of addressPatterns) {
            const match = text.match(pattern)
            if (match) {
                detectedAddress = match[0]
                break
            }
        }

        if (!detectedAddress) return false

        // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†åœ°å€éªŒè¯åŠŸèƒ½
        const setting = await prisma.setting.findUnique({
            where: { chatId },
            select: { addressVerificationEnabled: true }
        })

        if (!setting?.addressVerificationEnabled) return false

        const address = detectedAddress
        const senderId = String(ctx.from.id)
        const senderName = ctx.from.username ? `@${ctx.from.username}` :
            (ctx.from.first_name || ctx.from.last_name) ?
                `${ctx.from.first_name || ''} ${ctx.from.last_name || ''}`.trim() :
                senderId

        // æŸ¥è¯¢è¯¥ç¾¤çš„åœ°å€éªŒè¯è®°å½•ï¼ˆæ¯ä¸ªç¾¤åªæœ‰ä¸€æ¡è®°å½•ï¼‰
        let record = await prisma.addressVerification.findUnique({
            where: { chatId }
        })

        if (!record) {
            // ç¬¬ä¸€æ¬¡å‘é€åœ°å€
            // ğŸ”¥ è·å–å®Œæ•´Telegramåç§°ï¼ˆfirst_name + last_nameï¼‰
            const fullName = (ctx.from.first_name || '') + (ctx.from.last_name ? ' ' + ctx.from.last_name : '') || senderName

            await prisma.addressVerification.create({
                data: {
                    chatId,
                    confirmedAddress: address,
                    confirmedCount: 1,
                    lastSenderId: senderId,
                    lastSenderName: fullName
                }
            })

            const replyText = `ğŸ” *æ­¤åœ°å€å·²åŠ å…¥å®‰å…¨éªŒè¯*\n\n` +
                `ğŸ“ éªŒè¯åœ°å€ï¼š\`${address}\`\n` +
                `ğŸ”¢ éªŒè¯æ¬¡æ•°ï¼š*1*\n` +
                `ğŸ‘¤ å‘é€äººï¼š${fullName}`

            await ctx.reply(replyText, {
                parse_mode: 'Markdown',
                reply_to_message_id: ctx.message.message_id
            })

            logger.debug('[address-verification-new][first-time]', { chatId, address, senderId })
            return true
        }

        // å·²æœ‰è®°å½•
        const confirmedAddr = record.confirmedAddress
        const pendingAddr = record.pendingAddress

        if (address === confirmedAddr) {
            // å‘é€çš„æ˜¯å·²ç¡®è®¤çš„åœ°å€
            const newCount = record.confirmedCount + 1
            // ğŸ”¥ è·å–ç”¨æˆ·åï¼ˆä¼˜å…ˆï¼‰æˆ–å®Œæ•´åç§°
            const currentUsername = ctx.from.username ? `@${ctx.from.username}` : null
            const currentFullName = (ctx.from.first_name || '') + (ctx.from.last_name ? ' ' + ctx.from.last_name : '') || senderId
            const currentDisplay = currentUsername || currentFullName

            await prisma.addressVerification.update({
                where: { chatId },
                data: {
                    confirmedCount: newCount,
                    lastSenderId: senderId,
                    lastSenderName: currentDisplay,
                    updatedAt: new Date()
                }
            })

            const replyText = `âœ… *åœ°å€éªŒè¯é€šè¿‡*\n\n` +
                `ğŸ“ éªŒè¯åœ°å€ï¼š\`${address}\`\n` +
                `ğŸ”¢ éªŒè¯æ¬¡æ•°ï¼š*${newCount}*\n` +
                `ğŸ“¤ ä¸Šæ¬¡å‘é€äººï¼š${record.lastSenderName || record.lastSenderId}\n` +
                `ğŸ“¤ æœ¬æ¬¡å‘é€äººï¼š${currentDisplay}`

            await ctx.reply(replyText, {
                parse_mode: 'Markdown',
                reply_to_message_id: ctx.message.message_id
            })

            logger.debug('[address-verification-new][confirmed-address]', { chatId, address, count: newCount })
            return true
        }

        if (address === pendingAddr) {
            // å‘é€çš„æ˜¯å¾…ç¡®è®¤çš„åœ°å€ï¼ˆç¬¬2æ¬¡å‘é€æ–°åœ°å€ï¼‰
            const newCount = record.pendingCount + 1

            // ğŸ”¥ è·å–ç”¨æˆ·åï¼ˆä¼˜å…ˆï¼‰æˆ–å®Œæ•´åç§°
            const currentUsername = ctx.from.username ? `@${ctx.from.username}` : null
            const currentFullName = (ctx.from.first_name || '') + (ctx.from.last_name ? ' ' + ctx.from.last_name : '') || senderId
            const currentDisplay = currentUsername || currentFullName

            // ğŸ”¥ ç¬¬2æ¬¡å‘é€å¾…ç¡®è®¤åœ°å€ï¼Œå°†å…¶å‡çº§ä¸ºç¡®è®¤åœ°å€
            await prisma.addressVerification.update({
                where: { chatId },
                data: {
                    confirmedAddress: address,
                    confirmedCount: newCount,
                    pendingAddress: null,
                    pendingCount: 0,
                    lastSenderId: senderId,
                    lastSenderName: currentDisplay,
                    updatedAt: new Date()
                }
            })

            const replyText = `âœ… *åœ°å€éªŒè¯é€šè¿‡*\n\n` +
                `ğŸ“ éªŒè¯åœ°å€ï¼š\`${address}\`\n` +
                `ğŸ”¢ éªŒè¯æ¬¡æ•°ï¼š*${newCount}*\n` +
                `ğŸ“¤ ä¸Šæ¬¡å‘é€äººï¼š${record.lastSenderName || record.lastSenderId}\n` +
                `ğŸ“¤ æœ¬æ¬¡å‘é€äººï¼š${currentDisplay}`

            await ctx.reply(replyText, {
                parse_mode: 'Markdown',
                reply_to_message_id: ctx.message.message_id
            })

            logger.debug('[address-verification-new][pending-confirmed]', { chatId, address, newCount })
            return true
        }

        // ğŸ”¥ å‘é€çš„æ˜¯æ–°åœ°å€ï¼ˆä¸åŒäºç¡®è®¤åœ°å€å’Œå¾…ç¡®è®¤åœ°å€ï¼‰
        // å‘å‡ºè­¦å‘Šï¼Œå¹¶å°†æ–°åœ°å€è®¾ä¸ºå¾…ç¡®è®¤åœ°å€

        // ğŸ”¥ è·å–å½“å‰å‘é€äººçš„ä¿¡æ¯
        const currentSenderUsername = ctx.from.username ? `@${ctx.from.username}` : null
        const currentSenderFullName = (ctx.from.first_name || '') + (ctx.from.last_name ? ' ' + ctx.from.last_name : '').trim() || senderId
        const currentSenderDisplay = currentSenderUsername || currentSenderFullName || senderId

        // ğŸ”¥ æŸ¥è¯¢ä¹‹å‰å‘é€äººçš„ä¿¡æ¯
        // å¦‚æœä¹‹å‰è®°å½•çš„æ˜¯ç”¨æˆ·åï¼Œç›´æ¥ä½¿ç”¨ï¼›å¦‚æœæ˜¯IDæˆ–åç§°ï¼Œå°è¯•æŸ¥æ‰¾ç”¨æˆ·å
        let previousSenderUsername = null
        let previousSenderFullName = 'æœªçŸ¥'

        // ä»è®°å½•ä¸­è·å–ä¹‹å‰çš„å‘é€äººåç§°
        if (record.lastSenderName) {
            // å¦‚æœä¹‹å‰ä¿å­˜çš„æ˜¯ç”¨æˆ·åæ ¼å¼ï¼ˆ@å¼€å¤´ï¼‰ï¼Œåˆ™ç›´æ¥ä½¿ç”¨
            if (record.lastSenderName.startsWith('@')) {
                previousSenderUsername = record.lastSenderName
                // éœ€è¦æŸ¥è¯¢è¯¥ç”¨æˆ·çš„å®é™…åç§°ï¼ˆä»æ•°æ®åº“æˆ–ç¼“å­˜ï¼‰
                previousSenderFullName = record.lastSenderName // æš‚æ—¶ä½¿ç”¨ç”¨æˆ·å
            } else {
                // å¦‚æœä¹‹å‰ä¿å­˜çš„æ˜¯Telegramåç§°ï¼Œä½¿ç”¨å®ƒ
                previousSenderFullName = record.lastSenderName
            }
        }

        // ğŸ”¥ å¦‚æœä¹‹å‰çš„å‘é€äººIDå­˜åœ¨ä¸”ä¸åŒï¼Œå°è¯•ä»èŠå¤©è®°å½•ä¸­æŸ¥æ‰¾ç”¨æˆ·å
        // æ³¨æ„ï¼šè¿™é‡Œæ— æ³•ç›´æ¥è®¿é—® chat stateï¼Œæš‚æ—¶è·³è¿‡ä» state æŸ¥æ‰¾ç”¨æˆ·åçš„é€»è¾‘ï¼Œæˆ–è€…éœ€è¦ä¼ å…¥ chat state
        // ä¸ºäº†ç®€åŒ–ï¼Œè¿™é‡Œæš‚æ—¶åªä½¿ç”¨æ•°æ®åº“ä¸­çš„ä¿¡æ¯

        const previousSenderDisplay = previousSenderUsername || previousSenderFullName || record.lastSenderId || 'æœªçŸ¥'

        // ğŸ”¥ ä¿å­˜å½“å‰å‘é€äººçš„ç”¨æˆ·åï¼ˆå¦‚æœæœ‰ï¼‰æˆ–å®Œæ•´åç§°
        await prisma.addressVerification.update({
            where: { chatId },
            data: {
                pendingAddress: address,
                pendingCount: 1,
                lastSenderId: senderId,
                lastSenderName: currentSenderUsername || currentSenderFullName, // ä¼˜å…ˆä¿å­˜ç”¨æˆ·å
                updatedAt: new Date()
            }
        })

        const replyText = `âš ï¸âš ï¸âš ï¸*æ¸©é¦¨æç¤º*âš ï¸âš ï¸âš ï¸\n\n` +
            `â—ï¸æ­¤åœ°å€å’ŒåŸåœ°å€ä¸ä¸€æ ·è¯·å°å¿ƒäº¤æ˜“â—ï¸\n\n` +
            `ğŸ†”è¿˜æƒ³éšè—: \`${senderId}\`\n` +
            `ğŸš¹ä¿®æ”¹å‰åç§°ï¼š${previousSenderFullName}\n` +
            `ğŸšºä¿®æ”¹ååç§°ï¼š${currentSenderFullName}\n\n` +
            `ğŸ“æ–°åœ°å€ï¼š\`${address}\`\n` +
            `ğŸ“åŸåœ°å€ï¼š\`${confirmedAddr || 'æ— '}\`\n\n` +
            `ğŸ”¢éªŒè¯æ¬¡æ•°ï¼š0\n` +
            `ğŸ“¤ä¸Šæ¬¡å‘é€äººï¼š${previousSenderDisplay}\n` +
            `ğŸ“¤æœ¬æ¬¡å‘é€äººï¼š${currentSenderDisplay}`

        await ctx.reply(replyText, {
            parse_mode: 'Markdown',
            reply_to_message_id: ctx.message.message_id
        })

        logger.debug('[address-verification-new][warning-new-address]', {
            chatId,
            oldAddress: confirmedAddr,
            newAddress: address,
            senderId
        })
        return true

    } catch (error) {
        logger.error('[address-verification-new][error]', error)
        return false
    }
}

export function registerMessageHandlers(bot) {
    // å…œåº•ï¼šæ”¶åˆ°ä»»ä½•æ¶ˆæ¯æ—¶ï¼Œç¡®ä¿ chat è®°å½•å·² upsert å¹¶ç»‘å®šåˆ°å½“å‰æœºå™¨äºº
    bot.on('message', async (ctx, next) => {
        try {
            const chat = ctx.chat
            if (!chat) return await next()
            if (chat.type === 'channel') return
            const chatId = String(chat.id)
            const title = chat.title || ''
            const from = ctx.from?.username ? `@${ctx.from.username}` : ctx.from?.id
            const text = ctx.message?.text || ctx.message?.caption || '[éæ–‡æœ¬æ¶ˆæ¯]'

            logger.debug('[message][recv]', { chatId, title, from, text })

            // ğŸ”¥ åœ°å€éªŒè¯åŠŸèƒ½ - ä¼˜å…ˆå¤„ç†ï¼ˆä½¿ç”¨æ–°ç‰ˆæœ¬é€»è¾‘ï¼‰
            if (ctx.message?.text && chatId.startsWith('-')) {
                const handled = await handleAddressVerificationNew(ctx)
                if (handled) {
                    // åœ°å€éªŒè¯å·²å¤„ç†ï¼Œä¸ç»§ç»­æ‰§è¡Œåç»­é€»è¾‘
                    return
                }
            }

            // ğŸ”¥ æ£€æŸ¥ç¾¤ç»„æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨æˆ–æœªç»‘å®šï¼Œå°è¯•è¡¥å……ç™½åå•æ£€æµ‹
            const existingChat = await prisma.chat.findUnique({
                where: { id: chatId },
                select: { id: true, allowed: true, botId: true }
            })

            const botId = await ensureCurrentBotId(bot)

            // å¦‚æœç¾¤ç»„ä¸å­˜åœ¨ï¼Œæˆ–è€…æœªæˆæƒä¸”æœªç»‘å®šæœºå™¨äººï¼Œå°è¯•æ£€æµ‹ç™½åå•
            if (!existingChat || (!existingChat.allowed && !existingChat.botId)) {
                // ğŸ”¥ å¤‡ç”¨ç™½åå•æ£€æµ‹ï¼šä»æ¶ˆæ¯å‘é€è€…æ£€æŸ¥
                // è·å–ç¾¤æˆå‘˜åˆ—è¡¨ï¼Œæ‰¾å‡ºå¯èƒ½çš„é‚€è¯·äºº
                try {
                    const userId = String(ctx.from?.id || '')
                    const username = ctx.from?.username ? `@${ctx.from.username}` : null

                    // æ£€æŸ¥å½“å‰æ¶ˆæ¯å‘é€è€…æ˜¯å¦åœ¨ç™½åå•ä¸­
                    if (userId) {
                        const whitelistedUser = await prisma.whitelistedUser.findUnique({
                            where: { userId }
                        })

                        if (whitelistedUser) {
                            // æ‰¾åˆ°ç™½åå•ç”¨æˆ·ï¼Œè‡ªåŠ¨æˆæƒè¯¥ç¾¤ç»„
                            logger.info('[message][whitelist-detected]', { chatId, userId, username })

                            // ğŸ”¥ å¦‚æœç”¨æˆ·åä¸åŒï¼Œæ›´æ–°ç™½åå•è®°å½•ä¸­çš„ç”¨æˆ·å
                            if (username && username !== whitelistedUser.username) {
                                await prisma.whitelistedUser.update({
                                    where: { userId },
                                    data: { username }
                                }).catch((e) => {
                                    logger.error('[message][username-update-error]', e)
                                })
                                logger.debug('[message][username-updated]', { userId, oldUsername: whitelistedUser.username, newUsername: username })
                            }

                            // âš ï¸ ä¸åœ¨è¿™é‡Œåˆ›å»ºé‚€è¯·è®°å½•ï¼Œé¿å…ä¸ my_chat_member äº‹ä»¶é‡å¤
                            // é‚€è¯·è®°å½•åªåœ¨ my_chat_member äº‹ä»¶ä¸­åˆ›å»º

                            // è‡ªåŠ¨æˆæƒï¼šå…ˆç¡®ä¿ Chat ä¸ Setting å­˜åœ¨ï¼Œå†ä¸ºç¾¤èŠåˆ›å»ºåŠŸèƒ½å¼€å…³ï¼Œé¿å…å¤–é”®é”™è¯¯
                            await Promise.all([
                                prisma.chat.upsert({
                                    where: { id: chatId },
                                    create: {
                                        id: chatId,
                                        title,
                                        botId,
                                        status: 'APPROVED',
                                        allowed: true
                                    },
                                    update: {
                                        title,
                                        botId,
                                        status: 'APPROVED',
                                        allowed: true
                                    },
                                }),
                                prisma.setting.upsert({
                                    where: { chatId },
                                    create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
                                    update: {},
                                })
                            ])
                            // ä»…å¯¹ç¾¤èŠåˆ›å»ºé»˜è®¤åŠŸèƒ½å¼€å…³ï¼ˆchatId ä»¥ '-' å¼€å¤´ï¼‰ï¼Œé¿å…ç§èŠå¤–é”®å†²çª
                            if (String(chatId).startsWith('-')) {
                                await ensureDefaultFeatures(chatId, prisma)
                            }

                            logger.info('[message][auto-authorized]', { chatId, userId })
                        } else {
                            // éç™½åå•ç”¨æˆ·
                            await Promise.all([
                                prisma.chat.upsert({
                                    where: { id: chatId },
                                    create: { id: chatId, title, botId, status: 'PENDING', allowed: false },
                                    update: { title, botId },
                                }),
                                prisma.setting.upsert({
                                    where: { chatId },
                                    create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
                                    update: {},
                                })
                            ])
                        }
                    } else {
                        await Promise.all([
                            prisma.chat.upsert({
                                where: { id: chatId },
                                create: { id: chatId, title, status: 'PENDING', allowed: false },
                                update: { title },
                            }),
                            prisma.setting.upsert({
                                where: { chatId },
                                create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
                                update: {},
                            })
                        ])
                    }
                } catch (e) {
                    logger.error('[message][whitelist-check-error]', e)
                    await Promise.all([
                        prisma.chat.upsert({
                            where: { id: chatId },
                            create: { id: chatId, title, status: 'PENDING', allowed: false },
                            update: { title },
                        }),
                        prisma.setting.upsert({
                            where: { chatId },
                            create: { chatId, accountingEnabled: true }, // ğŸ”¥ é»˜è®¤å¼€å¯è®°è´¦
                            update: {},
                        })
                    ])
                }
            } else {
                // ç¾¤ç»„å·²å­˜åœ¨ï¼Œä»…æ›´æ–°æ ‡é¢˜
                await prisma.chat.update({
                    where: { id: chatId },
                    data: { title }
                }).catch((e) => {
                    logger.error('[message][title-update-error]', { chatId, error: e.message })
                })
            }

            logger.debug('[message][upsert-ok]', { chatId })
        } catch (e) {
            logger.error('[message][error]', e)
        } finally {
            try { await next() } catch { }
        }
    })
}
// ç»Ÿä¸€æ³¨å†Œæ‰€æœ‰å‘½ä»¤å¤„ç†å™¨
import { 
  registerStartAccounting, 
  registerStopAccounting,
  registerIncome, 
  registerDispatch,
  registerIncomeWithRemark,
  registerIncomeWithTarget,
  registerDispatchWithTarget
} from './accounting.js'
import { 
  registerSetFee, 
  registerSetRate, 
  registerSetRealtimeRate,
  registerRefreshRate,
  registerShowRate,
  registerSetCurrency,
  registerShowCurrency,
  registerSetDailyCutoff,
  registerOverDepositLimit,
  registerCalculatorToggle
} from './settings.js'
import {
  registerShowBill,
  registerSaveBill,
  registerDeleteBill,
  registerDeleteAllBills,
  registerShowHistory,
  registerShowIncomeHistory,
  registerShowDispatchHistory,
  registerUndoIncome,
  registerUndoDispatch,
  registerMyBill,
  registerAllBill
} from './bill.js'
import { registerZ0, registerLZ, registerLW, registerLK, registerZAmountU, registerZAmount } from './okx.js'
import { registerCustomCommands } from './custom.js'
import { registerDisplayMode, registerAccountingModes, registerCommissionMode } from './modes.js'
import { registerBotLeave, registerQueryRate, registerAdminInfo, registerListGroups } from './admin.js'
import { registerStart, registerHelp, registerHelpCommand, registerDashboard, registerCommandMenuAction, registerViewBill } from './core.js'
import { registerCheckUSDT, registerBroadcast, registerGroupBroadcast, registerBroadcastButtons, registerGroupManagement, registerGroupManagementButtons, registerGroupManagementText, registerGroupList } from './extended.js'

/**
 * æ³¨å†Œæ‰€æœ‰å‘½ä»¤å¤„ç†å™¨
 */
export function registerAllHandlers(bot, ensureChat) {
  // æ ¸å¿ƒå‘½ä»¤
  registerStart(bot, ensureChat)
  registerHelp(bot)
  registerHelpCommand(bot, ensureChat) // ğŸ”¥ ä½¿ç”¨è¯´æ˜å‘½ä»¤
  registerDashboard(bot)
  registerCommandMenuAction(bot)
  registerViewBill(bot, ensureChat)
  // è‡ªå®šä¹‰æŒ‡ä»¤ï¼ˆæ–‡æœ¬+å›¾ç‰‡ï¼‰
  registerCustomCommands(bot, ensureChat)
  
  // è®°è´¦ç›¸å…³
  registerStartAccounting(bot, ensureChat)
  registerStopAccounting(bot, ensureChat)
  // ğŸ”¥ å…ˆæ³¨å†Œå¤‡æ³¨å…¥è´¦å’ŒæŒ‡å®šå…¥è´¦ï¼ˆè¿™äº›éœ€è¦æ›´ä¸¥æ ¼çš„åŒ¹é…ï¼‰
  registerIncomeWithRemark(bot, ensureChat)
  registerIncomeWithTarget(bot, ensureChat)
  registerIncome(bot, ensureChat) // æœ€åæ³¨å†Œæ™®é€šå…¥è´¦ï¼ˆåŒ¹é…èŒƒå›´æ›´å¹¿ï¼‰
  // ğŸ”¥ å…ˆæ³¨å†ŒæŒ‡å®šä¸‹å‘
  registerDispatchWithTarget(bot, ensureChat)
  registerDispatch(bot, ensureChat) // æœ€åæ³¨å†Œæ™®é€šä¸‹å‘
  
  // è´¦å•ç›¸å…³
  registerShowBill(bot, ensureChat)
  registerSaveBill(bot, ensureChat)
  registerDeleteBill(bot, ensureChat)
  registerDeleteAllBills(bot, ensureChat)
  registerShowHistory(bot, ensureChat)
  registerShowIncomeHistory(bot, ensureChat) // ğŸ”¥ æŸ¥çœ‹å…¥æ¬¾å†å²ï¼ˆæœ€å¤š500æ¡ï¼‰
  registerShowDispatchHistory(bot, ensureChat) // ğŸ”¥ æŸ¥çœ‹ä¸‹å‘å†å²ï¼ˆæœ€å¤š500æ¡ï¼‰
  registerUndoIncome(bot, ensureChat)
  registerUndoDispatch(bot, ensureChat)
  registerMyBill(bot, ensureChat)
  registerAllBill(bot, ensureChat) // ğŸ”¥ å…¨éƒ¨è´¦å•ï¼šæ€»
  
  // è®¾ç½®ç›¸å…³
  registerSetFee(bot, ensureChat)
  registerSetRate(bot, ensureChat)
  registerSetRealtimeRate(bot, ensureChat)
  registerRefreshRate(bot, ensureChat)
  registerShowRate(bot, ensureChat)
  registerSetCurrency(bot, ensureChat)
  registerShowCurrency(bot, ensureChat)
  registerSetDailyCutoff(bot, ensureChat)
  // registerGlobalCutoff - å·²åˆ é™¤ï¼Œæ”¹ä¸ºåå°è®¾ç½®
  registerOverDepositLimit(bot, ensureChat)
  registerCalculatorToggle(bot, ensureChat)
  // æ¨¡å¼ç›¸å…³
  registerDisplayMode(bot, ensureChat)
  registerAccountingModes(bot, ensureChat)
  registerCommissionMode(bot, ensureChat)
  
  // OKXç›¸å…³
  registerZ0(bot)
  registerZAmountU(bot) // z600u å‘½ä»¤ï¼ˆå¿…é¡»åœ¨ z0 ä¹‹åæ³¨å†Œï¼Œé¿å…å†²çªï¼‰
  registerZAmount(bot) // z600 å‘½ä»¤ï¼ˆå¿…é¡»åœ¨ z0 ä¹‹åæ³¨å†Œï¼Œé¿å…å†²çªï¼‰
  registerLZ(bot)
  registerLW(bot)
  registerLK(bot)
  
  // ç®¡ç†å‘˜ç›¸å…³
  registerBotLeave(bot)
  registerQueryRate(bot, ensureChat)
  registerAdminInfo(bot)
  registerListGroups(bot)

  // æ‰©å±•åŠŸèƒ½
  registerCheckUSDT(bot, ensureChat)
  registerBroadcast(bot)
  registerGroupBroadcast(bot)
  registerBroadcastButtons(bot)
  registerGroupManagement(bot)
  registerGroupManagementButtons(bot)
  registerGroupManagementText(bot)
  registerGroupList(bot)
}

// è‡ªå®šä¹‰æŒ‡ä»¤ï¼ˆæ–‡æœ¬+å›¾ç‰‡ï¼‰å¤„ç†å™¨
import { prisma } from '../../lib/db.js'
import { hasPermissionWithWhitelist } from '../helpers.js'
import { getChat } from '../state.js'
import { ensureDbChat } from '../database.js'

async function getIndex(chatId) {
  const row = await prisma.globalConfig.findUnique({ where: { key: `customcmd_index:${chatId}` }, select: { value: true } }).catch(() => null)
  if (!row?.value) return []
  try { return JSON.parse(row.value) } catch { return [] }
}

async function setIndex(chatId, arr) {
  const value = JSON.stringify(Array.from(new Set(arr)))
  await prisma.globalConfig.upsert({
    where: { key: `customcmd_index:${chatId}` },
    create: { key: `customcmd_index:${chatId}`, value, description: `Custom commands index for ${chatId}`, updatedBy: 'system' },
    update: { value, description: `Custom commands index for ${chatId}`, updatedBy: 'system', updatedAt: new Date() }
  })
}

async function getCmd(chatId, trigger) {
  const key = `customcmd:${chatId}:${trigger}`
  const row = await prisma.globalConfig.findUnique({ where: { key }, select: { value: true } }).catch(() => null)
  if (!row?.value) return null
  try { return JSON.parse(row.value) } catch { return null }
}

async function setCmd(chatId, trigger, payload) {
  const key = `customcmd:${chatId}:${trigger}`
  const value = JSON.stringify(payload)
  await prisma.globalConfig.upsert({
    where: { key },
    create: { key, value, description: `Custom command ${trigger} for ${chatId}`, updatedBy: 'system' },
    update: { value, description: `Custom command ${trigger} for ${chatId}`, updatedBy: 'system', updatedAt: new Date() }
  })
}

async function delCmd(chatId, trigger) {
  const key = `customcmd:${chatId}:${trigger}`
  await prisma.globalConfig.delete({ where: { key } }).catch(() => {})
}

export function registerCustomCommands(bot, ensureChat) {
  // æ·»åŠ /ç¼–è¾‘ æ–‡æœ¬æŒ‡ä»¤ï¼šæ·»åŠ è‡ªå®šä¹‰æŒ‡ä»¤ <è§¦å‘è¯> <å†…å®¹>
  bot.hears(/^æ·»åŠ è‡ªå®šä¹‰æŒ‡ä»¤\s+([^\s]+)\s+([\s\S]+)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    const chatId = await ensureDbChat(ctx, chat)
    const ok = await hasPermissionWithWhitelist(ctx, chat)
    if (!ok) return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')

    const trigger = (ctx.match[1] || '').trim()
    const content = (ctx.match[2] || '').trim()
    if (!trigger || !content) return ctx.reply('ç”¨æ³•ï¼šæ·»åŠ è‡ªå®šä¹‰æŒ‡ä»¤ è§¦å‘è¯ å†…å®¹')

    const payload = await getCmd(chatId, trigger) || {}
    payload.content = content
    if (!payload.parseMode) payload.parseMode = 'Markdown'
    await setCmd(chatId, trigger, payload)

    const index = await getIndex(chatId)
    if (!index.includes(trigger)) {
      index.push(trigger)
      await setIndex(chatId, index)
    }
    await ctx.reply(`âœ… å·²è®¾ç½®è‡ªå®šä¹‰æŒ‡ä»¤ï¼š${trigger}`)
  })

  // è®¾ç½®å›¾ç‰‡ï¼šè®¾ç½®è‡ªå®šä¹‰å›¾ç‰‡ <è§¦å‘è¯> <å›¾ç‰‡URL>
  bot.hears(/^è®¾ç½®è‡ªå®šä¹‰å›¾ç‰‡\s+([^\s]+)\s+(https?:\/\/\S+)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    const chatId = await ensureDbChat(ctx, chat)
    const ok = await hasPermissionWithWhitelist(ctx, chat)
    if (!ok) return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')

    const trigger = (ctx.match[1] || '').trim()
    const imageUrl = (ctx.match[2] || '').trim()
    const existing = await getCmd(chatId, trigger) || { content: '' }
    existing.imageUrl = imageUrl
    if (!existing.parseMode) existing.parseMode = 'Markdown'
    await setCmd(chatId, trigger, existing)

    const index = await getIndex(chatId)
    if (!index.includes(trigger)) {
      index.push(trigger)
      await setIndex(chatId, index)
    }
    await ctx.reply(`âœ… å·²è®¾ç½®å›¾ç‰‡ï¼š${trigger}`)
  })

  // åˆ é™¤ï¼šåˆ é™¤è‡ªå®šä¹‰æŒ‡ä»¤ <è§¦å‘è¯>
  bot.hears(/^åˆ é™¤è‡ªå®šä¹‰æŒ‡ä»¤\s+([^\s]+)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    const chatId = await ensureDbChat(ctx, chat)
    const ok = await hasPermissionWithWhitelist(ctx, chat)
    if (!ok) return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')

    const trigger = (ctx.match[1] || '').trim()
    await delCmd(chatId, trigger)
    const index = (await getIndex(chatId)).filter(t => t !== trigger)
    await setIndex(chatId, index)
    await ctx.reply(`ğŸ—‘ï¸ å·²åˆ é™¤ï¼š${trigger}`)
  })

  // åˆ—è¡¨ï¼šè‡ªå®šä¹‰æŒ‡ä»¤åˆ—è¡¨
  bot.hears(/^è‡ªå®šä¹‰æŒ‡ä»¤åˆ—è¡¨$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    const chatId = await ensureDbChat(ctx, chat)
    const index = await getIndex(chatId)
    if (index.length === 0) return ctx.reply('å½“å‰æ²¡æœ‰è‡ªå®šä¹‰æŒ‡ä»¤')
    await ctx.reply('ğŸ“œ è‡ªå®šä¹‰æŒ‡ä»¤åˆ—è¡¨ï¼š\n\n' + index.map(t => `- ${t}`).join('\n'))
  })

  // è§¦å‘ï¼šæ¶ˆæ¯å…¨æ–‡ç­‰äºè§¦å‘è¯æ—¶å›å¤ï¼ˆä»…ç®¡ç†å‘˜/æ“ä½œäºº/ç™½åå•ï¼‰
  bot.on('text', async (ctx, next) => {
    try {
      const text = (ctx.message?.text || '').trim()
      if (!text) return next()
      const chatId = String(ctx.chat?.id || '')
      const chat = ensureChat(ctx)
      if (!chat) return next()
      if (!(await hasPermissionWithWhitelist(ctx, chat))) {
        return next()
      }
      const cmd = await getCmd(chatId, text)
      if (!cmd) return next()
      const content = cmd.content || ''
      const imageUrl = cmd.imageUrl || ''
      const parse_mode = cmd.parseMode || 'Markdown'
      if (imageUrl) {
        try {
          await ctx.replyWithPhoto(imageUrl, { caption: content, parse_mode })
        } catch {
          await ctx.reply(content, { parse_mode })
        }
      } else {
        await ctx.reply(content, { parse_mode })
      }
    } catch (e) {
      // é™é»˜å¤±è´¥ï¼Œä¸å½±å“å…¶ä»–å‘½ä»¤
      return next()
    }
  })
}
// è®°è´¦ç›¸å…³å‘½ä»¤å¤„ç†å™¨
import { prisma } from '../../lib/db.js'
import { parseAmountAndRate } from '../state.js'
import { ensureDbChat, getOrCreateTodayBill, checkAndClearIfNewDay, updateSettings, syncSettingsToMemory } from '../database.js'
import { buildInlineKb, fetchRealtimeRateUSDTtoCNY, getEffectiveRate, hasPermissionWithWhitelist } from '../helpers.js'
import { formatSummary } from '../formatting.js'
import { formatMoney } from '../utils.js'
import { getUsername, getDisplayName } from '../helpers.js'
import { isAccountingEnabled, isFeatureEnabled, clearAccountingCache } from '../middleware.js'

/**
 * å¼€å§‹è®°è´¦ï¼ˆæ¿€æ´»æœºå™¨äººå¹¶å¼€å§‹è®°å½•ï¼‰
 */
export function registerStartAccounting(bot, ensureChat) {
  bot.hears(/^(å¼€å§‹è®°è´¦|å¼€å§‹)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    const chatId = await ensureDbChat(ctx, chat)
    await updateSettings(chatId, { accountingEnabled: true })
    clearAccountingCache(chatId) // ğŸ”¥ æ¸…é™¤ç¼“å­˜ï¼Œç«‹å³ç”Ÿæ•ˆ
    await ctx.reply('âœ… å·²å¼€å§‹è®°è´¦ï¼Œæœºå™¨äººå·²æ¿€æ´»å¹¶å¼€å§‹è®°å½•', { ...(await buildInlineKb(ctx)) })
  })
}

/**
 * åœæ­¢è®°è´¦ï¼ˆæš‚åœæœºå™¨äººè®°å½•ï¼‰
 */
export function registerStopAccounting(bot, ensureChat) {
  bot.hears(/^(åœæ­¢è®°è´¦|åœæ­¢)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ æƒé™æ£€æŸ¥ï¼šåªæœ‰ç®¡ç†å‘˜æˆ–æ“ä½œå‘˜å¯ä»¥åœæ­¢è®°è´¦
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜æˆ–å·²æ·»åŠ çš„æ“ä½œäººå¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    await updateSettings(chatId, { accountingEnabled: false })
    clearAccountingCache(chatId) // ğŸ”¥ æ¸…é™¤ç¼“å­˜ï¼Œç«‹å³ç”Ÿæ•ˆ
    await ctx.reply('â¸ï¸ å·²åœæ­¢è®°è´¦ï¼Œæœºå™¨äººå·²æš‚åœè®°å½•ã€‚å‘é€"å¼€å§‹"å¯é‡æ–°å¼€å§‹è®°è´¦', { ...(await buildInlineKb(ctx)) })
  })
}

/**
 * ğŸ”¥ å¤‡æ³¨å…¥è´¦ï¼šå¤‡æ³¨ +10000 æˆ– æå››+10000
 * æ³¨æ„ï¼š
 * - "å¤‡æ³¨ +1000" æ ¼å¼ï¼šå¤‡æ³¨å’Œé‡‘é¢ä¹‹é—´å¿…é¡»æœ‰ç©ºæ ¼
 * - "æå››+10000" æ ¼å¼ï¼šä¼ ç»Ÿæ ¼å¼ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
 * - ä¸èƒ½åŒ¹é…@ç”¨æˆ·å+é‡‘é¢æ ¼å¼ï¼ˆé‚£ä¸ªç”±registerIncomeWithTargetå¤„ç†ï¼‰
 * - ä¸èƒ½åŒ¹é…è®¡ç®—è¡¨è¾¾å¼ï¼ˆå¦‚+3232+323åº”è¯¥è®¡ç®—ï¼Œä¸æ˜¯å¤‡æ³¨ï¼‰
 */
export function registerIncomeWithRemark(bot, ensureChat) {
  // ğŸ”¥ åŒ¹é…ä¸¤ç§æ ¼å¼ï¼š
  // 1. "å¤‡æ³¨ +1000" - å¤‡æ³¨å’Œé‡‘é¢ä¹‹é—´å¿…é¡»æœ‰ç©ºæ ¼
  // 2. "æå››+10000" - ä¼ ç»Ÿæ ¼å¼ï¼ˆéæ•°å­—å¼€å¤´ï¼Œé@å¼€å¤´ï¼Œé+/-å¼€å¤´ï¼‰
  // ğŸ”¥ æ’é™¤ä»¥+/-å¼€å¤´çš„è®¡ç®—è¡¨è¾¾å¼ï¼ˆå¦‚+3232+323ï¼‰
  bot.hears(/^(å¤‡æ³¨\s+[+\-]\s*\d+(?:\.\d+)?(?:u|U)?|[^@\s\d+\-][^@]*?\+(\d+(?:\.\d+)?)(?:u|U)?)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ æ£€æŸ¥è®°è´¦æ˜¯å¦å¯ç”¨ï¼ˆç”±ä¸­é—´ä»¶ç»Ÿä¸€å¤„ç†æé†’é€»è¾‘ï¼‰
    if (!(await isAccountingEnabled(ctx))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    // ğŸ”¥ æ£€æŸ¥åŸºç¡€è®°è´¦åŠŸèƒ½æ˜¯å¦å¯ç”¨
    if (!(await isFeatureEnabled(ctx, 'accounting_basic'))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥è®°è´¦ã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const isNewDay = await checkAndClearIfNewDay(chat, chatId)
    // ğŸ”¥ ä¿®å¤ï¼šè·¨æ—¥åé‡æ–°åŒæ­¥è®¾ç½®åˆ°å†…å­˜ï¼ˆç¡®ä¿æ“ä½œäººã€æ±‡ç‡ã€è´¹ç‡ä¸ä¸¢å¤±ï¼‰
    if (isNewDay) {
      await syncSettingsToMemory(ctx, chat, chatId)
    }

    const text = ctx.message.text.trim()

    // ğŸ”¥ ä¼˜å…ˆåŒ¹é… "å¤‡æ³¨ +1000" æ ¼å¼ï¼ˆå¤‡æ³¨å’Œé‡‘é¢ä¹‹é—´å¿…é¡»æœ‰ç©ºæ ¼ï¼‰
    let remark = null
    let amountStr = null
    let isUSDT = false

    if (/^å¤‡æ³¨\s+/i.test(text)) {
      // "å¤‡æ³¨ +1000" æ ¼å¼
      const remarkMatch = text.match(/^å¤‡æ³¨\s+([+\-]\s*\d+(?:\.\d+)?(?:u|U)?)(?:\s+(.+))?$/i)
      if (remarkMatch) {
        amountStr = remarkMatch[1].replace(/\s+/g, '') // å»æ‰ç©ºæ ¼
        remark = remarkMatch[2]?.trim() || null // å¯é€‰çš„é¢å¤–å¤‡æ³¨
        isUSDT = /[uU]/.test(amountStr)
        // å»æ‰u/Uåç¼€
        amountStr = amountStr.replace(/[uU]/g, '')
      } else {
        return // æ ¼å¼ä¸åŒ¹é…ï¼Œè®©å…¶ä»–å¤„ç†å™¨å¤„ç†
      }
    } else {
      // "æå››+10000" ä¼ ç»Ÿæ ¼å¼ï¼ˆéæ•°å­—å¼€å¤´ï¼Œé@å¼€å¤´ï¼Œé+/-å¼€å¤´ï¼‰
      // ğŸ”¥ æ’é™¤ä»¥+/-å¼€å¤´çš„è®¡ç®—è¡¨è¾¾å¼ï¼ˆå¦‚+3232+323ï¼‰
      if (/^[+\-]/.test(text)) {
        return // ä»¥+/-å¼€å¤´çš„æ˜¯è®¡ç®—è¡¨è¾¾å¼ï¼Œä¸æ˜¯å¤‡æ³¨ï¼Œè®©å…¶ä»–å¤„ç†å™¨å¤„ç†
      }

      const match = text.match(/^([^@\s\d+\-][^@]*?)\+(\d+(?:\.\d+)?)(?:u|U)?$/i)
      if (!match) return

      remark = match[1].trim() // å¤‡æ³¨ï¼ˆå¦‚"æå››"ï¼‰
      amountStr = match[2]
      isUSDT = /[uU]/.test(text)
    }

    if (!amountStr) return

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ±‡ç‡è·å–å‡½æ•°
    const rate = await getEffectiveRate(chatId, chat)

    const amount = Number(amountStr)
    if (!Number.isFinite(amount) || amount === 0) return

    let amountRMB, usdt
    if (isUSDT) {
      usdt = Math.abs(amount)
      amountRMB = rate ? Number((usdt * rate).toFixed(2)) : 0
      if (amount < 0) amountRMB = -amountRMB
    } else {
      amountRMB = amount
      usdt = rate ? Number((Math.abs(amountRMB) / rate).toFixed(2)) : undefined
    }

    const operatorUsername = ctx.from?.username ? `@${ctx.from.username}` : null
    const replierUsername = getUsername(ctx)
    const userId = ctx.from?.id ? Number(ctx.from.id) : null
    const displayName = getDisplayName(ctx.from) // ğŸ”¥ ä½¿ç”¨æ˜µç§°è€Œä¸æ˜¯ç”¨æˆ·å

    chat.current.incomes.push({
      amount: amountRMB,
      rate: rate || undefined,
      createdAt: new Date(),
      replier: replierUsername,
      operator: operatorUsername || replierUsername,
      displayName,
      userId,
      // è®°å½•åŸå§‹æ¶ˆæ¯IDï¼Œä¾¿äºåç»­è·³è½¬åˆ°æ¶ˆæ¯
      messageId: ctx.message?.message_id || null,
    })

    try {
      const { bill } = await getOrCreateTodayBill(chatId)
      await prisma.billItem.create({
        data: {
          billId: bill.id,
          type: 'INCOME',
          amount: Number(amountRMB),
          rate: rate ? Number(rate) : null,
          usdt: usdt ? Number(usdt) : null,
          remark: remark || null, // ğŸ”¥ ä¿å­˜å¤‡æ³¨
          replier: replierUsername || null,
          operator: operatorUsername || replierUsername || null,
          displayName: displayName || null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·æ˜µç§°
          userId: userId ? String(userId) : null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·ID
          messageId: ctx.message?.message_id || null, // ğŸ”¥ ä¿å­˜æ¶ˆæ¯ID
          createdAt: new Date(),
        }
      })
    } catch (e) {
      console.error('å†™å…¥ BillItem(INCOME) å¤±è´¥', e)
    }

    try {
      const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
      await ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
    } catch (e) {
      console.error('[å¤‡æ³¨å…¥è´¦] å‘é€å›å¤å¤±è´¥', e)
    }
  })
}

/**
 * ğŸ”¥ æŒ‡å®šå…¥è´¦ï¼š@å¼ ä¸‰+1000 æˆ–å›å¤+1000
 */
export function registerIncomeWithTarget(bot, ensureChat) {
  // å¤„ç† @ç”¨æˆ·å+é‡‘é¢ æ ¼å¼
  bot.hears(/^@(\w+)\s*\+(\d+(?:\.\d+)?)(?:u|U)?$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ æ£€æŸ¥è®°è´¦æ˜¯å¦å¯ç”¨ï¼ˆç”±ä¸­é—´ä»¶ç»Ÿä¸€å¤„ç†æé†’é€»è¾‘ï¼‰
    if (!(await isAccountingEnabled(ctx))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    // ğŸ”¥ æ£€æŸ¥åŸºç¡€è®°è´¦åŠŸèƒ½æ˜¯å¦å¯ç”¨
    if (!(await isFeatureEnabled(ctx, 'accounting_basic'))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥è®°è´¦ã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const isNewDay = await checkAndClearIfNewDay(chat, chatId)
    // ğŸ”¥ ä¿®å¤ï¼šè·¨æ—¥åé‡æ–°åŒæ­¥è®¾ç½®åˆ°å†…å­˜ï¼ˆç¡®ä¿æ“ä½œäººã€æ±‡ç‡ã€è´¹ç‡ä¸ä¸¢å¤±ï¼‰
    if (isNewDay) {
      await syncSettingsToMemory(ctx, chat, chatId)
    }

    const text = ctx.message.text.trim()
    const match = text.match(/^@(\w+)\s*\+(\d+(?:\.\d+)?)(?:u|U)?$/i)
    if (!match) return

    const targetUsername = `@${match[1]}` // ç›®æ ‡ç”¨æˆ·
    const amountStr = match[2]
    const isUSDT = /[uU]/.test(text)

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ±‡ç‡è·å–å‡½æ•°
    const rate = await getEffectiveRate(chatId, chat)

    const amount = Number(amountStr)
    if (!Number.isFinite(amount) || amount === 0) return

    let amountRMB, usdt
    if (isUSDT) {
      usdt = Math.abs(amount)
      amountRMB = rate ? Number((usdt * rate).toFixed(2)) : 0
    } else {
      amountRMB = amount
      usdt = rate ? Number((Math.abs(amountRMB) / rate).toFixed(2)) : undefined
    }

    const operatorUsername = ctx.from?.username ? `@${ctx.from.username}` : null
    const userId = ctx.from?.id ? Number(ctx.from.id) : null
    // ğŸ”¥ å¯¹äº @username æŒ‡å®šçš„ç”¨æˆ·ï¼Œæš‚æ—¶ä½¿ç”¨ç”¨æˆ·åï¼Œåç»­å¯é€šè¿‡APIè·å–æ˜µç§°
    const displayName = targetUsername.replace('@', '')

    chat.current.incomes.push({
      amount: amountRMB,
      rate: rate || undefined,
      createdAt: new Date(),
      replier: targetUsername.replace('@', ''),
      operator: operatorUsername || targetUsername,
      displayName,
      userId,
      messageId: ctx.message?.message_id || null,
    })

    try {
      const { bill } = await getOrCreateTodayBill(chatId)
      await prisma.billItem.create({
        data: {
          billId: bill.id,
          type: 'INCOME',
          amount: Number(amountRMB),
          rate: rate ? Number(rate) : null,
          usdt: usdt ? Number(usdt) : null,
          replier: targetUsername.replace('@', '') || null,
          operator: operatorUsername || targetUsername || null,
          displayName: displayName || null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·æ˜µç§°
          userId: userId ? String(userId) : null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·ID
          messageId: ctx.message?.message_id || null, // ğŸ”¥ ä¿å­˜æ¶ˆæ¯ID
          createdAt: new Date(),
        }
      })
    } catch (e) {
      console.error('å†™å…¥ BillItem(INCOME) å¤±è´¥', e)
    }

    try {
      const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
      await ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
    } catch (e) {
      console.error('[æŒ‡å®šå…¥è´¦] å‘é€å›å¤å¤±è´¥', e)
    }
  })

  // å¤„ç†å›å¤æ¶ˆæ¯çš„ +é‡‘é¢
  bot.on('text', async (ctx, next) => {
    const chat = ensureChat(ctx)
    if (!chat) return next()

    const text = ctx.message.text?.trim()
    const replyTo = ctx.message.reply_to_message
    if (!replyTo || !replyTo.from) return next()

    // åŒ¹é… +é‡‘é¢ æ ¼å¼ï¼ˆåœ¨å›å¤æ¶ˆæ¯æ—¶ï¼‰
    const match = text.match(/^\+(\d+(?:\.\d+)?)(?:u|U)?$/i)
    if (!match) return next()

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥è®°è´¦ã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const isNewDay = await checkAndClearIfNewDay(chat, chatId)
    // ğŸ”¥ ä¿®å¤ï¼šè·¨æ—¥åé‡æ–°åŒæ­¥è®¾ç½®åˆ°å†…å­˜ï¼ˆç¡®ä¿æ“ä½œäººã€æ±‡ç‡ã€è´¹ç‡ä¸ä¸¢å¤±ï¼‰
    if (isNewDay) {
      await syncSettingsToMemory(ctx, chat, chatId)
    }

    const amountStr = match[1]
    const isUSDT = /[uU]/.test(text)

    // è·å–ç›®æ ‡ç”¨æˆ·
    const targetUsername = replyTo.from.username ? `@${replyTo.from.username}` : `@user_${replyTo.from.id}`

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ±‡ç‡è·å–å‡½æ•°
    const rate = await getEffectiveRate(chatId, chat)

    const amount = Number(amountStr)
    if (!Number.isFinite(amount) || amount === 0) return next()

    let amountRMB, usdt
    if (isUSDT) {
      usdt = Math.abs(amount)
      amountRMB = rate ? Number((usdt * rate).toFixed(2)) : 0
    } else {
      amountRMB = amount
      usdt = rate ? Number((Math.abs(amountRMB) / rate).toFixed(1)) : undefined
    }

    const operatorUsername = ctx.from?.username ? `@${ctx.from.username}` : null
    const userId = ctx.from?.id ? Number(ctx.from.id) : null
    const displayName = getDisplayName(replyTo.from) // ğŸ”¥ ä½¿ç”¨ç»Ÿä¸€çš„æ˜µç§°è·å–å‡½æ•°

    chat.current.incomes.push({
      amount: amountRMB,
      rate: rate || undefined,
      createdAt: new Date(),
      replier: targetUsername.replace('@', ''),
      operator: operatorUsername || targetUsername,
      displayName,
      userId,
      messageId: ctx.message?.message_id || null,
    })

    try {
      const { bill } = await getOrCreateTodayBill(chatId)
      await prisma.billItem.create({
        data: {
          billId: bill.id,
          type: 'INCOME',
          amount: Number(amountRMB),
          rate: rate ? Number(rate) : null,
          usdt: usdt ? Number(usdt) : null,
          replier: targetUsername.replace('@', '') || null,
          operator: operatorUsername || targetUsername || null,
          displayName: displayName || null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·æ˜µç§°
          userId: userId ? String(userId) : null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·ID
          messageId: ctx.message?.message_id || null, // ğŸ”¥ ä¿å­˜æ¶ˆæ¯ID
          createdAt: new Date(),
        }
      })
    } catch (e) {
      console.error('å†™å…¥ BillItem(INCOME) å¤±è´¥', e)
    }

    try {
      const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
      await ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
    } catch (e) {
      console.error('[æŒ‡å®šå…¥è´¦(å›å¤)] å‘é€å›å¤å¤±è´¥', e)
    }
  })
}

/**
 * å…¥æ¬¾å‘½ä»¤å¤„ç†å™¨ï¼ˆå¢å¼ºç‰ˆï¼šæ”¯æŒæ±‡ç‡ã€è´¹ç‡ã€ç»„åˆæ ¼å¼ï¼‰
 */
export function registerIncome(bot, ensureChat) {
  // ğŸ”¥ æ”¯æŒå¤‡æ³¨æ ¼å¼ï¼šå¤‡æ³¨ +1000 æˆ– å¤‡æ³¨+1000
  bot.hears(/^(å¤‡æ³¨\s*)?[+\-]\s*[\d+\-*/.()]+(?:u|U)?(?:\s*\/\s*\d+(?:\.\d+)?)?(?:\s*\*\s*\d+(?:\.\d+)?)?$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ æ£€æŸ¥è®°è´¦æ˜¯å¦å¯ç”¨ï¼ˆç”±ä¸­é—´ä»¶ç»Ÿä¸€å¤„ç†æé†’é€»è¾‘ï¼‰
    if (!(await isAccountingEnabled(ctx))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    // ğŸ”¥ æ£€æŸ¥åŸºç¡€è®°è´¦åŠŸèƒ½æ˜¯å¦å¯ç”¨
    if (!(await isFeatureEnabled(ctx, 'accounting_basic'))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥è®°è´¦ã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)

    // ğŸ”¥ æ€§èƒ½ä¼˜åŒ–ï¼šä¸€æ¬¡æ€§æŸ¥è¯¢æ‰€æœ‰éœ€è¦çš„è®¾ç½®
    const setting = await prisma.setting.findUnique({
      where: { chatId },
      select: { calculatorEnabled: true, featureWarningMode: true }
    })
    const calculatorEnabled = setting?.calculatorEnabled !== false // é»˜è®¤å¼€å¯

    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦è·¨æ—¥ï¼Œå¦‚æœæ˜¯æ¯æ—¥æ¸…é›¶æ¨¡å¼åˆ™æ¸…ç©ºå†…å­˜æ•°æ®
    const isNewDay = await checkAndClearIfNewDay(chat, chatId)
    // ğŸ”¥ ä¿®å¤ï¼šè·¨æ—¥åé‡æ–°åŒæ­¥è®¾ç½®åˆ°å†…å­˜ï¼ˆç¡®ä¿æ“ä½œäººã€æ±‡ç‡ã€è´¹ç‡ä¸ä¸¢å¤±ï¼‰
    if (isNewDay) {
      await syncSettingsToMemory(ctx, chat, chatId)
    }
    const text = ctx.message.text.trim()

    // ğŸ”¥ æå–å¤‡æ³¨ï¼ˆå¦‚æœæœ‰ï¼‰
    let remark = null
    const remarkMatch = text.match(/^å¤‡æ³¨\s*(.+)$/i)
    let checkText = text
    if (remarkMatch) {
      checkText = remarkMatch[1].trim()
      // æå–é‡‘é¢éƒ¨åˆ†ï¼ˆå»æ‰å¤‡æ³¨ï¼‰
      const amountMatch = checkText.match(/^([+\-]\s*[\d+\-*/.()]+(?:u|U)?(?:\s*\/\s*\d+(?:\.\d+)?)?(?:\s*\*\s*\d+(?:\.\d+)?)?)/i)
      if (amountMatch) {
        remark = checkText.substring(amountMatch[0].length).trim() || null
        checkText = amountMatch[0] // åªæ£€æŸ¥é‡‘é¢éƒ¨åˆ†
      }
    }

    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦æ˜¯è®¡ç®—è¡¨è¾¾å¼ï¼ˆéœ€è¦åŒ…å«è¿ç®—ç¬¦ä¸”ä¸æ˜¯ç®€å•çš„æ­£è´Ÿå·ï¼‰
    // è§„åˆ™ï¼šå¦‚æœåŒ…å«è¿ç®—ç¬¦ï¼Œä¸”ä¸æ˜¯ç®€å•çš„ +æ•°å­— æˆ– -æ•°å­— æ ¼å¼ï¼Œåˆ™è®¤ä¸ºæ˜¯è®¡ç®—è¡¨è¾¾å¼
    const hasOperator = /[+\-*\/]/.test(checkText)
    const isSimpleNumber = /^[+\-]?\s*\d+(?:\.\d+)?(?:u|U)?(?:\s*\/\s*\d+(?:\.\d+)?)?(?:\s*\*\s*\d+(?:\.\d+)?)?$/i.test(checkText.replace(/\s+/g, ''))
    const isCalculation = hasOperator && !isSimpleNumber

    // ğŸ”¥ å¦‚æœæ˜¯è®¡ç®—è¡¨è¾¾å¼ä¸”è®¡ç®—å™¨å·²å…³é—­ï¼Œéœ€è¦æ£€æŸ¥åŠŸèƒ½æç¤ºè®¾ç½®
    if (isCalculation && !calculatorEnabled) {
      // ğŸ”¥ ä½¿ç”¨åŠŸèƒ½æç¤ºé€»è¾‘ï¼ˆç±»ä¼¼è®°è´¦å¼€å…³ï¼‰
      const warningMode = setting?.featureWarningMode || 'always'
      let shouldWarn = false

      if (warningMode === 'always') {
        shouldWarn = true
        await prisma.featureWarningLog.deleteMany({
          where: { chatId, feature: 'calculator_disabled' }
        }).catch(() => { })
      } else if (warningMode === 'once') {
        const existingLog = await prisma.featureWarningLog.findUnique({
          where: { chatId_feature: { chatId, feature: 'calculator_disabled' } }
        })
        if (!existingLog) {
          shouldWarn = true
          await prisma.featureWarningLog.upsert({
            where: { chatId_feature: { chatId, feature: 'calculator_disabled' } },
            create: { chatId, feature: 'calculator_disabled' },
            update: { warnedAt: new Date() }
          }).catch(() => { })
        }
      } else if (warningMode === 'daily') {
        const existingLog = await prisma.featureWarningLog.findUnique({
          where: { chatId_feature: { chatId, feature: 'calculator_disabled' } }
        })
        const now = new Date()
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate())
        if (!existingLog || existingLog.warnedAt < today) {
          shouldWarn = true
          await prisma.featureWarningLog.upsert({
            where: { chatId_feature: { chatId, feature: 'calculator_disabled' } },
            create: { chatId, feature: 'calculator_disabled' },
            update: { warnedAt: now }
          }).catch(() => { })
        }
      }
      // warningMode === 'silent' æ—¶ä¸æé†’

      if (shouldWarn) {
        return ctx.reply('âš ï¸ è®¡ç®—å™¨åŠŸèƒ½å·²å…³é—­ï¼Œä¸æ”¯æŒæ•°å­¦è®¡ç®—ã€‚è¯·ä½¿ç”¨ç®€å•æ•°å­—æ ¼å¼ã€‚')
      }
      return // ä¸æé†’ï¼Œç›´æ¥è¿”å›
    }

    if (ctx.from?.id && ctx.from?.username) {
      const uname = `@${ctx.from.username}`
      chat.userIdByUsername.set(uname, ctx.from.id)
      chat.userIdByUsername.set(ctx.from.username, ctx.from.id)
    }

    // ğŸ”¥ æå–é‡‘é¢éƒ¨åˆ†ï¼ˆå»æ‰"å¤‡æ³¨"å‰ç¼€ï¼‰
    let amountText = text
    if (text.startsWith('å¤‡æ³¨')) {
      amountText = text.replace(/^å¤‡æ³¨\s*/i, '').trim()
      // å¦‚æœè¿˜æœ‰å¤‡æ³¨å†…å®¹ï¼Œæå–å‡ºæ¥
      const amountMatch = amountText.match(/^([+\-]\s*[\d+\-*/.()]+(?:u|U)?(?:\s*\/\s*\d+(?:\.\d+)?)?(?:\s*\*\s*\d+(?:\.\d+)?)?)/i)
      if (amountMatch) {
        const remaining = amountText.substring(amountMatch[0].length).trim()
        if (remaining && !remark) {
          remark = remaining
        }
        amountText = amountMatch[0]
      }
    }

    const isUSDT = /[uU]/.test(amountText)
    const cleanText = amountText.replace(/[uU]/g, '').replace(/\s+/g, '')
    const parsed = parseAmountAndRate(cleanText)
    if (!parsed) {
      return ctx.reply('âŒ æ— æ•ˆçš„é‡‘é¢æ ¼å¼')
    }

    if (!Number(parsed.amount)) {
      const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
      return ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
    }

    // ğŸ”¥ ä½¿ç”¨è§£æå‡ºçš„æ±‡ç‡ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ç¾¤ç»„è®¾ç½®
    const rate = parsed.rate ?? chat.fixedRate ?? chat.realtimeRate
    const feeRate = parsed.feeRate // å•ç‹¬è´¹ç‡ï¼ˆå¦‚0.95è¡¨ç¤º95%ï¼‰

    let amountRMB, usdt, finalAmountRMB

    if (isUSDT) {
      usdt = Math.abs(parsed.amount)
      amountRMB = rate ? Number((usdt * rate).toFixed(2)) : 0
      if (parsed.amount < 0) amountRMB = -amountRMB
    } else {
      amountRMB = parsed.amount
      usdt = rate ? Number((Math.abs(amountRMB) / rate).toFixed(1)) : undefined
    }

    // ğŸ”¥ å¦‚æœæŒ‡å®šäº†è´¹ç‡ï¼Œåº”ç”¨è´¹ç‡ï¼ˆå¦‚0.95è¡¨ç¤ºæ‰£é™¤5%æ‰‹ç»­è´¹ï¼‰
    if (feeRate && feeRate > 0 && feeRate <= 1) {
      finalAmountRMB = Number((amountRMB * feeRate).toFixed(2))
      // å¦‚æœè¾“å…¥çš„æ˜¯USDTï¼Œä¹Ÿç›¸åº”è°ƒæ•´
      if (isUSDT && rate) {
        usdt = Number((Math.abs(finalAmountRMB) / rate).toFixed(2))
      }
    } else {
      finalAmountRMB = amountRMB
    }

    const operatorUsername = ctx.from?.username ? `@${ctx.from.username}` : null
    const replierUsername = getUsername(ctx)
    const userId = ctx.from?.id ? Number(ctx.from.id) : null
    const displayName = getDisplayName(ctx.from) // ğŸ”¥ ä½¿ç”¨æ˜µç§°è€Œä¸æ˜¯ç”¨æˆ·å

    chat.current.incomes.push({
      amount: finalAmountRMB,
      rate: parsed.rate || undefined,
      createdAt: new Date(),
      replier: replierUsername,
      operator: operatorUsername || replierUsername,
      displayName,
      userId,
      messageId: ctx.message?.message_id || null,
    })

    try {
      const { bill } = await getOrCreateTodayBill(chatId)
      await prisma.billItem.create({
        data: {
          billId: bill.id,
          type: 'INCOME',
          amount: Number(finalAmountRMB),
          rate: rate ? Number(rate) : null,
          feeRate: feeRate ? Number(feeRate) : null, // ğŸ”¥ ä¿å­˜è´¹ç‡
          usdt: usdt ? Number(usdt) : null,
          remark: remark || null, // ğŸ”¥ ä¿å­˜å¤‡æ³¨
          replier: replierUsername || null,
          operator: operatorUsername || replierUsername || null,
          displayName: displayName || null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·æ˜µç§°
          userId: userId ? String(userId) : null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·ID
          messageId: ctx.message?.message_id || null, // ğŸ”¥ ä¿å­˜æ¶ˆæ¯ID
          createdAt: new Date(),
        }
      })
    } catch (e) {
      console.error('å†™å…¥ BillItem(INCOME) å¤±è´¥', e)
    }

    // è¶…æŠ¼æé†’æ£€æŸ¥
    if (finalAmountRMB > 0) {
      try {
        const setting = await prisma.setting.findUnique({
          where: { chatId },
          select: { overDepositLimit: true, lastOverDepositWarning: true }
        })

        if (setting?.overDepositLimit && setting.overDepositLimit > 0) {
          const { bill } = await getOrCreateTodayBill(chatId)
          const totalIncome = await prisma.billItem.aggregate({
            where: { billId: bill.id, type: 'INCOME' },
            _sum: { amount: true }
          })

          // ğŸ”¥ ç¡®ä¿ç²¾åº¦ï¼šä½¿ç”¨ Number è½¬æ¢ï¼Œé¿å…æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
          const currentTotal = Number((totalIncome._sum.amount || 0).toFixed(2))
          const limit = setting.overDepositLimit
          const shouldWarn = currentTotal >= limit || (currentTotal >= limit * 0.9 && currentTotal < limit)
          const lastWarning = setting.lastOverDepositWarning
          const shouldSendWarning = shouldWarn && (!lastWarning || Date.now() - lastWarning.getTime() > 60 * 60 * 1000)

          if (shouldSendWarning) {
            const warningText = currentTotal >= limit
              ? `âš ï¸ *è¶…æŠ¼æé†’*\n\nå½“å‰å…¥æ¬¾æ€»é¢ï¼š${formatMoney(currentTotal)} å…ƒ\nè®¾ç½®é¢åº¦ï¼š${formatMoney(limit)} å…ƒ\nå·²è¶…è¿‡é¢åº¦ï¼š${formatMoney(currentTotal - limit)} å…ƒ`
              : `âš ï¸ *è¶…æŠ¼æé†’*\n\nå½“å‰å…¥æ¬¾æ€»é¢ï¼š${formatMoney(currentTotal)} å…ƒ\nè®¾ç½®é¢åº¦ï¼š${formatMoney(limit)} å…ƒ\nå³å°†è¶…è¿‡é¢åº¦ï¼Œè¿˜å·®ï¼š${formatMoney(limit - currentTotal)} å…ƒ`

            await ctx.reply(warningText, { parse_mode: 'Markdown' })
            await prisma.setting.update({
              where: { chatId },
              data: { lastOverDepositWarning: new Date() }
            })
          }
        }
      } catch (e) {
        console.error('[è¶…æŠ¼æé†’]', e)
      }
    }

    try {
      const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
      const inlineKb = await buildInlineKb(ctx)
      await ctx.reply(summary, { ...inlineKb, parse_mode: 'Markdown' })
    } catch (e) {
      console.error('[è®°è´¦å‘½ä»¤] å‘é€å›å¤å¤±è´¥', e)
      await ctx.reply('âœ… è®°è´¦å·²ä¿å­˜ï¼ˆè´¦å•æ˜¾ç¤ºå¤±è´¥ï¼Œè¯·ç¨åæŸ¥çœ‹ï¼‰').catch(() => { })
    }
  })
}

/**
 * ğŸ”¥ æŒ‡å®šä¸‹å‘ï¼š@å¼ ä¸‰ä¸‹å‘1000 æˆ–å›å¤ä¸‹å‘1000u
 */
export function registerDispatchWithTarget(bot, ensureChat) {
  // å¤„ç† @ç”¨æˆ·åä¸‹å‘é‡‘é¢ æ ¼å¼
  bot.hears(/^@(\w+)\s*ä¸‹å‘\s*([+\-]?\s*\d+(?:\.\d+)?)(?:u|U)?$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ æ£€æŸ¥è®°è´¦æ˜¯å¦å¯ç”¨ï¼ˆç”±ä¸­é—´ä»¶ç»Ÿä¸€å¤„ç†æé†’é€»è¾‘ï¼‰
    if (!(await isAccountingEnabled(ctx))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    // ğŸ”¥ æ£€æŸ¥åŸºç¡€è®°è´¦åŠŸèƒ½æ˜¯å¦å¯ç”¨
    if (!(await isFeatureEnabled(ctx, 'accounting_basic'))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥è®°è´¦ã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const isNewDay = await checkAndClearIfNewDay(chat, chatId)
    // ğŸ”¥ ä¿®å¤ï¼šè·¨æ—¥åé‡æ–°åŒæ­¥è®¾ç½®åˆ°å†…å­˜ï¼ˆç¡®ä¿æ“ä½œäººã€æ±‡ç‡ã€è´¹ç‡ä¸ä¸¢å¤±ï¼‰
    if (isNewDay) {
      await syncSettingsToMemory(ctx, chat, chatId)
    }

    const text = ctx.message.text.trim()
    const match = text.match(/^@(\w+)\s*ä¸‹å‘\s*([+\-]?\s*\d+(?:\.\d+)?)(?:u|U)?$/i)
    if (!match) return

    const targetUsername = `@${match[1]}`
    const amountStr = match[2].replace(/\s+/g, '')
    const isUSDT = /[uU]/.test(text)

    const inputValue = Number(amountStr)
    if (!Number.isFinite(inputValue)) return

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ±‡ç‡è·å–å‡½æ•°
    const rate = await getEffectiveRate(chatId, chat)

    let amountRMB, usdtValue
    if (isUSDT) {
      usdtValue = inputValue
      amountRMB = rate ? Number((Math.abs(usdtValue) * rate).toFixed(2)) : 0
      if (usdtValue < 0) amountRMB = -amountRMB
    } else {
      amountRMB = inputValue
      usdtValue = rate ? Number((Math.abs(amountRMB) / rate).toFixed(2)) : 0
      if (amountRMB < 0) usdtValue = -usdtValue
    }

    const operatorUsername = ctx.from?.username ? `@${ctx.from.username}` : null
    const userId = ctx.from?.id ? Number(ctx.from.id) : null
    // ğŸ”¥ å¯¹äº @username æŒ‡å®šçš„ç”¨æˆ·ï¼Œæš‚æ—¶ä½¿ç”¨ç”¨æˆ·åï¼Œåç»­å¯é€šè¿‡APIè·å–æ˜µç§°
    const displayName = targetUsername.replace('@', '')

    chat.current.dispatches.push({
      amount: amountRMB,
      usdt: Math.abs(usdtValue),
      createdAt: new Date(),
      replier: targetUsername.replace('@', ''),
      operator: operatorUsername || targetUsername,
      displayName,
      userId,
    })

    try {
      const { bill } = await getOrCreateTodayBill(chatId)
      await prisma.billItem.create({
        data: {
          billId: bill.id,
          type: 'DISPATCH',
          amount: Number(amountRMB),
          usdt: Number(usdtValue),
          replier: targetUsername.replace('@', '') || null,
          operator: operatorUsername || targetUsername || null,
          displayName: displayName || null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·æ˜µç§°
          userId: userId ? String(userId) : null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·ID
          createdAt: new Date(),
        }
      })
    } catch (e) {
      console.error('å†™å…¥ BillItem(DISPATCH) å¤±è´¥', e)
    }

    try {
      const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
      await ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
    } catch (e) {
      console.error('[æŒ‡å®šä¸‹å‘] å‘é€å›å¤å¤±è´¥', e)
    }
  })

  // å¤„ç†å›å¤æ¶ˆæ¯çš„ ä¸‹å‘é‡‘é¢
  bot.on('text', async (ctx, next) => {
    const chat = ensureChat(ctx)
    if (!chat) return next()

    // ğŸ”¥ æ£€æŸ¥è®°è´¦æ˜¯å¦å¯ç”¨ï¼ˆç”±ä¸­é—´ä»¶ç»Ÿä¸€å¤„ç†æé†’é€»è¾‘ï¼‰
    const accountingOk = await isAccountingEnabled(ctx)
    if (!accountingOk) {
      return next() // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    const text = ctx.message.text?.trim()
    const replyTo = ctx.message.reply_to_message
    if (!replyTo || !replyTo.from) return next()

    // åŒ¹é… ä¸‹å‘é‡‘é¢ æ ¼å¼ï¼ˆåœ¨å›å¤æ¶ˆæ¯æ—¶ï¼‰
    const match = text.match(/^ä¸‹å‘\s*([+\-]?\s*\d+(?:\.\d+)?)(?:u|U)?$/i)
    if (!match) return next()

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥è®°è´¦ã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const isNewDay = await checkAndClearIfNewDay(chat, chatId)
    // ğŸ”¥ ä¿®å¤ï¼šè·¨æ—¥åé‡æ–°åŒæ­¥è®¾ç½®åˆ°å†…å­˜ï¼ˆç¡®ä¿æ“ä½œäººã€æ±‡ç‡ã€è´¹ç‡ä¸ä¸¢å¤±ï¼‰
    if (isNewDay) {
      await syncSettingsToMemory(ctx, chat, chatId)
    }

    const amountStr = match[1].replace(/\s+/g, '')
    const isUSDT = /[uU]/.test(text)

    const inputValue = Number(amountStr)
    if (!Number.isFinite(inputValue)) return next()

    // è·å–ç›®æ ‡ç”¨æˆ·
    const targetUsername = replyTo.from.username ? `@${replyTo.from.username}` : `@user_${replyTo.from.id}`

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ±‡ç‡è·å–å‡½æ•°
    const rate = await getEffectiveRate(chatId, chat)

    let amountRMB, usdtValue
    if (isUSDT) {
      usdtValue = inputValue
      amountRMB = rate ? Number((Math.abs(usdtValue) * rate).toFixed(2)) : 0
      if (usdtValue < 0) amountRMB = -amountRMB
    } else {
      amountRMB = inputValue
      usdtValue = rate ? Number((Math.abs(amountRMB) / rate).toFixed(2)) : 0
      if (amountRMB < 0) usdtValue = -usdtValue
    }

    const operatorUsername = ctx.from?.username ? `@${ctx.from.username}` : null
    const userId = ctx.from?.id ? Number(ctx.from.id) : null
    const displayName = getDisplayName(replyTo.from) // ğŸ”¥ ä½¿ç”¨ç»Ÿä¸€çš„æ˜µç§°è·å–å‡½æ•°

    chat.current.dispatches.push({
      amount: amountRMB,
      usdt: Math.abs(usdtValue),
      createdAt: new Date(),
      replier: targetUsername.replace('@', ''),
      operator: operatorUsername || targetUsername,
      displayName,
      userId,
    })

    try {
      const { bill } = await getOrCreateTodayBill(chatId)
      await prisma.billItem.create({
        data: {
          billId: bill.id,
          type: 'DISPATCH',
          amount: Number(amountRMB),
          usdt: Number(usdtValue),
          replier: targetUsername.replace('@', '') || null,
          operator: operatorUsername || targetUsername || null,
          displayName: displayName || null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·æ˜µç§°
          userId: userId ? String(userId) : null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·ID
          createdAt: new Date(),
        }
      })
    } catch (e) {
      console.error('å†™å…¥ BillItem(DISPATCH) å¤±è´¥', e)
    }

    try {
      const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
      await ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
    } catch (e) {
      console.error('[æŒ‡å®šä¸‹å‘(å›å¤)] å‘é€å›å¤å¤±è´¥', e)
    }
  })
}

/**
 * ä¸‹å‘å‘½ä»¤å¤„ç†å™¨ï¼ˆå¢å¼ºç‰ˆï¼šä½¿ç”¨å½“å‰æ±‡ç‡ï¼‰
 */
export function registerDispatch(bot, ensureChat) {
  // ğŸ”¥ æ”¯æŒå¤‡æ³¨æ ¼å¼ï¼šå¤‡æ³¨ ä¸‹å‘1000 æˆ– å¤‡æ³¨ä¸‹å‘1000
  bot.hears(/^(å¤‡æ³¨\s*)?ä¸‹å‘\s*[+\-]?\s*\d+(?:\.\d+)?(?:u|U)?$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ æ£€æŸ¥è®°è´¦æ˜¯å¦å¯ç”¨ï¼ˆç”±ä¸­é—´ä»¶ç»Ÿä¸€å¤„ç†æé†’é€»è¾‘ï¼‰
    if (!(await isAccountingEnabled(ctx))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    // ğŸ”¥ æ£€æŸ¥åŸºç¡€è®°è´¦åŠŸèƒ½æ˜¯å¦å¯ç”¨
    if (!(await isFeatureEnabled(ctx, 'accounting_basic'))) {
      return // ä¸­é—´ä»¶å·²å¤„ç†æé†’
    }

    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰è®°è´¦æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œå‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥è®°è´¦ã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)

    // ğŸ”¥ æ£€æŸ¥æ˜¯å¦è·¨æ—¥ï¼Œå¦‚æœæ˜¯æ¯æ—¥æ¸…é›¶æ¨¡å¼åˆ™æ¸…ç©ºå†…å­˜æ•°æ®
    const isNewDay = await checkAndClearIfNewDay(chat, chatId)
    // ğŸ”¥ ä¿®å¤ï¼šè·¨æ—¥åé‡æ–°åŒæ­¥è®¾ç½®åˆ°å†…å­˜ï¼ˆç¡®ä¿æ“ä½œäººã€æ±‡ç‡ã€è´¹ç‡ä¸ä¸¢å¤±ï¼‰
    if (isNewDay) {
      await syncSettingsToMemory(ctx, chat, chatId)
    }
    const text = ctx.message.text.trim()

    // ğŸ”¥ æå–å¤‡æ³¨ï¼ˆå¦‚æœæœ‰ï¼‰
    let remark = null
    let dispatchText = text
    if (text.startsWith('å¤‡æ³¨')) {
      dispatchText = text.replace(/^å¤‡æ³¨\s*/i, '').trim()
      // æå–é‡‘é¢éƒ¨åˆ†
      const amountMatch = dispatchText.match(/^ä¸‹å‘\s*([+\-]?\s*\d+(?:\.\d+)?(?:u|U)?)/i)
      if (amountMatch) {
        const remaining = dispatchText.substring(amountMatch[0].length).trim()
        if (remaining) {
          remark = remaining
        }
        dispatchText = amountMatch[0]
      }
    }

    const isUSDT = /[uU]/.test(dispatchText)
    const m = dispatchText.match(/^ä¸‹å‘\s*([+\-]?\s*\d+(?:\.\d+)?)/i)
    if (!m) return

    const inputValue = Number(m[1].replace(/\s+/g, ''))
    if (!Number.isFinite(inputValue)) return

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ±‡ç‡è·å–å‡½æ•°
    const rate = await getEffectiveRate(chatId, chat)

    let amountRMB, usdtValue
    if (isUSDT) {
      usdtValue = inputValue
      amountRMB = rate ? Number((Math.abs(usdtValue) * rate).toFixed(2)) : 0
      if (usdtValue < 0) amountRMB = -amountRMB
    } else {
      amountRMB = inputValue
      usdtValue = rate ? Number((Math.abs(amountRMB) / rate).toFixed(1)) : 0
      if (amountRMB < 0) usdtValue = -usdtValue
    }

    const operatorUsername = ctx.from?.username ? `@${ctx.from.username}` : null
    const replierUsername = getUsername(ctx)
    const userId = ctx.from?.id ? Number(ctx.from.id) : null
    const displayName = getDisplayName(ctx.from) // ğŸ”¥ ä½¿ç”¨æ˜µç§°è€Œä¸æ˜¯ç”¨æˆ·å

    chat.current.dispatches.push({
      amount: amountRMB,
      usdt: Math.abs(usdtValue),
      createdAt: new Date(),
      replier: replierUsername,
      operator: operatorUsername || replierUsername,
      displayName,
      userId,
    })

    try {
      const { bill } = await getOrCreateTodayBill(chatId)
      await prisma.billItem.create({
        data: {
          billId: bill.id,
          type: 'DISPATCH',
          amount: Number(amountRMB),
          usdt: Number(usdtValue),
          remark: remark || null, // ğŸ”¥ ä¿å­˜å¤‡æ³¨
          replier: replierUsername || null,
          operator: operatorUsername || replierUsername || null,
          displayName: displayName || null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·æ˜µç§°
          userId: userId ? String(userId) : null, // ğŸ”¥ ä¿å­˜ç”¨æˆ·ID
          createdAt: new Date(),
        }
      })
    } catch (e) {
      console.error('å†™å…¥ BillItem(DISPATCH) å¤±è´¥', e)
    }

    try {
      const summary = await formatSummary(ctx, chat, { title: 'å½“å‰è´¦å•' })
      await ctx.reply(summary, { ...(await buildInlineKb(ctx)), parse_mode: 'Markdown' })
    } catch (e) {
      console.error('[ä¸‹å‘å‘½ä»¤] å‘é€å›å¤å¤±è´¥', e)
      await ctx.reply('âœ… ä¸‹å‘å·²ä¿å­˜').catch(() => { })
    }
  })
}
import { prisma } from '../../lib/db.js'
import { ensureCurrentBotId } from '../bot-identity.js'
import { ensureDefaultFeatures } from '../constants.js'
import logger from '../logger.js'

// è·å–åå°é…ç½®çš„æ¬¢è¿è¯­
async function getWelcomeMessage(botId) {
    const bot = await prisma.bot.findUnique({
        where: { id: botId },
        select: { welcomeMessage: true }
    })
    return bot?.welcomeMessage
}

/**
 * å½»åº•æ¸…ç†ç¾¤ç»„æ•°æ®
 */
async function cleanupGroupData(chatId) {
    try {
        logger.info('[cleanup] å¼€å§‹æ¸…ç†ç¾¤ç»„æ•°æ®', { chatId })
        // ä½¿ç”¨äº‹åŠ¡æˆ–å¹¶è¡Œåˆ é™¤ï¼Œç¡®ä¿æ¸…ç†å¹²å‡€ï¼Œå…ˆåˆ å­è¡¨ï¼Œæœ€ååˆ ä¸»è¡¨
        await Promise.all([
            prisma.billItem.deleteMany({ where: { bill: { chatId } } }),
            prisma.bill.deleteMany({ where: { chatId } }),
            prisma.operator.deleteMany({ where: { chatId } }),
            prisma.setting.deleteMany({ where: { chatId } }),
            prisma.chatFeatureFlag.deleteMany({ where: { chatId } }),
            prisma.addressVerification.deleteMany({ where: { chatId } }),
            prisma.featureWarningLog.deleteMany({ where: { chatId } }),
            prisma.income.deleteMany({ where: { chatId } }), // å…¼å®¹æ—§è¡¨
            prisma.dispatch.deleteMany({ where: { chatId } }), // å…¼å®¹æ—§è¡¨
            prisma.commission.deleteMany({ where: { chatId } }) // å…¼å®¹æ—§è¡¨
        ])

        // æœ€ååˆ é™¤ Chat è®°å½•
        await prisma.chat.delete({ where: { id: chatId } })

        logger.info('[cleanup] ç¾¤ç»„æ•°æ®æ¸…ç†å®Œæˆ', { chatId })
        return true
    } catch (e) {
        // å¿½ç•¥"è®°å½•ä¸å­˜åœ¨"çš„é”™è¯¯
        if (e.code !== 'P2025') {
            logger.error('[cleanup] æ¸…ç†æ•°æ®å¤±è´¥', { chatId, error: e.message })
        }
        return false
    }
}

export function registerMemberHandlers(bot) {
    // å¤„ç†æ™®é€šæˆå‘˜åŠ å…¥/ç¦»å¼€ç¾¤ç»„
    bot.on('chat_member', async (ctx) => {
        logger.debug('[chat_member][event-triggered]', {
            updateType: ctx.updateType,
            hasChat: !!ctx.chat,
            chatId: ctx.chat?.id
        })

        try {
            const upd = ctx.update?.chat_member
            if (!upd) {
                logger.debug('[chat_member][no-update-data]')
                return
            }

            const chat = ctx.chat
            if (!chat || !chat.id) {
                logger.debug('[chat_member][no-chat-data]')
                return
            }

            const newStatus = upd.new_chat_member?.status
            const oldStatus = upd.old_chat_member?.status
            const chatId = String(chat.id)
            const userId = String(upd.new_chat_member?.user?.id || '')
            const username = upd.new_chat_member?.user?.username
            const firstName = upd.new_chat_member?.user?.first_name || ''
            const lastName = upd.new_chat_member?.user?.last_name || ''

            // åªå¤„ç†æˆå‘˜åŠ å…¥çš„æƒ…å†µ
            if (newStatus === 'member' && (!oldStatus || oldStatus === 'left' || oldStatus === 'kicked')) {
                logger.info('[chat_member][user-joined]', {
                    chatId,
                    userId,
                    username,
                    name: `${firstName} ${lastName}`.trim(),
                    oldStatus,
                    newStatus
                })

                // æ£€æŸ¥ç¾¤ç»„æ˜¯å¦å·²æˆæƒä½¿ç”¨æœºå™¨äºº
                const chatSettings = await prisma.chat.findUnique({
                    where: { id: chatId },
                    select: {
                        allowed: true,
                        status: true,
                        invitedBy: true,
                        invitedByUsername: true
                    }
                })

                // å¦‚æœç¾¤ç»„å·²è¢«æ‰¹å‡†ä¸”å…è®¸ä½¿ç”¨æœºå™¨äººï¼Œåˆ™å‘é€æ¬¢è¿è¯­
                if (chatSettings?.allowed && chatSettings?.status === 'APPROVED') {
                    logger.info('[chat_member][sending-welcome]', {
                        chatId,
                        userId,
                        allowed: chatSettings.allowed,
                        status: chatSettings.status
                    })
                    try {
                        // è·å–ç¾¤ç»„çº§åˆ«çš„æ ‡è¯­è®¾ç½®
                        const settings = await prisma.setting.findUnique({
                            where: { chatId },
                            select: {
                                welcomeMessage: true,
                                showWelcomeMessage: true
                            }
                        })

                        logger.debug('[chat_member][settings-check]', {
                            chatId,
                            hasSettings: !!settings,
                            welcomeMessage: settings?.welcomeMessage?.substring(0, 50) + '...',
                            showWelcomeMessage: settings?.showWelcomeMessage
                        })

                        // æ£€æŸ¥æ˜¯å¦å¯ç”¨æ¬¢è¿æ¶ˆæ¯
                        if (settings?.showWelcomeMessage === false) {
                            logger.info('[chat_member][welcome-disabled]', { chatId, userId })
                            return
                        }

                        let welcomeText = settings?.welcomeMessage || 'æ¬¢è¿åŠ å…¥ç¾¤ç»„ï¼æ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨æœºå™¨äººåŠŸèƒ½äº†ã€‚'

                        logger.debug('[chat_member][preparing-welcome]', {
                            chatId,
                            userId,
                            welcomeTextLength: welcomeText.length
                        })

                        // å»¶è¿Ÿ2ç§’å‘é€ï¼Œé¿å…æ¶ˆæ¯å‘é€è¿‡å¿«
                        setTimeout(async () => {
                            try {
                                const finalWelcomeText = welcomeText
                                    .replace('{name}', firstName || 'æ–°æˆå‘˜')
                                    .replace('{username}', username ? `@${username}` : 'æ–°æˆå‘˜')
                                    .replace('{chat}', chat.title || 'ç¾¤ç»„')

                                await bot.telegram.sendMessage(chatId, finalWelcomeText, {
                                    parse_mode: 'Markdown',
                                    disable_web_page_preview: true,
                                    reply_to_message_id: ctx.message?.message_id
                                })

                                logger.info('[chat_member][welcome-sent]', {
                                    chatId,
                                    userId,
                                    username,
                                    name: `${firstName} ${lastName}`.trim()
                                })
                            } catch (e) {
                                logger.error('[chat_member][welcome-send-failed]', { chatId, userId, error: e.message })
                            }
                        }, 2000)
                    } catch (e) {
                        logger.error('[chat_member][welcome-check-failed]', { chatId, userId, error: e.message })
                    }
                }
            }
        } catch (e) {
            logger.error('[chat_member][error]', e)
        }
    })

    // ç›‘å¬æœºå™¨äººè‡ªèº«è¿›å‡ºç¾¤çŠ¶æ€å˜æ›´ (æ ¸å¿ƒé€»è¾‘)
    bot.on('my_chat_member', async (ctx) => {
        try {
            const upd = ctx.update?.my_chat_member
            const chat = ctx.chat
            if (!upd || !chat) return

            const newStatus = upd.new_chat_member?.status
            const oldStatus = upd.old_chat_member?.status
            const chatId = String(chat.id)
            const title = chat.title || ''

            // è·å–å½“å‰æœºå™¨äººID
            const botId = await ensureCurrentBotId(bot)

            // è·å–è§¦å‘åŠ¨ä½œçš„äººï¼ˆé‚€è¯·äºº/è¸¢äººè€…ï¼‰
            // ä¼˜å…ˆä½¿ç”¨ ctx.myChatMember.fromï¼Œè¿™æ˜¯APIæä¾›çš„è§¦å‘è€…
            const from = ctx.myChatMember?.from || ctx.from
            const actionUserId = String(from?.id || '')
            const actionUsername = from?.username ? `@${from.username}` : null
            const actionFullName = `${from?.first_name || ''} ${from?.last_name || ''}`.trim()

            logger.info('[my_chat_member]', {
                chatId,
                title,
                action: newStatus,
                inviter: actionUserId
            })

            // === åœºæ™¯ A: æœºå™¨äººè¢«é‚€è¯·å…¥ç¾¤ (æˆ–è¢«æå‡ä¸ºç®¡ç†å‘˜) ===
            if (newStatus === 'member' || newStatus === 'administrator') {
                // åªæœ‰å½“ä¹‹å‰ä¸åœ¨ç¾¤é‡Œ (left/kicked/null) æ—¶æ‰è§†ä¸ºæ–°åŠ å…¥
                const isNewJoin = !oldStatus || oldStatus === 'left' || oldStatus === 'kicked'

                if (!isNewJoin) {
                    // ä»…æ›´æ–°æ ‡é¢˜å’Œç»‘å®šå…³ç³»
                    await prisma.chat.update({
                        where: { id: chatId },
                        data: { title, botId }
                    }).catch(() => {})
                    return
                }

                logger.info('[my_chat_member] æœºå™¨äººæ–°åŠ å…¥ç¾¤ç»„ï¼Œå¼€å§‹æƒé™æ£€æŸ¥', { chatId })

                // 1. æ£€æŸ¥é‚€è¯·äººæ˜¯å¦åœ¨ç™½åå•
                let autoAllowed = false

                if (actionUserId) {
                    const whitelistedUser = await prisma.whitelistedUser.findUnique({
                        where: { userId: actionUserId }
                    })

                    if (whitelistedUser) {
                        autoAllowed = true
                        logger.info('[my_chat_member] âœ… é‚€è¯·äººæ˜¯ç™½åå•ç”¨æˆ·ï¼Œè‡ªåŠ¨æˆæƒ', { inviter: actionUserId })

                        // é¡ºä¾¿æ›´æ–°ç™½åå•ç”¨æˆ·çš„ç”¨æˆ·å
                        if (actionUsername && actionUsername !== whitelistedUser.username) {
                            await prisma.whitelistedUser.update({
                                where: { userId: actionUserId },
                                data: { username: actionUsername }
                            }).catch(() => {})
                        }
                    }
                }

                // 2. æ›´æ–°æˆ–åˆ›å»ºç¾¤ç»„è®°å½•
                // ğŸ”¥ å…³é”®ç‚¹ï¼šå¦‚æœæ˜¯ç™½åå•ï¼Œç›´æ¥ create ä¸º APPROVEDï¼Œè€Œä¸æ˜¯ PENDING
                await prisma.chat.upsert({
                    where: { id: chatId },
                    create: {
                        id: chatId,
                        title,
                        botId,
                        status: autoAllowed ? 'APPROVED' : 'PENDING',
                        allowed: autoAllowed,
                        invitedBy: actionUserId || null,
                        invitedByUsername: actionUsername || null
                    },
                    update: {
                        title,
                        botId,
                        // å¦‚æœæ˜¯è‡ªåŠ¨æˆæƒï¼Œåˆ™æ›´æ–°çŠ¶æ€ï¼›å¦åˆ™ä¿æŒåŸæ ·ï¼Œä¸è¦†ç›–å¯èƒ½å·²æœ‰çš„è®¾ç½®
                        ...(autoAllowed ? { status: 'APPROVED', allowed: true } : {}),
                        // æ€»æ˜¯æ›´æ–°é‚€è¯·äººä¿¡æ¯
                        invitedBy: actionUserId || null,
                        invitedByUsername: actionUsername || null
                    }
                })

                // 3. ç¡®ä¿è®¾ç½®è®°å½•å­˜åœ¨ (é»˜è®¤å¼€å¯è®°è´¦)
                await prisma.setting.upsert({
                    where: { chatId },
                    create: {
                        chatId,
                        accountingEnabled: true,
                        addressVerificationEnabled: false
                    },
                    update: {
                        accountingEnabled: true // æœºå™¨äººè¿›ç¾¤é»˜è®¤å¼€å¯è®°è´¦
                    }
                })

                // 4. å¤„ç†åç»­åŠ¨ä½œ
                if (autoAllowed) {
                    // A. åˆå§‹åŒ–åŠŸèƒ½å¼€å…³
                    if (String(chatId).startsWith('-')) {
                        await ensureDefaultFeatures(chatId, prisma, true) // force=true ç¡®ä¿å¼€å¯

                        // åŒé‡ä¿é™©ï¼šç¡®ä¿åŠŸèƒ½çŠ¶æ€ä¸º enabled
                        await prisma.chatFeatureFlag.updateMany({
                            where: { chatId },
                            data: { enabled: true }
                        }).catch(() => {})
                    }

                    // B. å‘é€æ¬¢è¿è¯­
                    const welcomeMsg = await getWelcomeMessage(botId)
                    const msgToSend = welcomeMsg || (
                        `âœ… *æœºå™¨äººå·²æ¿€æ´»*\n\n` +
                        `æ„Ÿè°¢ç™½åå•ç”¨æˆ· ${actionUsername || actionFullName} çš„é‚€è¯·ã€‚\n` +
                        `æœ¬ç¾¤å·²è‡ªåŠ¨æˆæƒï¼ŒåŠŸèƒ½å·²å…¨éƒ¨å¼€å¯ï¼Œæ‚¨å¯ä»¥ç›´æ¥å¼€å§‹è®°è´¦ã€‚\n\n` +
                        `å‘é€ "ä½¿ç”¨è¯´æ˜" æŸ¥çœ‹æŒ‡ä»¤ã€‚`
                    )

                    try {
                        await ctx.reply(msgToSend, { parse_mode: 'Markdown' })
                    } catch (e) {
                        // Markdown å¤±è´¥å›é€€åˆ°çº¯æ–‡æœ¬
                        await ctx.reply(msgToSend).catch(() => {})
                    }

                } else {
                    // éç™½åå•ç”¨æˆ·é‚€è¯·ï¼Œæç¤ºéœ€å®¡æ ¸
                    await ctx.reply(
                        `ğŸ¤– *æœºå™¨äººå·²å…¥ç¾¤*\n\n` +
                        `âš ï¸ æœ¬ç¾¤å°šæœªæˆæƒã€‚\n` +
                        `é‚€è¯·äººï¼š${actionUsername || actionFullName} (ID: ${actionUserId})\n\n` +
                        `è¯·è”ç³»ç®¡ç†å‘˜åœ¨åå°é€šè¿‡å®¡æ ¸ï¼Œæˆ–ç”±ç™½åå•ç”¨æˆ·é‚€è¯·ã€‚`,
                        { parse_mode: 'Markdown' }
                    )
                }
            }

            // === åœºæ™¯ B: æœºå™¨äººè¢«è¸¢å‡ºæˆ–ç¦»å¼€ ===
            else if (newStatus === 'left' || newStatus === 'kicked') {
                logger.info('[my_chat_member] æœºå™¨äººè¢«ç§»é™¤ï¼Œæ‰§è¡Œå½»åº•æ¸…ç†', { chatId })
                await cleanupGroupData(chatId)
            }

        } catch (e) {
            logger.error('[my_chat_member] å¤„ç†å¼‚å¸¸', e)
        }
    })

}
// ç®¡ç†å‘˜ç›¸å…³å‘½ä»¤å¤„ç†å™¨
import { prisma } from '../../lib/db.js'
import { ensureDbChat } from '../database.js'
import { buildInlineKb, isAdmin, hasPermissionWithWhitelist, getEffectiveRate, getDisplayCurrencySymbol } from '../helpers.js'
import { setGlobalDailyCutoffHour } from '../utils.js'
import { getChat } from '../state.js'

/**
 * æœºå™¨äººé€€ç¾¤
 */
export function registerBotLeave(bot) {
  bot.hears(/^æœºå™¨äººé€€ç¾¤$/i, async (ctx) => {
    if (ctx.chat?.type === 'private') {
      return ctx.reply('æ­¤å‘½ä»¤ä»…åœ¨ç¾¤ç»„ä¸­ä½¿ç”¨')
    }

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æƒé™æ£€æŸ¥
    const chat = getChat(process.env.BOT_TOKEN, String(ctx.chat?.id || ''))
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ‰§è¡Œæ­¤æ“ä½œã€‚')
    }

    const chatId = String(ctx.chat?.id || '')

    try {
      // å¹¶è¡Œåˆ é™¤æ‰€æœ‰ç›¸å…³æ•°æ®
      await Promise.all([
        prisma.chatFeatureFlag.deleteMany({ where: { chatId } }),
        prisma.setting.deleteMany({ where: { chatId } }),
        prisma.operator.deleteMany({ where: { chatId } }),
        prisma.addressVerification.deleteMany({ where: { chatId } }),
        prisma.featureWarningLog.deleteMany({ where: { chatId } }),
        prisma.bill.deleteMany({ where: { chatId } }),
        prisma.income.deleteMany({ where: { chatId } }),
        prisma.dispatch.deleteMany({ where: { chatId } }),
        prisma.commission.deleteMany({ where: { chatId } })
      ])

      await prisma.chat.delete({ where: { id: chatId } }).catch(() => { })
      await ctx.leaveChat()
      console.log('[æœºå™¨äººé€€ç¾¤]', { chatId })
    } catch (e) {
      console.error('[æœºå™¨äººé€€ç¾¤]', e)
      try {
        await ctx.leaveChat()
      } catch { }
    }
  })
}

/**
 * ç¾¤åˆ—è¡¨ï¼šåˆ—å‡ºå½“å‰æœºå™¨äººæ‰€åœ¨çš„ç¾¤
 */
export function registerListGroups(bot) {
  bot.hears(/^ç¾¤åˆ—è¡¨$/i, async (ctx) => {
    // ä»…åœ¨ç§èŠæˆ–ç¾¤å†…ç®¡ç†å‘˜/ç™½åå•å¯ç”¨
    try {
      const isPrivate = ctx.chat?.type === 'private'
      if (!isPrivate) {
        // åœ¨ç¾¤èŠä¸­ï¼Œè¦æ±‚æœ‰æƒé™
        const chat = getChat(process.env.BOT_TOKEN, String(ctx.chat?.id || ''))
        if (!(await hasPermissionWithWhitelist(ctx, chat))) {
          return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜æˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ‰§è¡Œæ­¤æ“ä½œã€‚')
        }
      }

      // æŸ¥è¯¢å·²å…è®¸è¿è¡Œçš„ç¾¤
      const chats = await prisma.chat.findMany({
        where: { allowed: true },
        select: { id: true, title: true, status: true },
        orderBy: [{ title: 'asc' }]
      })

      if (!chats || chats.length === 0) {
        return ctx.reply('å½“å‰æœºå™¨äººå°šæœªåŠ å…¥ä»»ä½•å·²æˆæƒçš„ç¾¤ã€‚')
      }

      // é™åˆ¶è¾“å‡ºé•¿åº¦ï¼Œæœ€å¤šæ˜¾ç¤ºå‰ 50 ä¸ªï¼ˆä»…å±•ç¤ºç¾¤åç§°ï¼‰
      const list = chats.slice(0, 50).map(c => `â€¢ ${c.title || '(æ— æ ‡é¢˜)'}`)
      let text = ' ğŸ“œ ç¾¤åˆ—è¡¨ï¼ˆå‰50ï¼‰\n\n' + list.join('\n')
      if (chats.length > 50) text += `\n\n... ä»¥åŠå…¶ä»– ${chats.length - 50} ä¸ªç¾¤`
      await ctx.reply(text)
    } catch (e) {
      console.error('[ç¾¤åˆ—è¡¨] å¤±è´¥', e)
      await ctx.reply('âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * æŸ¥è¯¢æ±‡ç‡/æ˜ å°„è¡¨
 */
export function registerQueryRate(bot, ensureChat) {
  bot.hears(/^(æŸ¥è¯¢æ±‡ç‡|æŸ¥è¯¢æ˜ å°„è¡¨)(?:\s+(.+))?$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    const query = ctx.match[2]?.trim() || ''
    const chatId = await ensureDbChat(ctx, chat)

    try {
      // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ±‡ç‡è·å–å‡½æ•°
      const [setting, effectiveRate] = await Promise.all([
        prisma.setting.findUnique({
          where: { chatId },
          select: { feePercent: true }
        }),
        getEffectiveRate(chatId, ensureChat(ctx))
      ])

      let rateText = ''
      if (query) {
        const rate = parseFloat(query)
        if (!isNaN(rate) && rate > 0) {
          const code = (ensureChat(ctx)?.currencyCode || 'cny')
          const sym = getDisplayCurrencySymbol(code)
          rateText = `æŸ¥è¯¢æ±‡ç‡ ${rate.toFixed(2)} çš„æ˜ å°„å…³ç³»ï¼š\n` +
            `â€¢ 1 USDT = ${rate.toFixed(2)} ${sym}\n` +
            `â€¢ 1 ${code.toUpperCase()} = ${(1 / rate).toFixed(6)} USDT\n` +
            `â€¢ 100 ${code.toUpperCase()} = ${(100 / rate).toFixed(2)} USDT\n` +
            `â€¢ 100 USDT = ${(100 * rate).toFixed(2)} ${sym}`
        } else {
          rateText = `âŒ æ— æ•ˆçš„æ±‡ç‡å€¼ï¼š${query}`
        }
      } else {
        const chat = ensureChat(ctx)
        const fixedRate = chat?.fixedRate ?? null
        const realtimeRate = chat?.realtimeRate ?? null
        const feePercent = setting?.feePercent || 0
        const displayRate = effectiveRate ?? null
        const code = (chat?.currencyCode || 'cny')
        const sym = getDisplayCurrencySymbol(code)
        rateText = ' ğŸ’± æ±‡ç‡æ˜ å°„è¡¨ \n\n'

        if (fixedRate && displayRate) {
          rateText += `ã€å›ºå®šæ±‡ç‡ã€‘\n` +
            `â€¢ 1 USDT = ${Number(displayRate).toFixed(2)} ${sym}\n` +
            `â€¢ 1 ${code.toUpperCase()} = ${(1 / displayRate).toFixed(6)} USDT\n` +
            `â€¢ 100 ${code.toUpperCase()} = ${(100 / displayRate).toFixed(2)} USDT\n` +
            `â€¢ 100 USDT = ${(100 * displayRate).toFixed(2)} ${sym}\n\n`
        } else if (realtimeRate && displayRate) {
          rateText += `ã€å®æ—¶æ±‡ç‡ã€‘\n` +
            `â€¢ 1 USDT = ${Number(displayRate).toFixed(2)} ${sym}\n` +
            `â€¢ 1 ${code.toUpperCase()} = ${(1 / displayRate).toFixed(6)} USDT\n` +
            `â€¢ 100 ${code.toUpperCase()} = ${(100 / displayRate).toFixed(2)} USDT\n` +
            `â€¢ 100 USDT = ${(100 * displayRate).toFixed(2)} ${sym}\n\n`
        } else if (displayRate) {
          rateText += `ã€å½“å‰æ±‡ç‡ã€‘\n` +
            `â€¢ 1 USDT = ${Number(displayRate).toFixed(2)} ${sym}\n` +
            `â€¢ 1 ${code.toUpperCase()} = ${(1 / displayRate).toFixed(6)} USDT\n` +
            `â€¢ 100 ${code.toUpperCase()} = ${(100 / displayRate).toFixed(2)} USDT\n` +
            `â€¢ 100 USDT = ${(100 * displayRate).toFixed(2)} ${sym}\n\n`
        } else {
          rateText += `âš ï¸ æœªè®¾ç½®æ±‡ç‡\n\n`
        }

        if (feePercent > 0) {
          rateText += `ã€è´¹ç‡ã€‘${feePercent}%\n`
        }

        rateText += `\nğŸ’¡ æç¤ºï¼šä½¿ç”¨"æŸ¥è¯¢æ±‡ç‡ 7.2"å¯ä»¥æŸ¥è¯¢æŒ‡å®šæ±‡ç‡çš„æ˜ å°„å…³ç³»`
      }

      await ctx.reply(rateText, { ...(await buildInlineKb(ctx)) })
    } catch (e) {
      console.error('[æŸ¥è¯¢æ±‡ç‡]', e)
      await ctx.reply('âŒ æŸ¥è¯¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * ç¾¤å†…ç®¡ç†å‘˜ä¿¡æ¯ï¼ˆæ˜¾ç¤ºæ‰€æœ‰ç®¡ç†å‘˜å’Œæ“ä½œå‘˜ï¼‰
 */
export function registerAdminInfo(bot) {
  bot.hears(/^(ç®¡ç†å‘˜|æƒé™äºº|æ˜¾ç¤ºæ“ä½œå‘˜|æ˜¾ç¤ºæ“ä½œäºº)$/i, async (ctx) => {
    if (ctx.chat?.type === 'private') {
      return ctx.reply('æ­¤å‘½ä»¤ä»…åœ¨ç¾¤ç»„ä¸­ä½¿ç”¨')
    }

    const chatId = await ensureDbChat(ctx)

    try {
      const [admins, operators, setting] = await Promise.all([
        ctx.getChatAdministrators(),
        prisma.operator.findMany({ where: { chatId }, select: { username: true } }),
        prisma.setting.findUnique({ where: { chatId }, select: { everyoneAllowed: true } })
      ])

      // ğŸ”¥ åˆ†ç±»ï¼šç¾¤ä¸»ã€ç®¡ç†å‘˜ã€æ“ä½œå‘˜
      const creators = []
      const adminsList = []
      const operatorUsernames = new Set(operators.map(op => op.username))

      admins
        .filter(a => !a.user.is_bot)
        .forEach(a => {
          const name = a.user.username
            ? `@${a.user.username}`
            : `${a.user.first_name || ''} ${a.user.last_name || ''}`.trim() || `ç”¨æˆ·${a.user.id}`
          const status = a.status === 'creator' ? 'ğŸ‘‘ ç¾¤ä¸»' : 'ğŸ‘¤ ç®¡ç†å‘˜'
          const item = { name, status, isCreator: a.status === 'creator' }

          if (a.status === 'creator') {
            creators.push(item)
          } else {
            adminsList.push(item)
          }
        })

      // ğŸ”¥ è¿‡æ»¤å‡ºéç¾¤ä¸»å’Œç®¡ç†å‘˜çš„æ“ä½œå‘˜
      const otherOperators = operators
        .filter(op => {
          const username = op.username.startsWith('@') ? op.username : `@${op.username}`
          return !creators.some(c => c.name === username) &&
            !adminsList.some(a => a.name === username)
        })
        .map(op => op.username)

      let text = ' ğŸ‘¥ ç¾¤ç»„æƒé™ä¿¡æ¯ \n\n'

      // ğŸ”¥ ç¾¤ä¸»æœ€ä¸Šé¢
      if (creators.length > 0) {
        text += `ã€ğŸ‘‘ ç¾¤ä¸»ã€‘\n${creators.map(c => `â€¢ ${c.name}`).join('\n')}\n\n`
      }

      // ğŸ”¥ ç„¶åç®¡ç†å‘˜
      if (adminsList.length > 0) {
        text += `ã€ğŸ‘¤ ç®¡ç†å‘˜ã€‘\n${adminsList.map(a => `â€¢ ${a.name}`).join('\n')}\n\n`
      }

      // ğŸ”¥ ç„¶åå…¶ä»–æ“ä½œå‘˜
      if (setting?.everyoneAllowed) {
        text += `ã€âœ… æƒé™è®¾ç½®ã€‘\nâ€¢ æ‰€æœ‰äººå¯æ“ä½œ\n\n`
      } else if (otherOperators.length > 0) {
        text += `ã€ğŸ‘¤ æ“ä½œå‘˜ã€‘\n${otherOperators.map(op => `â€¢ ${op}`).join('\n')}\n\n`
      } else {
        text += `ã€ğŸ‘¤ æ“ä½œå‘˜ã€‘\nâ€¢ ä»…ç®¡ç†å‘˜å¯æ“ä½œ\n\n`
      }

      await ctx.reply(text, { ...(await buildInlineKb(ctx)) })
    } catch (e) {
      console.error('[ç¾¤å†…ç®¡ç†å‘˜]', e)
      await ctx.reply('âŒ è·å–ä¿¡æ¯å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

import { prisma } from '../../lib/db.js'
import { ensureCurrentBotId } from '../bot-identity.js'
import logger from '../logger.js'

// ===== è‡ªå®šä¹‰æŒ‡ä»¤è§¦å‘ï¼ˆæŒ‰ bot ç»´åº¦ï¼‰ =====
const CUSTOM_CMDS_CACHE = {
    map: null, // Record<string, { text?: string; imageUrl?: string }>
    ts: 0,
}

async function loadCustomCommandsForBot(botId) {
    // 5åˆ†é’Ÿç¼“å­˜
    const now = Date.now()
    if (CUSTOM_CMDS_CACHE.map && now - CUSTOM_CMDS_CACHE.ts < 5 * 60 * 1000) return CUSTOM_CMDS_CACHE.map
    try {
        const key = `customcmds:bot:${botId}`
        const row = await prisma.globalConfig.findUnique({ where: { key } })
        let map = {}
        if (row?.value) {
            try { map = JSON.parse(String(row.value) || '{}') } catch { }
        }
        CUSTOM_CMDS_CACHE.map = map
        CUSTOM_CMDS_CACHE.ts = now
        return map
    } catch {
        return {}
    }
}

export function registerCustomCommandHandlers(bot) {
    bot.on('text', async (ctx, next) => {
        try {
            const text = (ctx.message?.text || '').trim()
            if (!text) return next()
            const botId = await ensureCurrentBotId(bot)
            const map = await loadCustomCommandsForBot(botId)
            if (!map || typeof map !== 'object') return next()
            const key = text.toLowerCase()
            const item = map[key]
            if (!item) return next()

            const chatId = String(ctx.chat?.id || '')
            // ç®€æ´æ—¥å¿—ï¼ˆå‘½ä¸­ï¼‰
            logger.info('[customcmd][hit]', { chatId, name: key })

            if (item.imageUrl && item.text) {
                await ctx.replyWithPhoto(item.imageUrl, { caption: item.text })
                return
            } else if (item.imageUrl) {
                await ctx.replyWithPhoto(item.imageUrl)
                return
            } else if (item.text) {
                await ctx.reply(item.text)
                return
            }
            return next()
        } catch (e) {
            logger.error('[customcmd][error]', e?.message || e)
            return next()
        }
    })
}
// è®¾ç½®ç›¸å…³å‘½ä»¤å¤„ç†å™¨
import { prisma } from '../../lib/db.js'
import { ensureDbChat, setChatCurrencyCode, updateSettings, getChatDailyCutoffHour } from '../database.js'
import { buildInlineKb, isAdmin, hasPermissionWithWhitelist, getEffectiveRate, fetchUsdtToFiatRate, getDisplayCurrencySymbol } from '../helpers.js'
import { formatMoney } from '../utils.js'

/**
 * è®¾ç½®è´¹ç‡
 */
export function registerSetFee(bot, ensureChat) {
  bot.hears(/^è®¾ç½®è´¹ç‡\s*(-?\d+(?:\.\d+)?)%?$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æƒé™æ£€æŸ¥å‡½æ•°
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const m = ctx.message.text.match(/(-?\d+(?:\.\d+)?)/)
    if (!m) return

    let v = Number(m[1])
    if (Math.abs(v) <= 1) v = v * 100
    chat.feePercent = Math.max(-100, Math.min(100, v))

    await updateSettings(chatId, { feePercent: chat.feePercent })
    await ctx.reply(`âœ… è´¹ç‡å·²è®¾ç½®ä¸º ${chat.feePercent}%`, { ...(await buildInlineKb(ctx)) })
  })
}

/**
 * è®¾ç½®æ±‡ç‡
 */
export function registerSetRate(bot, ensureChat) {
  // ğŸ”¥ æ”¯æŒæœ‰æ— ç©ºæ ¼ï¼šè®¾ç½®æ±‡ç‡ 7.2 æˆ– è®¾ç½®æ±‡ç‡7.2
  bot.hears(/^è®¾ç½®æ±‡ç‡\s*(\d+(?:\.\d+)?)?$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æƒé™æ£€æŸ¥å‡½æ•°
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    // ğŸ”¥ æ”¯æŒæœ‰æ— ç©ºæ ¼ï¼šè®¾ç½®æ±‡ç‡ 7.2 æˆ– è®¾ç½®æ±‡ç‡7.2
    const m = ctx.message.text.match(/^è®¾ç½®æ±‡ç‡\s*(\d+(?:\.\d+)?)?$/i)
    const val = m && m[1] ? Number(m[1]) : null

    if (val == null) {
      const settings = await prisma.setting.findUnique({ where: { chatId } })
      const current = settings?.fixedRate ?? settings?.realtimeRate ?? null
      return ctx.reply(`å½“å‰æ±‡ç‡ï¼š${current ?? 'æœªè®¾ç½®'}\nç”¨æ³•ï¼šè®¾ç½®æ±‡ç‡7.2 æˆ– è®¾ç½®æ±‡ç‡ 7.2`)
    }

    chat.fixedRate = val
    chat.realtimeRate = null
    await updateSettings(chatId, { fixedRate: val, realtimeRate: null })
    await ctx.reply(`âœ… å›ºå®šæ±‡ç‡å·²è®¾ç½®ä¸º ${val}`, { ...(await buildInlineKb(ctx)) })
  })
}

/**
 * è®¾ç½®å®æ—¶æ±‡ç‡
 * ğŸ”¥ ä½¿ç”¨ OKX C2C ç¬¬ä¸€ä¸ªæ±‡ç‡ï¼ˆä¸ z0 å‘½ä»¤ä¿æŒä¸€è‡´ï¼‰
 */
export function registerSetRealtimeRate(bot, ensureChat) {
  bot.hears(/^è®¾ç½®å®æ—¶æ±‡ç‡$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æƒé™æ£€æŸ¥å‡½æ•°
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const code = chat.currencyCode || 'cny'
    
    // ğŸ”¥ ä½¿ç”¨ OKX C2C API è·å–ç¬¬ä¸€ä¸ªæ±‡ç‡ï¼ˆä¸ z0 å‘½ä»¤ä¿æŒä¸€è‡´ï¼‰
    try {
      const { getOKXC2CSellers } = await import('../../lib/okx-api.js')
      const sellers = await getOKXC2CSellers('all')
      
      if (!sellers || sellers.length === 0) {
        return ctx.reply('âŒ è·å–OKXå®æ—¶æ±‡ç‡å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }

      // ä½¿ç”¨ç¬¬ä¸€ä¸ªæ±‡ç‡ï¼ˆæœ€ä½ä»·æ ¼ï¼Œä¸ z0 å‘½ä»¤æ˜¾ç¤ºçš„ç¬¬ä¸€ä¸ªä¸€è‡´ï¼‰
      const rate = sellers[0].price

    chat.realtimeRate = rate
    chat.fixedRate = null
    await updateSettings(chatId, { realtimeRate: rate, fixedRate: null })
    await ctx.reply(`âœ… å·²å¯ç”¨å®æ—¶æ±‡ç‡ï¼š${rate.toFixed(2)} (${getDisplayCurrencySymbol(code)}/${'USDT'})`, { ...(await buildInlineKb(ctx)) })
    } catch (e) {
      console.error('[è®¾ç½®å®æ—¶æ±‡ç‡]', e)
      await ctx.reply('âŒ è·å–å®æ—¶æ±‡ç‡å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * åˆ·æ–°å®æ—¶æ±‡ç‡
 * ğŸ”¥ ä½¿ç”¨ OKX C2C ç¬¬ä¸€ä¸ªæ±‡ç‡ï¼ˆä¸ z0 å‘½ä»¤ä¿æŒä¸€è‡´ï¼‰
 */
export function registerRefreshRate(bot, ensureChat) {
  bot.hears(/^åˆ·æ–°å®æ—¶æ±‡ç‡$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    const chatId = await ensureDbChat(ctx, chat)
    const code = chat.currencyCode || 'cny'
    
    // ğŸ”¥ ä½¿ç”¨ OKX C2C API è·å–ç¬¬ä¸€ä¸ªæ±‡ç‡ï¼ˆä¸ z0 å‘½ä»¤ä¿æŒä¸€è‡´ï¼‰
    try {
      const { getOKXC2CSellers } = await import('../../lib/okx-api.js')
      const sellers = await getOKXC2CSellers('all')
      
      if (!sellers || sellers.length === 0) {
        return ctx.reply('âŒ è·å–OKXå®æ—¶æ±‡ç‡å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }

      // ä½¿ç”¨ç¬¬ä¸€ä¸ªæ±‡ç‡ï¼ˆæœ€ä½ä»·æ ¼ï¼Œä¸ z0 å‘½ä»¤æ˜¾ç¤ºçš„ç¬¬ä¸€ä¸ªä¸€è‡´ï¼‰
      const rate = sellers[0].price

    chat.realtimeRate = rate
    await updateSettings(chatId, { realtimeRate: rate })
    await ctx.reply(`âœ… å®æ—¶æ±‡ç‡å·²æ›´æ–°ï¼š${rate.toFixed(2)} (${getDisplayCurrencySymbol(code)}/${'USDT'})`, { ...(await buildInlineKb(ctx)) })
    } catch (e) {
      console.error('[åˆ·æ–°å®æ—¶æ±‡ç‡]', e)
      await ctx.reply('âŒ è·å–å®æ—¶æ±‡ç‡å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * æ˜¾ç¤ºå®æ—¶æ±‡ç‡
 */
export function registerShowRate(bot, ensureChat) {
  bot.hears(/^æ˜¾ç¤ºå®æ—¶æ±‡ç‡$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    const chatId = await ensureDbChat(ctx, chat)
    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ±‡ç‡è·å–å‡½æ•°
    const rate = await getEffectiveRate(chatId, chat)
    const fixedRate = chat.fixedRate ?? (rate && chat.realtimeRate === null ? rate : null)
    const realtimeRate = chat.realtimeRate ?? (rate && chat.fixedRate === null ? rate : null)
    const code = chat.currencyCode || 'cny'
    const sym = getDisplayCurrencySymbol(code)

    if (fixedRate) {
      await ctx.reply(`å½“å‰æ±‡ç‡ï¼š${Number(fixedRate).toFixed(2)} ${sym}/USDTï¼ˆå›ºå®šï¼‰`, { ...(await buildInlineKb(ctx)) })
    } else if (realtimeRate) {
      await ctx.reply(`å½“å‰æ±‡ç‡ï¼š${Number(realtimeRate).toFixed(2)} ${sym}/USDTï¼ˆå®æ—¶ï¼‰`, { ...(await buildInlineKb(ctx)) })
    } else {
      await ctx.reply('å½“å‰æœªè®¾ç½®æ±‡ç‡', { ...(await buildInlineKb(ctx)) })
    }
  })
}

// æ–°å¢ï¼šè®¾ç½®/åˆ‡æ¢è´§å¸ ä¸ æ˜¾ç¤ºè´§å¸
export function registerSetCurrency(bot, ensureChat) {
  const whitelist = new Set(['cny', 'usd', 'jpy', 'twd', 'krw', 'eur', 'hkd', 'gbp', 'aud', 'chf', 'cad', 'nzd'])
  bot.hears(/^(è®¾ç½®è´§å¸|åˆ‡æ¢è´§å¸|è´§å¸)\s*([A-Za-z]{3,5})?$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    const chatId = await ensureDbChat(ctx, chat)
    const m = ctx.message.text.match(/^(?:è®¾ç½®è´§å¸|åˆ‡æ¢è´§å¸|è´§å¸)\s*([A-Za-z]{3,5})?$/i)
    const codeRaw = m && m[1] ? m[1] : ''
    if (!codeRaw) {
      return ctx.reply(`å½“å‰è´§å¸ï¼š${(chat.currencyCode || 'cny').toUpperCase()}\nå¯é€‰ï¼šCNY, USD, EUR, JPY, GBP, AUD, CHF, CAD, NZD, TWD, KRW, HKD`)
    }
    const code = codeRaw.toLowerCase()
    if (!whitelist.has(code)) {
      return ctx.reply('âŒ ä¸æ”¯æŒçš„è´§å¸ã€‚å¯é€‰ï¼šCNY, USD, EUR, JPY, GBP, AUD, CHF, CAD, NZD, TWD, KRW, HKD')
    }
    await setChatCurrencyCode(chatId, code)
    chat.currencyCode = code
    // è‹¥å½“å‰ä¸ºå®æ—¶æ±‡ç‡æ¨¡å¼ï¼Œåˆ·æ–°ä¸ºæ–°å¸ç§æ±‡ç‡
    if (chat.fixedRate == null) {
      const rate = await fetchUsdtToFiatRate(code)
      if (rate) {
        chat.realtimeRate = rate
        await updateSettings(chatId, { realtimeRate: rate, fixedRate: null })
      }
    }
    await ctx.reply(`âœ… å·²åˆ‡æ¢è´§å¸ä¸º ${code.toUpperCase()}`)
  })
}

export function registerShowCurrency(bot, ensureChat) {
  bot.hears(/^æ˜¾ç¤ºè´§å¸$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    const code = (chat.currencyCode || 'cny').toUpperCase()
    const sym = getDisplayCurrencySymbol(chat.currencyCode || 'cny')
    await ctx.reply(`å½“å‰è´§å¸ï¼š${code}ï¼ˆ${sym}ï¼‰`)
  })
}

// è®¾ç½®æ—¥åˆ‡æ—¶é—´ï¼ˆç¾¤çº§ä¼˜å…ˆç”Ÿæ•ˆï¼ŒèŒƒå›´0-23ï¼›ä¸ä¼ å‚æ•°åˆ™æ˜¾ç¤ºå½“å‰è®¾ç½®å’Œé»˜è®¤ï¼‰
export function registerSetDailyCutoff(bot, ensureChat) {
  const pattern = /^(?:è®¾ç½®æ—¥åˆ‡(?:æ—¶é—´)?)[\s]*(\d{1,2})?$/i
  bot.hears(pattern, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }
    const chatId = await ensureDbChat(ctx, chat)
    const m = ctx.message.text.match(pattern)
    const valStr = m && m[1] != null ? m[1] : null
    if (valStr == null) {
      const current = await getChatDailyCutoffHour(chatId)
      return ctx.reply(`å½“å‰æ—¥åˆ‡æ—¶é—´ï¼š${current} ç‚¹ï¼ˆ0-23ï¼Œé»˜è®¤0ç‚¹=å‡Œæ™¨ï¼‰\nç”¨æ³•ï¼šè®¾ç½®æ—¥åˆ‡æ—¶é—´ 2 æˆ– è®¾ç½®æ—¥åˆ‡ 2`)
    }
    const hour = Number(valStr)
    if (!Number.isInteger(hour) || hour < 0 || hour > 23) {
      return ctx.reply('âŒ æ—¥åˆ‡æ—¶é—´å¿…é¡»æ˜¯ 0-23 çš„æ•´æ•°')
    }
    await updateSettings(chatId, { dailyCutoffHour: hour })
    return ctx.reply(`âœ… å·²è®¾ç½®æœ¬ç¾¤æ—¥åˆ‡æ—¶é—´ä¸º ${hour} ç‚¹ï¼ˆ0-23ï¼‰`)
  })
}

/**
 * è®¾ç½®è¶…æŠ¼æé†’é¢åº¦
 */
export function registerOverDepositLimit(bot, ensureChat) {
  // ğŸ”¥ æ”¯æŒæœ‰æ— ç©ºæ ¼ï¼šè®¾ç½®é¢åº¦ 10000 æˆ– è®¾ç½®é¢åº¦10000
  bot.hears(/^è®¾ç½®é¢åº¦\s*(\d+(?:\.\d+)?)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æƒé™æ£€æŸ¥å‡½æ•°
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const m = ctx.message.text.match(/^è®¾ç½®é¢åº¦\s*(\d+(?:\.\d+)?)$/i)
    const limit = m && m[1] ? parseFloat(m[1]) : 0
    const chatId = await ensureDbChat(ctx, chat)

    try {
      await updateSettings(chatId, { overDepositLimit: limit })

      if (limit === 0) {
        await ctx.reply('âœ… å·²å…³é—­è¶…æŠ¼æé†’', { ...(await buildInlineKb(ctx)) })
      } else {
        await ctx.reply(`âœ… å·²è®¾ç½®è¶…æŠ¼æé†’é¢åº¦ä¸º ${formatMoney(limit)} å…ƒ`, { ...(await buildInlineKb(ctx)) })
      }
    } catch (e) {
      console.error('[è®¾ç½®é¢åº¦]', e)
      await ctx.reply('âŒ è®¾ç½®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

/**
 * æ‰“å¼€/å…³é—­è®¡ç®—å™¨åŠŸèƒ½
 */
export function registerCalculatorToggle(bot, ensureChat) {
  bot.hears(/^(æ‰“å¼€è®¡ç®—å™¨|å…³é—­è®¡ç®—å™¨)$/i, async (ctx) => {
    const chat = ensureChat(ctx)
    if (!chat) return

    // ğŸ”¥ ä¼˜åŒ–ï¼šä½¿ç”¨ç»Ÿä¸€çš„æƒé™æ£€æŸ¥å‡½æ•°
    if (!(await hasPermissionWithWhitelist(ctx, chat))) {
      return ctx.reply('âš ï¸ æ‚¨æ²¡æœ‰æƒé™ã€‚åªæœ‰ç®¡ç†å‘˜ã€æ“ä½œäººæˆ–ç™½åå•ç”¨æˆ·å¯ä»¥æ“ä½œã€‚')
    }

    const chatId = await ensureDbChat(ctx, chat)
    const text = ctx.message.text.trim()
    const enabled = /^æ‰“å¼€è®¡ç®—å™¨$/i.test(text)

    try {
      await updateSettings(chatId, { calculatorEnabled: enabled })
      await ctx.reply(
        enabled
          ? 'âœ… å·²æ‰“å¼€è®¡ç®—å™¨åŠŸèƒ½ï¼Œç°åœ¨æ”¯æŒæ•°å­¦è®¡ç®—ï¼ˆå¦‚ï¼š288-32ã€288*2ã€288/2ã€288+21ï¼‰'
          : 'â¸ï¸ å·²å…³é—­è®¡ç®—å™¨åŠŸèƒ½ï¼Œä¸å†æ”¯æŒæ•°å­¦è®¡ç®—',
        { ...(await buildInlineKb(ctx)) }
      )
    } catch (e) {
      console.error('[è®¡ç®—å™¨å¼€å…³]', e)
      await ctx.reply('âŒ è®¾ç½®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•')
    }
  })
}

